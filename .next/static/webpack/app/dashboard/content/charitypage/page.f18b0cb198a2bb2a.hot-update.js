"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/content/charitypage/page",{

/***/ "(app-pages-browser)/./node_modules/gsap/Observer.js":
/*!***************************************!*\
  !*** ./node_modules/gsap/Observer.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observer: function() { return /* binding */ Observer; },\n/* harmony export */   _getProxyProp: function() { return /* binding */ _getProxyProp; },\n/* harmony export */   _getScrollFunc: function() { return /* binding */ _getScrollFunc; },\n/* harmony export */   _getTarget: function() { return /* binding */ _getTarget; },\n/* harmony export */   _getVelocityProp: function() { return /* binding */ _getVelocityProp; },\n/* harmony export */   _horizontal: function() { return /* binding */ _horizontal; },\n/* harmony export */   _isViewport: function() { return /* binding */ _isViewport; },\n/* harmony export */   _proxies: function() { return /* binding */ _proxies; },\n/* harmony export */   _scrollers: function() { return /* binding */ _scrollers; },\n/* harmony export */   _vertical: function() { return /* binding */ _vertical; },\n/* harmony export */   \"default\": function() { return /* binding */ Observer; }\n/* harmony export */ });\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\n/*!\n * Observer 3.12.7\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _clamp, _win, _doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger, _root, _normalizer, _eventTypes, _context, _getGSAP = function _getGSAP() {\n    return gsap ||  true && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _startup = 1, _observers = [], _scrollers = [], _proxies = [], _getTime = Date.now, _bridge = function _bridge(name, value) {\n    return value;\n}, _integrate = function _integrate() {\n    var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;\n    scrollers.push.apply(scrollers, _scrollers);\n    proxies.push.apply(proxies, _proxies);\n    _scrollers = scrollers;\n    _proxies = proxies;\n    _bridge = function _bridge(name, value) {\n        return data[name](value);\n    };\n}, _getProxyProp = function _getProxyProp(element, property) {\n    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\n}, _isViewport = function _isViewport(el) {\n    return !!~_root.indexOf(el);\n}, _addListener = function _addListener(element, type, func, passive, capture) {\n    return element.addEventListener(type, func, {\n        passive: passive !== false,\n        capture: !!capture\n    });\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    return element.removeEventListener(type, func, !!capture);\n}, _scrollLeft = \"scrollLeft\", _scrollTop = \"scrollTop\", _onScroll = function _onScroll() {\n    return _normalizer && _normalizer.isPressed || _scrollers.cache++;\n}, _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {\n    var cachingFunc = function cachingFunc(value) {\n        // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\n        if (value || value === 0) {\n            _startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\n            var isNormalizing = _normalizer && _normalizer.isPressed;\n            value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\n            f(value);\n            cachingFunc.cacheID = _scrollers.cache;\n            isNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\n        } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\n            cachingFunc.cacheID = _scrollers.cache;\n            cachingFunc.v = f();\n        }\n        return cachingFunc.v + cachingFunc.offset;\n    };\n    cachingFunc.offset = 0;\n    return f && cachingFunc;\n}, _horizontal = {\n    s: _scrollLeft,\n    p: \"left\",\n    p2: \"Left\",\n    os: \"right\",\n    os2: \"Right\",\n    d: \"width\",\n    d2: \"Width\",\n    a: \"x\",\n    sc: _scrollCacheFunc(function(value) {\n        return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n    })\n}, _vertical = {\n    s: _scrollTop,\n    p: \"top\",\n    p2: \"Top\",\n    os: \"bottom\",\n    os2: \"Bottom\",\n    d: \"height\",\n    d2: \"Height\",\n    a: \"y\",\n    op: _horizontal,\n    sc: _scrollCacheFunc(function(value) {\n        return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n    })\n}, _getTarget = function _getTarget(t, self) {\n    return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null);\n}, _getScrollFunc = function _getScrollFunc(element, _ref) {\n    var s = _ref.s, sc = _ref.sc;\n    // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n    _isViewport(element) && (element = _doc.scrollingElement || _docEl);\n    var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;\n    !~i && (i = _scrollers.push(element) - 1);\n    _scrollers[i + offset] || _addListener(element, \"scroll\", _onScroll); // clear the cache when a scroll occurs\n    var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {\n        return arguments.length ? element[s] = value : element[s];\n    })));\n    func.target = element;\n    prev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.\n    return func;\n}, _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {\n    var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update(value, force) {\n        var t = _getTime();\n        if (force || t - t1 > min) {\n            v2 = v1;\n            v1 = value;\n            t2 = t1;\n            t1 = t;\n        } else if (useDelta) {\n            v1 += value;\n        } else {\n            // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\n            v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);\n        }\n    }, reset = function reset() {\n        v2 = v1 = useDelta ? 0 : v1;\n        t2 = t1 = 0;\n    }, getVelocity = function getVelocity(latestValue) {\n        var tOld = t2, vOld = v2, t = _getTime();\n        (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n        return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\n    };\n    return {\n        update: update,\n        reset: reset,\n        getVelocity: getVelocity\n    };\n}, _getEvent = function _getEvent(e, preventDefault) {\n    preventDefault && !e._gsapAllow && e.preventDefault();\n    return e.changedTouches ? e.changedTouches[0] : e;\n}, _getAbsoluteMax = function _getAbsoluteMax(a) {\n    var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);\n    return Math.abs(max) >= Math.abs(min) ? max : min;\n}, _setScrollTrigger = function _setScrollTrigger() {\n    ScrollTrigger = gsap.core.globals().ScrollTrigger;\n    ScrollTrigger && ScrollTrigger.core && _integrate();\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (!_coreInitted && gsap && typeof document !== \"undefined\" && document.body) {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n        _root = [\n            _win,\n            _doc,\n            _docEl,\n            _body\n        ];\n        _clamp = gsap.utils.clamp;\n        _context = gsap.core.context || function() {};\n        _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n        _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\n        _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n        setTimeout(function() {\n            return _startup = 0;\n        }, 500);\n        _setScrollTrigger();\n        _coreInitted = 1;\n    }\n    return _coreInitted;\n};\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\nvar Observer = /*#__PURE__*/ function() {\n    function Observer(vars) {\n        this.init(vars);\n    }\n    var _proto = Observer.prototype;\n    _proto.init = function init(vars) {\n        _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n        ScrollTrigger || _setScrollTrigger();\n        var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;\n        this.target = target = _getTarget(target) || _docEl;\n        this.vars = vars;\n        ignore && (ignore = gsap.utils.toArray(ignore));\n        tolerance = tolerance || 1e-9;\n        dragMinimum = dragMinimum || 0;\n        wheelSpeed = wheelSpeed || 1;\n        scrollSpeed = scrollSpeed || 1;\n        type = type || \"wheel,touch,pointer\";\n        debounce = debounce !== false;\n        lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\n        var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault && vars.passive !== false, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\", // for devices that accommodate mouse events and touch events, we need to distinguish.\n        isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc, deltaX = [\n            0,\n            0,\n            0\n        ], // wheel, scroll, pointer/touch\n        deltaY = [\n            0,\n            0,\n            0\n        ], onClickTime = 0, clickCapture = function clickCapture() {\n            return onClickTime = _getTime();\n        }, _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {\n            return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);\n        }, onStopFunc = function onStopFunc() {\n            self._vx.reset();\n            self._vy.reset();\n            onStopDelayedCall.pause();\n            onStop && onStop(self);\n        }, update = function update() {\n            var dx = self.deltaX = _getAbsoluteMax(deltaX), dy = self.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;\n            onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\n            if (changedX) {\n                onRight && self.deltaX > 0 && onRight(self);\n                onLeft && self.deltaX < 0 && onLeft(self);\n                onChangeX && onChangeX(self);\n                onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\n                prevDeltaX = self.deltaX;\n                deltaX[0] = deltaX[1] = deltaX[2] = 0;\n            }\n            if (changedY) {\n                onDown && self.deltaY > 0 && onDown(self);\n                onUp && self.deltaY < 0 && onUp(self);\n                onChangeY && onChangeY(self);\n                onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\n                prevDeltaY = self.deltaY;\n                deltaY[0] = deltaY[1] = deltaY[2] = 0;\n            }\n            if (moved || dragged) {\n                onMove && onMove(self);\n                if (dragged) {\n                    onDragStart && dragged === 1 && onDragStart(self);\n                    onDrag && onDrag(self);\n                    dragged = 0;\n                }\n                moved = false;\n            }\n            locked && !(locked = false) && onLockAxis && onLockAxis(self);\n            if (wheeled) {\n                onWheel(self);\n                wheeled = false;\n            }\n            id = 0;\n        }, onDelta = function onDelta(x, y, index) {\n            deltaX[index] += x;\n            deltaY[index] += y;\n            self._vx.update(x);\n            self._vy.update(y);\n            debounce ? id || (id = requestAnimationFrame(update)) : update();\n        }, onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {\n            if (lockAxis && !axis) {\n                self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n                locked = true;\n            }\n            if (axis !== \"y\") {\n                deltaX[2] += x;\n                self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\n            }\n            if (axis !== \"x\") {\n                deltaY[2] += y;\n                self._vy.update(y, true);\n            }\n            debounce ? id || (id = requestAnimationFrame(update)) : update();\n        }, _onDrag = function _onDrag(e) {\n            if (_ignoreCheck(e, 1)) {\n                return;\n            }\n            e = _getEvent(e, preventDefault);\n            var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y, isDragging = self.isDragging;\n            self.x = x;\n            self.y = y;\n            if (isDragging || (dx || dy) && (Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum)) {\n                dragged = isDragging ? 2 : 1; // dragged: 0 = not dragging, 1 = first drag, 2 = normal drag\n                isDragging || (self.isDragging = true);\n                onTouchOrPointerDelta(dx, dy);\n            }\n        }, _onPress = self.onPress = function(e) {\n            if (_ignoreCheck(e, 1) || e && e.button) {\n                return;\n            }\n            self.axis = axis = null;\n            onStopDelayedCall.pause();\n            self.isPressed = true;\n            e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\n            prevDeltaX = prevDeltaY = 0;\n            self.startX = self.x = e.clientX;\n            self.startY = self.y = e.clientY;\n            self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\n            self._vy.reset();\n            _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);\n            self.deltaX = self.deltaY = 0;\n            onPress && onPress(self);\n        }, _onRelease = self.onRelease = function(e) {\n            if (_ignoreCheck(e, 1)) {\n                return;\n            }\n            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n            var isTrackingDrag = !isNaN(self.y - self.startY), wasDragging = self.isDragging, isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\n            eventData = _getEvent(e);\n            if (!isDragNotClick && isTrackingDrag) {\n                self._vx.reset();\n                self._vy.reset(); //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.\n                if (preventDefault && allowClicks) {\n                    gsap.delayedCall(0.08, function() {\n                        // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n                        if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n                            if (e.target.click) {\n                                //some browsers (like mobile Safari) don't properly trigger the click event\n                                e.target.click();\n                            } else if (ownerDoc.createEvent) {\n                                var syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n                                e.target.dispatchEvent(syntheticEvent);\n                            }\n                        }\n                    });\n                }\n            }\n            self.isDragging = self.isGesturing = self.isPressed = false;\n            onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);\n            dragged && update(); // in case debouncing, we don't want onDrag to fire AFTER onDragEnd().\n            onDragEnd && wasDragging && onDragEnd(self);\n            onRelease && onRelease(self, isDragNotClick);\n        }, _onGestureStart = function _onGestureStart(e) {\n            return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);\n        }, _onGestureEnd = function _onGestureEnd() {\n            return (self.isGesturing = false) || onGestureEnd(self);\n        }, onScroll = function onScroll(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            var x = scrollFuncX(), y = scrollFuncY();\n            onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n            scrollX = x;\n            scrollY = y;\n            onStop && onStopDelayedCall.restart(true);\n        }, _onWheel = function _onWheel(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            e = _getEvent(e, preventDefault);\n            onWheel && (wheeled = true);\n            var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n            onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n            onStop && !isNormalizer && onStopDelayedCall.restart(true);\n        }, _onMove = function _onMove(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y;\n            self.x = x;\n            self.y = y;\n            moved = true;\n            onStop && onStopDelayedCall.restart(true);\n            (dx || dy) && onTouchOrPointerDelta(dx, dy);\n        }, _onHover = function _onHover(e) {\n            self.event = e;\n            onHover(self);\n        }, _onHoverEnd = function _onHoverEnd(e) {\n            self.event = e;\n            onHoverEnd(self);\n        }, _onClick = function _onClick(e) {\n            return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\n        };\n        onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n        self.deltaX = self.deltaY = 0;\n        self._vx = _getVelocityProp(0, 50, true);\n        self._vy = _getVelocityProp(0, 50, true);\n        self.scrollX = scrollFuncX;\n        self.scrollY = scrollFuncY;\n        self.isDragging = self.isGesturing = self.isPressed = false;\n        _context(this);\n        self.enable = function(e) {\n            if (!self.isEnabled) {\n                _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n                type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, passive, capture);\n                type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, passive, capture);\n                if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\n                    _addListener(target, _eventTypes[0], _onPress, passive, capture);\n                    _addListener(ownerDoc, _eventTypes[2], _onRelease);\n                    _addListener(ownerDoc, _eventTypes[3], _onRelease);\n                    allowClicks && _addListener(target, \"click\", clickCapture, true, true);\n                    onClick && _addListener(target, \"click\", _onClick);\n                    onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n                    onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n                    onHover && _addListener(target, _pointerType + \"enter\", _onHover);\n                    onHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\n                    onMove && _addListener(target, _pointerType + \"move\", _onMove);\n                }\n                self.isEnabled = true;\n                self.isDragging = self.isGesturing = self.isPressed = moved = dragged = false;\n                self._vx.reset();\n                self._vy.reset();\n                scrollX = scrollFuncX();\n                scrollY = scrollFuncY();\n                e && e.type && _onPress(e);\n                onEnable && onEnable(self);\n            }\n            return self;\n        };\n        self.disable = function() {\n            if (self.isEnabled) {\n                // only remove the _onScroll listener if there aren't any others that rely on the functionality.\n                _observers.filter(function(o) {\n                    return o !== self && _isViewport(o.target);\n                }).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n                if (self.isPressed) {\n                    self._vx.reset();\n                    self._vy.reset();\n                    _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n                }\n                _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n                _removeListener(target, \"wheel\", _onWheel, capture);\n                _removeListener(target, _eventTypes[0], _onPress, capture);\n                _removeListener(ownerDoc, _eventTypes[2], _onRelease);\n                _removeListener(ownerDoc, _eventTypes[3], _onRelease);\n                _removeListener(target, \"click\", clickCapture, true);\n                _removeListener(target, \"click\", _onClick);\n                _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n                _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n                _removeListener(target, _pointerType + \"enter\", _onHover);\n                _removeListener(target, _pointerType + \"leave\", _onHoverEnd);\n                _removeListener(target, _pointerType + \"move\", _onMove);\n                self.isEnabled = self.isPressed = self.isDragging = false;\n                onDisable && onDisable(self);\n            }\n        };\n        self.kill = self.revert = function() {\n            self.disable();\n            var i = _observers.indexOf(self);\n            i >= 0 && _observers.splice(i, 1);\n            _normalizer === self && (_normalizer = 0);\n        };\n        _observers.push(self);\n        isNormalizer && _isViewport(target) && (_normalizer = self);\n        self.enable(event);\n    };\n    _createClass(Observer, [\n        {\n            key: \"velocityX\",\n            get: function get() {\n                return this._vx.getVelocity();\n            }\n        },\n        {\n            key: \"velocityY\",\n            get: function get() {\n                return this._vy.getVelocity();\n            }\n        }\n    ]);\n    return Observer;\n}();\nObserver.version = \"3.12.7\";\nObserver.create = function(vars) {\n    return new Observer(vars);\n};\nObserver.register = _initCore;\nObserver.getAll = function() {\n    return _observers.slice();\n};\nObserver.getById = function(id) {\n    return _observers.filter(function(o) {\n        return o.vars.id === id;\n    })[0];\n};\n_getGSAP() && gsap.registerPlugin(Observer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nc2FwL09ic2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0Esa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUs7SUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFLO1FBQUUsSUFBSUUsYUFBYUgsS0FBSyxDQUFDQyxFQUFFO1FBQUVFLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1FBQU9ELFdBQVdFLFlBQVksR0FBRztRQUFNLElBQUksV0FBV0YsWUFBWUEsV0FBV0csUUFBUSxHQUFHO1FBQU1DLE9BQU9DLGNBQWMsQ0FBQ1QsUUFBUUksV0FBV00sR0FBRyxFQUFFTjtJQUFhO0FBQUU7QUFFNVQsU0FBU08sYUFBYUMsV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFdBQVc7SUFBSSxJQUFJRCxZQUFZZCxrQkFBa0JhLFlBQVlHLFNBQVMsRUFBRUY7SUFBYSxJQUFJQyxhQUFhZixrQkFBa0JhLGFBQWFFO0lBQWMsT0FBT0Y7QUFBYTtBQUV0Tjs7Ozs7Ozs7QUFRQSxHQUVBLGtCQUFrQixHQUNsQixJQUFJSSxNQUNBQyxjQUNBQyxRQUNBQyxNQUNBQyxNQUNBQyxRQUNBQyxPQUNBQyxVQUNBQyxjQUNBQyxlQUNBQyxPQUNBQyxhQUNBQyxhQUNBQyxVQUNBQyxXQUFXLFNBQVNBO0lBQ3RCLE9BQU9kLFFBQVEsS0FBNkIsSUFBS0EsQ0FBQUEsT0FBT2UsT0FBT2YsSUFBSSxLQUFLQSxLQUFLZ0IsY0FBYyxJQUFJaEI7QUFDakcsR0FDSWlCLFdBQVcsR0FDWEMsYUFBYSxFQUFFLEVBQ2ZDLGFBQWEsRUFBRSxFQUNmQyxXQUFXLEVBQUUsRUFDYkMsV0FBV0MsS0FBS0MsR0FBRyxFQUNuQkMsVUFBVSxTQUFTQSxRQUFRQyxJQUFJLEVBQUVDLEtBQUs7SUFDeEMsT0FBT0E7QUFDVCxHQUNJQyxhQUFhLFNBQVNBO0lBQ3hCLElBQUlD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QUNaLE9BQU8sSUFBSSxDQUFDMUQsR0FBRyxDQUFDbEcsV0FBVztZQUM3QjtRQUNGO0tBQUU7SUFFRixPQUFPbUI7QUFDVCxJQUFJO0FBQ0pBLFNBQVMwSSxPQUFPLEdBQUc7QUFFbkIxSSxTQUFTMkksTUFBTSxHQUFHLFNBQVVqSSxJQUFJO0lBQzlCLE9BQU8sSUFBSVYsU0FBU1U7QUFDdEI7QUFFQVYsU0FBUzRJLFFBQVEsR0FBR2xKO0FBRXBCTSxTQUFTNkksTUFBTSxHQUFHO0lBQ2hCLE9BQU8vUCxXQUFXZ1EsS0FBSztBQUN6QjtBQUVBOUksU0FBUytJLE9BQU8sR0FBRyxTQUFVMUYsRUFBRTtJQUM3QixPQUFPdkssV0FBV3NQLE1BQU0sQ0FBQyxTQUFVQyxDQUFDO1FBQ2xDLE9BQU9BLEVBQUUzSCxJQUFJLENBQUMyQyxFQUFFLEtBQUtBO0lBQ3ZCLEVBQUUsQ0FBQyxFQUFFO0FBQ1A7QUFFQTNLLGNBQWNkLEtBQUtnQixjQUFjLENBQUNvSDtBQUNxSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9PYnNlcnZlci5qcz8wOTY0Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyohXG4gKiBPYnNlcnZlciAzLjEyLjdcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2NsYW1wLFxuICAgIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWwsXG4gICAgX2JvZHksXG4gICAgX2lzVG91Y2gsXG4gICAgX3BvaW50ZXJUeXBlLFxuICAgIFNjcm9sbFRyaWdnZXIsXG4gICAgX3Jvb3QsXG4gICAgX25vcm1hbGl6ZXIsXG4gICAgX2V2ZW50VHlwZXMsXG4gICAgX2NvbnRleHQsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9zdGFydHVwID0gMSxcbiAgICBfb2JzZXJ2ZXJzID0gW10sXG4gICAgX3Njcm9sbGVycyA9IFtdLFxuICAgIF9wcm94aWVzID0gW10sXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICBfYnJpZGdlID0gZnVuY3Rpb24gX2JyaWRnZShuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59LFxuICAgIF9pbnRlZ3JhdGUgPSBmdW5jdGlvbiBfaW50ZWdyYXRlKCkge1xuICB2YXIgY29yZSA9IFNjcm9sbFRyaWdnZXIuY29yZSxcbiAgICAgIGRhdGEgPSBjb3JlLmJyaWRnZSB8fCB7fSxcbiAgICAgIHNjcm9sbGVycyA9IGNvcmUuX3Njcm9sbGVycyxcbiAgICAgIHByb3hpZXMgPSBjb3JlLl9wcm94aWVzO1xuICBzY3JvbGxlcnMucHVzaC5hcHBseShzY3JvbGxlcnMsIF9zY3JvbGxlcnMpO1xuICBwcm94aWVzLnB1c2guYXBwbHkocHJveGllcywgX3Byb3hpZXMpO1xuICBfc2Nyb2xsZXJzID0gc2Nyb2xsZXJzO1xuICBfcHJveGllcyA9IHByb3hpZXM7XG5cbiAgX2JyaWRnZSA9IGZ1bmN0aW9uIF9icmlkZ2UobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZGF0YVtuYW1lXSh2YWx1ZSk7XG4gIH07XG59LFxuICAgIF9nZXRQcm94eVByb3AgPSBmdW5jdGlvbiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIHJldHVybiB+X3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSAmJiBfcHJveGllc1tfcHJveGllcy5pbmRleE9mKGVsZW1lbnQpICsgMV1bcHJvcGVydHldO1xufSxcbiAgICBfaXNWaWV3cG9ydCA9IGZ1bmN0aW9uIF9pc1ZpZXdwb3J0KGVsKSB7XG4gIHJldHVybiAhIX5fcm9vdC5pbmRleE9mKGVsKTtcbn0sXG4gICAgX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIHBhc3NpdmUsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCB7XG4gICAgcGFzc2l2ZTogcGFzc2l2ZSAhPT0gZmFsc2UsXG4gICAgY2FwdHVyZTogISFjYXB0dXJlXG4gIH0pO1xufSxcbiAgICBfcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgY2FwdHVyZSkge1xuICByZXR1cm4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsICEhY2FwdHVyZSk7XG59LFxuICAgIF9zY3JvbGxMZWZ0ID0gXCJzY3JvbGxMZWZ0XCIsXG4gICAgX3Njcm9sbFRvcCA9IFwic2Nyb2xsVG9wXCIsXG4gICAgX29uU2Nyb2xsID0gZnVuY3Rpb24gX29uU2Nyb2xsKCkge1xuICByZXR1cm4gX25vcm1hbGl6ZXIgJiYgX25vcm1hbGl6ZXIuaXNQcmVzc2VkIHx8IF9zY3JvbGxlcnMuY2FjaGUrKztcbn0sXG4gICAgX3Njcm9sbENhY2hlRnVuYyA9IGZ1bmN0aW9uIF9zY3JvbGxDYWNoZUZ1bmMoZiwgZG9Ob3RDYWNoZSkge1xuICB2YXIgY2FjaGluZ0Z1bmMgPSBmdW5jdGlvbiBjYWNoaW5nRnVuYyh2YWx1ZSkge1xuICAgIC8vIHNpbmNlIHJlYWRpbmcgdGhlIHNjcm9sbFRvcC9zY3JvbGxMZWZ0L3BhZ2VPZmZzZXRZL3BhZ2VPZmZzZXRYIGNhbiB0cmlnZ2VyIGEgbGF5b3V0LCB0aGlzIGZ1bmN0aW9uIGFsbG93cyB1cyB0byBjYWNoZSB0aGUgdmFsdWUgc28gaXQgb25seSBnZXRzIHJlYWQgZnJlc2ggYWZ0ZXIgYSBcInNjcm9sbFwiIGV2ZW50IGZpcmVzIChvciB3aGlsZSB3ZSdyZSByZWZyZXNoaW5nIGJlY2F1c2UgdGhhdCBjYW4gbGVuZ3RoZW4gdGhlIHBhZ2UgYW5kIGFsdGVyIHRoZSBzY3JvbGwgcG9zaXRpb24pLiB3aGVuIFwic29mdFwiIGlzIHRydWUsIHRoYXQgbWVhbnMgZG9uJ3QgYWN0dWFsbHkgc2V0IHRoZSBzY3JvbGwsIGJ1dCBjYWNoZSB0aGUgbmV3IHZhbHVlIGluc3RlYWQgKHVzZWZ1bCBpbiBTY3JvbGxTbW9vdGhlcilcbiAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIF9zdGFydHVwICYmIChfd2luLmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiKTsgLy8gb3RoZXJ3aXNlIHRoZSBuZXcgcG9zaXRpb24gd2lsbCBnZXQgb3ZlcndyaXR0ZW4gYnkgdGhlIGJyb3dzZXIgb25sb2FkLlxuXG4gICAgICB2YXIgaXNOb3JtYWxpemluZyA9IF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmlzUHJlc3NlZDtcbiAgICAgIHZhbHVlID0gY2FjaGluZ0Z1bmMudiA9IE1hdGgucm91bmQodmFsdWUpIHx8IChfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5pT1MgPyAxIDogMCk7IC8vVE9ETzogaU9TIEJ1ZzogaWYgeW91IGFsbG93IGl0IHRvIGdvIHRvIDAsIFNhZmFyaSBjYW4gc3RhcnQgdG8gcmVwb3J0IHN1cGVyIHN0cmFuZ2UgKHdpbGRseSBpbmFjY3VyYXRlKSB0b3VjaCBwb3NpdGlvbnMhXG5cbiAgICAgIGYodmFsdWUpO1xuICAgICAgY2FjaGluZ0Z1bmMuY2FjaGVJRCA9IF9zY3JvbGxlcnMuY2FjaGU7XG4gICAgICBpc05vcm1hbGl6aW5nICYmIF9icmlkZ2UoXCJzc1wiLCB2YWx1ZSk7IC8vIHNldCBzY3JvbGwgKG5vdGlmeSBTY3JvbGxUcmlnZ2VyIHNvIGl0IGNhbiBkaXNwYXRjaCBhIFwic2Nyb2xsU3RhcnRcIiBldmVudCBpZiBuZWNlc3NhcnlcbiAgICB9IGVsc2UgaWYgKGRvTm90Q2FjaGUgfHwgX3Njcm9sbGVycy5jYWNoZSAhPT0gY2FjaGluZ0Z1bmMuY2FjaGVJRCB8fCBfYnJpZGdlKFwicmVmXCIpKSB7XG4gICAgICBjYWNoaW5nRnVuYy5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcbiAgICAgIGNhY2hpbmdGdW5jLnYgPSBmKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hpbmdGdW5jLnYgKyBjYWNoaW5nRnVuYy5vZmZzZXQ7XG4gIH07XG5cbiAgY2FjaGluZ0Z1bmMub2Zmc2V0ID0gMDtcbiAgcmV0dXJuIGYgJiYgY2FjaGluZ0Z1bmM7XG59LFxuICAgIF9ob3Jpem9udGFsID0ge1xuICBzOiBfc2Nyb2xsTGVmdCxcbiAgcDogXCJsZWZ0XCIsXG4gIHAyOiBcIkxlZnRcIixcbiAgb3M6IFwicmlnaHRcIixcbiAgb3MyOiBcIlJpZ2h0XCIsXG4gIGQ6IFwid2lkdGhcIixcbiAgZDI6IFwiV2lkdGhcIixcbiAgYTogXCJ4XCIsXG4gIHNjOiBfc2Nyb2xsQ2FjaGVGdW5jKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3dpbi5zY3JvbGxUbyh2YWx1ZSwgX3ZlcnRpY2FsLnNjKCkpIDogX3dpbi5wYWdlWE9mZnNldCB8fCBfZG9jW19zY3JvbGxMZWZ0XSB8fCBfZG9jRWxbX3Njcm9sbExlZnRdIHx8IF9ib2R5W19zY3JvbGxMZWZ0XSB8fCAwO1xuICB9KVxufSxcbiAgICBfdmVydGljYWwgPSB7XG4gIHM6IF9zY3JvbGxUb3AsXG4gIHA6IFwidG9wXCIsXG4gIHAyOiBcIlRvcFwiLFxuICBvczogXCJib3R0b21cIixcbiAgb3MyOiBcIkJvdHRvbVwiLFxuICBkOiBcImhlaWdodFwiLFxuICBkMjogXCJIZWlnaHRcIixcbiAgYTogXCJ5XCIsXG4gIG9wOiBfaG9yaXpvbnRhbCxcbiAgc2M6IF9zY3JvbGxDYWNoZUZ1bmMoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfd2luLnNjcm9sbFRvKF9ob3Jpem9udGFsLnNjKCksIHZhbHVlKSA6IF93aW4ucGFnZVlPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsVG9wXSB8fCBfZG9jRWxbX3Njcm9sbFRvcF0gfHwgX2JvZHlbX3Njcm9sbFRvcF0gfHwgMDtcbiAgfSlcbn0sXG4gICAgX2dldFRhcmdldCA9IGZ1bmN0aW9uIF9nZXRUYXJnZXQodCwgc2VsZikge1xuICByZXR1cm4gKHNlbGYgJiYgc2VsZi5fY3R4ICYmIHNlbGYuX2N0eC5zZWxlY3RvciB8fCBnc2FwLnV0aWxzLnRvQXJyYXkpKHQpWzBdIHx8ICh0eXBlb2YgdCA9PT0gXCJzdHJpbmdcIiAmJiBnc2FwLmNvbmZpZygpLm51bGxUYXJnZXRXYXJuICE9PSBmYWxzZSA/IGNvbnNvbGUud2FybihcIkVsZW1lbnQgbm90IGZvdW5kOlwiLCB0KSA6IG51bGwpO1xufSxcbiAgICBfZ2V0U2Nyb2xsRnVuYyA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxGdW5jKGVsZW1lbnQsIF9yZWYpIHtcbiAgdmFyIHMgPSBfcmVmLnMsXG4gICAgICBzYyA9IF9yZWYuc2M7XG4gIC8vIHdlIHN0b3JlIHRoZSBzY3JvbGxlciBmdW5jdGlvbnMgaW4gYW4gYWx0ZXJuYXRpbmcgc2VxdWVuY2VkIEFycmF5IGxpa2UgW2VsZW1lbnQsIHZlcnRpY2FsU2Nyb2xsRnVuYywgaG9yaXpvbnRhbFNjcm9sbEZ1bmMsIC4uLl0gc28gdGhhdCB3ZSBjYW4gbWluaW1pemUgbWVtb3J5LCBtYXhpbWl6ZSBwZXJmb3JtYW5jZSwgYW5kIHdlIGFsc28gcmVjb3JkIHRoZSBsYXN0IHBvc2l0aW9uIGFzIGEgXCIucmVjXCIgcHJvcGVydHkgaW4gb3JkZXIgdG8gcmV2ZXJ0IHRvIHRoYXQgYWZ0ZXIgcmVmcmVzaGluZyB0byBlbnN1cmUgdGhpbmdzIGRvbid0IHNoaWZ0IGFyb3VuZC5cbiAgX2lzVmlld3BvcnQoZWxlbWVudCkgJiYgKGVsZW1lbnQgPSBfZG9jLnNjcm9sbGluZ0VsZW1lbnQgfHwgX2RvY0VsKTtcblxuICB2YXIgaSA9IF9zY3JvbGxlcnMuaW5kZXhPZihlbGVtZW50KSxcbiAgICAgIG9mZnNldCA9IHNjID09PSBfdmVydGljYWwuc2MgPyAxIDogMjtcblxuICAhfmkgJiYgKGkgPSBfc2Nyb2xsZXJzLnB1c2goZWxlbWVudCkgLSAxKTtcbiAgX3Njcm9sbGVyc1tpICsgb2Zmc2V0XSB8fCBfYWRkTGlzdGVuZXIoZWxlbWVudCwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTsgLy8gY2xlYXIgdGhlIGNhY2hlIHdoZW4gYSBzY3JvbGwgb2NjdXJzXG5cbiAgdmFyIHByZXYgPSBfc2Nyb2xsZXJzW2kgKyBvZmZzZXRdLFxuICAgICAgZnVuYyA9IHByZXYgfHwgKF9zY3JvbGxlcnNbaSArIG9mZnNldF0gPSBfc2Nyb2xsQ2FjaGVGdW5jKF9nZXRQcm94eVByb3AoZWxlbWVudCwgcyksIHRydWUpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/IHNjIDogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGVsZW1lbnRbc10gPSB2YWx1ZSA6IGVsZW1lbnRbc107XG4gIH0pKSk7XG4gIGZ1bmMudGFyZ2V0ID0gZWxlbWVudDtcbiAgcHJldiB8fCAoZnVuYy5zbW9vdGggPSBnc2FwLmdldFByb3BlcnR5KGVsZW1lbnQsIFwic2Nyb2xsQmVoYXZpb3JcIikgPT09IFwic21vb3RoXCIpOyAvLyBvbmx5IHNldCBpdCB0aGUgZmlyc3QgdGltZSAoZG9uJ3QgcmVzZXQgZXZlcnkgdGltZSBhIHNjcm9sbEZ1bmMgaXMgcmVxdWVzdGVkIGJlY2F1c2UgcGVyaGFwcyBpdCBoYXBwZW5zIGR1cmluZyBhIHJlZnJlc2goKSB3aGVuIGl0J3MgZGlzYWJsZWQgaW4gU2Nyb2xsVHJpZ2dlci5cblxuICByZXR1cm4gZnVuYztcbn0sXG4gICAgX2dldFZlbG9jaXR5UHJvcCA9IGZ1bmN0aW9uIF9nZXRWZWxvY2l0eVByb3AodmFsdWUsIG1pblRpbWVSZWZyZXNoLCB1c2VEZWx0YSkge1xuICB2YXIgdjEgPSB2YWx1ZSxcbiAgICAgIHYyID0gdmFsdWUsXG4gICAgICB0MSA9IF9nZXRUaW1lKCksXG4gICAgICB0MiA9IHQxLFxuICAgICAgbWluID0gbWluVGltZVJlZnJlc2ggfHwgNTAsXG4gICAgICBkcm9wVG9aZXJvVGltZSA9IE1hdGgubWF4KDUwMCwgbWluICogMyksXG4gICAgICB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodmFsdWUsIGZvcmNlKSB7XG4gICAgdmFyIHQgPSBfZ2V0VGltZSgpO1xuXG4gICAgaWYgKGZvcmNlIHx8IHQgLSB0MSA+IG1pbikge1xuICAgICAgdjIgPSB2MTtcbiAgICAgIHYxID0gdmFsdWU7XG4gICAgICB0MiA9IHQxO1xuICAgICAgdDEgPSB0O1xuICAgIH0gZWxzZSBpZiAodXNlRGVsdGEpIHtcbiAgICAgIHYxICs9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3QgdG90YWxseSBuZWNlc3NhcnksIGJ1dCBtYWtlcyBpdCBhIGJpdCBtb3JlIGFjY3VyYXRlIGJ5IGFkanVzdGluZyB0aGUgdjEgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2xvcGUuIFRoaXMgd2F5IHdlJ3JlIG5vdCBqdXN0IGlnbm9yaW5nIHRoZSBpbmNvbWluZyBkYXRhLiBSZW1vdmluZyBmb3Igbm93IGJlY2F1c2UgaXQgZG9lc24ndCBzZWVtIHRvIG1ha2UgbXVjaCBwcmFjdGljYWwgZGlmZmVyZW5jZSBhbmQgaXQncyBwcm9iYWJseSBub3Qgd29ydGggdGhlIGtiLlxuICAgICAgdjEgPSB2MiArICh2YWx1ZSAtIHYyKSAvICh0IC0gdDIpICogKHQxIC0gdDIpO1xuICAgIH1cbiAgfSxcbiAgICAgIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdjIgPSB2MSA9IHVzZURlbHRhID8gMCA6IHYxO1xuICAgIHQyID0gdDEgPSAwO1xuICB9LFxuICAgICAgZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiBnZXRWZWxvY2l0eShsYXRlc3RWYWx1ZSkge1xuICAgIHZhciB0T2xkID0gdDIsXG4gICAgICAgIHZPbGQgPSB2MixcbiAgICAgICAgdCA9IF9nZXRUaW1lKCk7XG5cbiAgICAobGF0ZXN0VmFsdWUgfHwgbGF0ZXN0VmFsdWUgPT09IDApICYmIGxhdGVzdFZhbHVlICE9PSB2MSAmJiB1cGRhdGUobGF0ZXN0VmFsdWUpO1xuICAgIHJldHVybiB0MSA9PT0gdDIgfHwgdCAtIHQyID4gZHJvcFRvWmVyb1RpbWUgPyAwIDogKHYxICsgKHVzZURlbHRhID8gdk9sZCA6IC12T2xkKSkgLyAoKHVzZURlbHRhID8gdCA6IHQxKSAtIHRPbGQpICogMTAwMDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIHJlc2V0OiByZXNldCxcbiAgICBnZXRWZWxvY2l0eTogZ2V0VmVsb2NpdHlcbiAgfTtcbn0sXG4gICAgX2dldEV2ZW50ID0gZnVuY3Rpb24gX2dldEV2ZW50KGUsIHByZXZlbnREZWZhdWx0KSB7XG4gIHByZXZlbnREZWZhdWx0ICYmICFlLl9nc2FwQWxsb3cgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0gOiBlO1xufSxcbiAgICBfZ2V0QWJzb2x1dGVNYXggPSBmdW5jdGlvbiBfZ2V0QWJzb2x1dGVNYXgoYSkge1xuICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYSksXG4gICAgICBtaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBhKTtcbiAgcmV0dXJuIE1hdGguYWJzKG1heCkgPj0gTWF0aC5hYnMobWluKSA/IG1heCA6IG1pbjtcbn0sXG4gICAgX3NldFNjcm9sbFRyaWdnZXIgPSBmdW5jdGlvbiBfc2V0U2Nyb2xsVHJpZ2dlcigpIHtcbiAgU2Nyb2xsVHJpZ2dlciA9IGdzYXAuY29yZS5nbG9iYWxzKCkuU2Nyb2xsVHJpZ2dlcjtcbiAgU2Nyb2xsVHJpZ2dlciAmJiBTY3JvbGxUcmlnZ2VyLmNvcmUgJiYgX2ludGVncmF0ZSgpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoY29yZSkge1xuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXG4gIGlmICghX2NvcmVJbml0dGVkICYmIGdzYXAgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICBfd2luID0gd2luZG93O1xuICAgIF9kb2MgPSBkb2N1bWVudDtcbiAgICBfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfYm9keSA9IF9kb2MuYm9keTtcbiAgICBfcm9vdCA9IFtfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5XTtcbiAgICBfY2xhbXAgPSBnc2FwLnV0aWxzLmNsYW1wO1xuXG4gICAgX2NvbnRleHQgPSBnc2FwLmNvcmUuY29udGV4dCB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIF9wb2ludGVyVHlwZSA9IFwib25wb2ludGVyZW50ZXJcIiBpbiBfYm9keSA/IFwicG9pbnRlclwiIDogXCJtb3VzZVwiOyAvLyBpc1RvdWNoIGlzIDAgaWYgbm8gdG91Y2gsIDEgaWYgT05MWSB0b3VjaCwgYW5kIDIgaWYgaXQgY2FuIGFjY29tbW9kYXRlIHRvdWNoIGJ1dCBhbHNvIG90aGVyIHR5cGVzIGxpa2UgbW91c2UvcG9pbnRlci5cblxuICAgIF9pc1RvdWNoID0gT2JzZXJ2ZXIuaXNUb3VjaCA9IF93aW4ubWF0Y2hNZWRpYSAmJiBfd2luLm1hdGNoTWVkaWEoXCIoaG92ZXI6IG5vbmUpLCAocG9pbnRlcjogY29hcnNlKVwiKS5tYXRjaGVzID8gMSA6IFwib250b3VjaHN0YXJ0XCIgaW4gX3dpbiB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwIHx8IG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCA/IDIgOiAwO1xuICAgIF9ldmVudFR5cGVzID0gT2JzZXJ2ZXIuZXZlbnRUeXBlcyA9IChcIm9udG91Y2hzdGFydFwiIGluIF9kb2NFbCA/IFwidG91Y2hzdGFydCx0b3VjaG1vdmUsdG91Y2hjYW5jZWwsdG91Y2hlbmRcIiA6ICEoXCJvbnBvaW50ZXJkb3duXCIgaW4gX2RvY0VsKSA/IFwibW91c2Vkb3duLG1vdXNlbW92ZSxtb3VzZXVwLG1vdXNldXBcIiA6IFwicG9pbnRlcmRvd24scG9pbnRlcm1vdmUscG9pbnRlcmNhbmNlbCxwb2ludGVydXBcIikuc3BsaXQoXCIsXCIpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9zdGFydHVwID0gMDtcbiAgICB9LCA1MDApO1xuXG4gICAgX3NldFNjcm9sbFRyaWdnZXIoKTtcblxuICAgIF9jb3JlSW5pdHRlZCA9IDE7XG4gIH1cblxuICByZXR1cm4gX2NvcmVJbml0dGVkO1xufTtcblxuX2hvcml6b250YWwub3AgPSBfdmVydGljYWw7XG5fc2Nyb2xsZXJzLmNhY2hlID0gMDtcbmV4cG9ydCB2YXIgT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZlcih2YXJzKSB7XG4gICAgdGhpcy5pbml0KHZhcnMpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQodmFycykge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoZ3NhcCkgfHwgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oT2JzZXJ2ZXIpXCIpO1xuICAgIFNjcm9sbFRyaWdnZXIgfHwgX3NldFNjcm9sbFRyaWdnZXIoKTtcbiAgICB2YXIgdG9sZXJhbmNlID0gdmFycy50b2xlcmFuY2UsXG4gICAgICAgIGRyYWdNaW5pbXVtID0gdmFycy5kcmFnTWluaW11bSxcbiAgICAgICAgdHlwZSA9IHZhcnMudHlwZSxcbiAgICAgICAgdGFyZ2V0ID0gdmFycy50YXJnZXQsXG4gICAgICAgIGxpbmVIZWlnaHQgPSB2YXJzLmxpbmVIZWlnaHQsXG4gICAgICAgIGRlYm91bmNlID0gdmFycy5kZWJvdW5jZSxcbiAgICAgICAgcHJldmVudERlZmF1bHQgPSB2YXJzLnByZXZlbnREZWZhdWx0LFxuICAgICAgICBvblN0b3AgPSB2YXJzLm9uU3RvcCxcbiAgICAgICAgb25TdG9wRGVsYXkgPSB2YXJzLm9uU3RvcERlbGF5LFxuICAgICAgICBpZ25vcmUgPSB2YXJzLmlnbm9yZSxcbiAgICAgICAgd2hlZWxTcGVlZCA9IHZhcnMud2hlZWxTcGVlZCxcbiAgICAgICAgZXZlbnQgPSB2YXJzLmV2ZW50LFxuICAgICAgICBvbkRyYWdTdGFydCA9IHZhcnMub25EcmFnU3RhcnQsXG4gICAgICAgIG9uRHJhZ0VuZCA9IHZhcnMub25EcmFnRW5kLFxuICAgICAgICBvbkRyYWcgPSB2YXJzLm9uRHJhZyxcbiAgICAgICAgb25QcmVzcyA9IHZhcnMub25QcmVzcyxcbiAgICAgICAgb25SZWxlYXNlID0gdmFycy5vblJlbGVhc2UsXG4gICAgICAgIG9uUmlnaHQgPSB2YXJzLm9uUmlnaHQsXG4gICAgICAgIG9uTGVmdCA9IHZhcnMub25MZWZ0LFxuICAgICAgICBvblVwID0gdmFycy5vblVwLFxuICAgICAgICBvbkRvd24gPSB2YXJzLm9uRG93bixcbiAgICAgICAgb25DaGFuZ2VYID0gdmFycy5vbkNoYW5nZVgsXG4gICAgICAgIG9uQ2hhbmdlWSA9IHZhcnMub25DaGFuZ2VZLFxuICAgICAgICBvbkNoYW5nZSA9IHZhcnMub25DaGFuZ2UsXG4gICAgICAgIG9uVG9nZ2xlWCA9IHZhcnMub25Ub2dnbGVYLFxuICAgICAgICBvblRvZ2dsZVkgPSB2YXJzLm9uVG9nZ2xlWSxcbiAgICAgICAgb25Ib3ZlciA9IHZhcnMub25Ib3ZlcixcbiAgICAgICAgb25Ib3ZlckVuZCA9IHZhcnMub25Ib3ZlckVuZCxcbiAgICAgICAgb25Nb3ZlID0gdmFycy5vbk1vdmUsXG4gICAgICAgIGlnbm9yZUNoZWNrID0gdmFycy5pZ25vcmVDaGVjayxcbiAgICAgICAgaXNOb3JtYWxpemVyID0gdmFycy5pc05vcm1hbGl6ZXIsXG4gICAgICAgIG9uR2VzdHVyZVN0YXJ0ID0gdmFycy5vbkdlc3R1cmVTdGFydCxcbiAgICAgICAgb25HZXN0dXJlRW5kID0gdmFycy5vbkdlc3R1cmVFbmQsXG4gICAgICAgIG9uV2hlZWwgPSB2YXJzLm9uV2hlZWwsXG4gICAgICAgIG9uRW5hYmxlID0gdmFycy5vbkVuYWJsZSxcbiAgICAgICAgb25EaXNhYmxlID0gdmFycy5vbkRpc2FibGUsXG4gICAgICAgIG9uQ2xpY2sgPSB2YXJzLm9uQ2xpY2ssXG4gICAgICAgIHNjcm9sbFNwZWVkID0gdmFycy5zY3JvbGxTcGVlZCxcbiAgICAgICAgY2FwdHVyZSA9IHZhcnMuY2FwdHVyZSxcbiAgICAgICAgYWxsb3dDbGlja3MgPSB2YXJzLmFsbG93Q2xpY2tzLFxuICAgICAgICBsb2NrQXhpcyA9IHZhcnMubG9ja0F4aXMsXG4gICAgICAgIG9uTG9ja0F4aXMgPSB2YXJzLm9uTG9ja0F4aXM7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHRhcmdldCkgfHwgX2RvY0VsO1xuICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgaWdub3JlICYmIChpZ25vcmUgPSBnc2FwLnV0aWxzLnRvQXJyYXkoaWdub3JlKSk7XG4gICAgdG9sZXJhbmNlID0gdG9sZXJhbmNlIHx8IDFlLTk7XG4gICAgZHJhZ01pbmltdW0gPSBkcmFnTWluaW11bSB8fCAwO1xuICAgIHdoZWVsU3BlZWQgPSB3aGVlbFNwZWVkIHx8IDE7XG4gICAgc2Nyb2xsU3BlZWQgPSBzY3JvbGxTcGVlZCB8fCAxO1xuICAgIHR5cGUgPSB0eXBlIHx8IFwid2hlZWwsdG91Y2gscG9pbnRlclwiO1xuICAgIGRlYm91bmNlID0gZGVib3VuY2UgIT09IGZhbHNlO1xuICAgIGxpbmVIZWlnaHQgfHwgKGxpbmVIZWlnaHQgPSBwYXJzZUZsb2F0KF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShfYm9keSkubGluZUhlaWdodCkgfHwgMjIpOyAvLyBub3RlOiBicm93c2VyIG1heSByZXBvcnQgXCJub3JtYWxcIiwgc28gZGVmYXVsdCB0byAyMi5cblxuICAgIHZhciBpZCxcbiAgICAgICAgb25TdG9wRGVsYXllZENhbGwsXG4gICAgICAgIGRyYWdnZWQsXG4gICAgICAgIG1vdmVkLFxuICAgICAgICB3aGVlbGVkLFxuICAgICAgICBsb2NrZWQsXG4gICAgICAgIGF4aXMsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBwcmV2RGVsdGFYID0gMCxcbiAgICAgICAgcHJldkRlbHRhWSA9IDAsXG4gICAgICAgIHBhc3NpdmUgPSB2YXJzLnBhc3NpdmUgfHwgIXByZXZlbnREZWZhdWx0ICYmIHZhcnMucGFzc2l2ZSAhPT0gZmFsc2UsXG4gICAgICAgIHNjcm9sbEZ1bmNYID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfaG9yaXpvbnRhbCksXG4gICAgICAgIHNjcm9sbEZ1bmNZID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfdmVydGljYWwpLFxuICAgICAgICBzY3JvbGxYID0gc2Nyb2xsRnVuY1goKSxcbiAgICAgICAgc2Nyb2xsWSA9IHNjcm9sbEZ1bmNZKCksXG4gICAgICAgIGxpbWl0VG9Ub3VjaCA9IH50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSAmJiAhfnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgJiYgX2V2ZW50VHlwZXNbMF0gPT09IFwicG9pbnRlcmRvd25cIixcbiAgICAgICAgLy8gZm9yIGRldmljZXMgdGhhdCBhY2NvbW1vZGF0ZSBtb3VzZSBldmVudHMgYW5kIHRvdWNoIGV2ZW50cywgd2UgbmVlZCB0byBkaXN0aW5ndWlzaC5cbiAgICBpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQodGFyZ2V0KSxcbiAgICAgICAgb3duZXJEb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBfZG9jLFxuICAgICAgICBkZWx0YVggPSBbMCwgMCwgMF0sXG4gICAgICAgIC8vIHdoZWVsLCBzY3JvbGwsIHBvaW50ZXIvdG91Y2hcbiAgICBkZWx0YVkgPSBbMCwgMCwgMF0sXG4gICAgICAgIG9uQ2xpY2tUaW1lID0gMCxcbiAgICAgICAgY2xpY2tDYXB0dXJlID0gZnVuY3Rpb24gY2xpY2tDYXB0dXJlKCkge1xuICAgICAgcmV0dXJuIG9uQ2xpY2tUaW1lID0gX2dldFRpbWUoKTtcbiAgICB9LFxuICAgICAgICBfaWdub3JlQ2hlY2sgPSBmdW5jdGlvbiBfaWdub3JlQ2hlY2soZSwgaXNQb2ludGVyT3JUb3VjaCkge1xuICAgICAgcmV0dXJuIChzZWxmLmV2ZW50ID0gZSkgJiYgaWdub3JlICYmIH5pZ25vcmUuaW5kZXhPZihlLnRhcmdldCkgfHwgaXNQb2ludGVyT3JUb3VjaCAmJiBsaW1pdFRvVG91Y2ggJiYgZS5wb2ludGVyVHlwZSAhPT0gXCJ0b3VjaFwiIHx8IGlnbm9yZUNoZWNrICYmIGlnbm9yZUNoZWNrKGUsIGlzUG9pbnRlck9yVG91Y2gpO1xuICAgIH0sXG4gICAgICAgIG9uU3RvcEZ1bmMgPSBmdW5jdGlvbiBvblN0b3BGdW5jKCkge1xuICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgb25TdG9wRGVsYXllZENhbGwucGF1c2UoKTtcbiAgICAgIG9uU3RvcCAmJiBvblN0b3Aoc2VsZik7XG4gICAgfSxcbiAgICAgICAgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIGR4ID0gc2VsZi5kZWx0YVggPSBfZ2V0QWJzb2x1dGVNYXgoZGVsdGFYKSxcbiAgICAgICAgICBkeSA9IHNlbGYuZGVsdGFZID0gX2dldEFic29sdXRlTWF4KGRlbHRhWSksXG4gICAgICAgICAgY2hhbmdlZFggPSBNYXRoLmFicyhkeCkgPj0gdG9sZXJhbmNlLFxuICAgICAgICAgIGNoYW5nZWRZID0gTWF0aC5hYnMoZHkpID49IHRvbGVyYW5jZTtcblxuICAgICAgb25DaGFuZ2UgJiYgKGNoYW5nZWRYIHx8IGNoYW5nZWRZKSAmJiBvbkNoYW5nZShzZWxmLCBkeCwgZHksIGRlbHRhWCwgZGVsdGFZKTsgLy8gaW4gU2Nyb2xsVHJpZ2dlci5ub3JtYWxpemVTY3JvbGwoKSwgd2UgbmVlZCB0byBrbm93IGlmIGl0IHdhcyB0b3VjaC9wb2ludGVyIHNvIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBkZWx0YVgvZGVsdGFZIEFycmF5cyBiZWZvcmUgd2UgY2xlYXIgdGhlbSBvdXQuXG5cbiAgICAgIGlmIChjaGFuZ2VkWCkge1xuICAgICAgICBvblJpZ2h0ICYmIHNlbGYuZGVsdGFYID4gMCAmJiBvblJpZ2h0KHNlbGYpO1xuICAgICAgICBvbkxlZnQgJiYgc2VsZi5kZWx0YVggPCAwICYmIG9uTGVmdChzZWxmKTtcbiAgICAgICAgb25DaGFuZ2VYICYmIG9uQ2hhbmdlWChzZWxmKTtcbiAgICAgICAgb25Ub2dnbGVYICYmIHNlbGYuZGVsdGFYIDwgMCAhPT0gcHJldkRlbHRhWCA8IDAgJiYgb25Ub2dnbGVYKHNlbGYpO1xuICAgICAgICBwcmV2RGVsdGFYID0gc2VsZi5kZWx0YVg7XG4gICAgICAgIGRlbHRhWFswXSA9IGRlbHRhWFsxXSA9IGRlbHRhWFsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkWSkge1xuICAgICAgICBvbkRvd24gJiYgc2VsZi5kZWx0YVkgPiAwICYmIG9uRG93bihzZWxmKTtcbiAgICAgICAgb25VcCAmJiBzZWxmLmRlbHRhWSA8IDAgJiYgb25VcChzZWxmKTtcbiAgICAgICAgb25DaGFuZ2VZICYmIG9uQ2hhbmdlWShzZWxmKTtcbiAgICAgICAgb25Ub2dnbGVZICYmIHNlbGYuZGVsdGFZIDwgMCAhPT0gcHJldkRlbHRhWSA8IDAgJiYgb25Ub2dnbGVZKHNlbGYpO1xuICAgICAgICBwcmV2RGVsdGFZID0gc2VsZi5kZWx0YVk7XG4gICAgICAgIGRlbHRhWVswXSA9IGRlbHRhWVsxXSA9IGRlbHRhWVsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3ZlZCB8fCBkcmFnZ2VkKSB7XG4gICAgICAgIG9uTW92ZSAmJiBvbk1vdmUoc2VsZik7XG5cbiAgICAgICAgaWYgKGRyYWdnZWQpIHtcbiAgICAgICAgICBvbkRyYWdTdGFydCAmJiBkcmFnZ2VkID09PSAxICYmIG9uRHJhZ1N0YXJ0KHNlbGYpO1xuICAgICAgICAgIG9uRHJhZyAmJiBvbkRyYWcoc2VsZik7XG4gICAgICAgICAgZHJhZ2dlZCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBtb3ZlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsb2NrZWQgJiYgIShsb2NrZWQgPSBmYWxzZSkgJiYgb25Mb2NrQXhpcyAmJiBvbkxvY2tBeGlzKHNlbGYpO1xuXG4gICAgICBpZiAod2hlZWxlZCkge1xuICAgICAgICBvbldoZWVsKHNlbGYpO1xuICAgICAgICB3aGVlbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlkID0gMDtcbiAgICB9LFxuICAgICAgICBvbkRlbHRhID0gZnVuY3Rpb24gb25EZWx0YSh4LCB5LCBpbmRleCkge1xuICAgICAgZGVsdGFYW2luZGV4XSArPSB4O1xuICAgICAgZGVsdGFZW2luZGV4XSArPSB5O1xuXG4gICAgICBzZWxmLl92eC51cGRhdGUoeCk7XG5cbiAgICAgIHNlbGYuX3Z5LnVwZGF0ZSh5KTtcblxuICAgICAgZGVib3VuY2UgPyBpZCB8fCAoaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKSkgOiB1cGRhdGUoKTtcbiAgICB9LFxuICAgICAgICBvblRvdWNoT3JQb2ludGVyRGVsdGEgPSBmdW5jdGlvbiBvblRvdWNoT3JQb2ludGVyRGVsdGEoeCwgeSkge1xuICAgICAgaWYgKGxvY2tBeGlzICYmICFheGlzKSB7XG4gICAgICAgIHNlbGYuYXhpcyA9IGF4aXMgPSBNYXRoLmFicyh4KSA+IE1hdGguYWJzKHkpID8gXCJ4XCIgOiBcInlcIjtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgIT09IFwieVwiKSB7XG4gICAgICAgIGRlbHRhWFsyXSArPSB4O1xuXG4gICAgICAgIHNlbGYuX3Z4LnVwZGF0ZSh4LCB0cnVlKTsgLy8gdXBkYXRlIHRoZSB2ZWxvY2l0eSBhcyBmcmVxdWVudGx5IGFzIHBvc3NpYmxlIGluc3RlYWQgb2YgaW4gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBzbyB0aGF0IHZlcnkgcXVpY2sgdG91Y2gtc2Nyb2xscyAoZmxpY2tzKSBmZWVsIG5hdHVyYWwuIElmIGl0J3MgdGhlIG1vdXNlL3RvdWNoL3BvaW50ZXIsIGZvcmNlIGl0IHNvIHRoYXQgd2UgZ2V0IHNuYXBweS9hY2N1cmF0ZSBtb21lbnR1bSBzY3JvbGwuXG5cbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgIT09IFwieFwiKSB7XG4gICAgICAgIGRlbHRhWVsyXSArPSB5O1xuXG4gICAgICAgIHNlbGYuX3Z5LnVwZGF0ZSh5LCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZGVib3VuY2UgPyBpZCB8fCAoaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKSkgOiB1cGRhdGUoKTtcbiAgICB9LFxuICAgICAgICBfb25EcmFnID0gZnVuY3Rpb24gX29uRHJhZyhlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZSA9IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICB5ID0gZS5jbGllbnRZLFxuICAgICAgICAgIGR4ID0geCAtIHNlbGYueCxcbiAgICAgICAgICBkeSA9IHkgLSBzZWxmLnksXG4gICAgICAgICAgaXNEcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZztcbiAgICAgIHNlbGYueCA9IHg7XG4gICAgICBzZWxmLnkgPSB5O1xuXG4gICAgICBpZiAoaXNEcmFnZ2luZyB8fCAoZHggfHwgZHkpICYmIChNYXRoLmFicyhzZWxmLnN0YXJ0WCAtIHgpID49IGRyYWdNaW5pbXVtIHx8IE1hdGguYWJzKHNlbGYuc3RhcnRZIC0geSkgPj0gZHJhZ01pbmltdW0pKSB7XG4gICAgICAgIGRyYWdnZWQgPSBpc0RyYWdnaW5nID8gMiA6IDE7IC8vIGRyYWdnZWQ6IDAgPSBub3QgZHJhZ2dpbmcsIDEgPSBmaXJzdCBkcmFnLCAyID0gbm9ybWFsIGRyYWdcblxuICAgICAgICBpc0RyYWdnaW5nIHx8IChzZWxmLmlzRHJhZ2dpbmcgPSB0cnVlKTtcbiAgICAgICAgb25Ub3VjaE9yUG9pbnRlckRlbHRhKGR4LCBkeSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgX29uUHJlc3MgPSBzZWxmLm9uUHJlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlLCAxKSB8fCBlICYmIGUuYnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5heGlzID0gYXhpcyA9IG51bGw7XG4gICAgICBvblN0b3BEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgc2VsZi5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgZSA9IF9nZXRFdmVudChlKTsgLy8gbm90ZTogbWF5IG5lZWQgdG8gcHJldmVudERlZmF1bHQoPykgV29uJ3Qgc2lkZS1zY3JvbGwgb24gaU9TIFNhZmFyaSBpZiB3ZSBkbywgdGhvdWdoLlxuXG4gICAgICBwcmV2RGVsdGFYID0gcHJldkRlbHRhWSA9IDA7XG4gICAgICBzZWxmLnN0YXJ0WCA9IHNlbGYueCA9IGUuY2xpZW50WDtcbiAgICAgIHNlbGYuc3RhcnRZID0gc2VsZi55ID0gZS5jbGllbnRZO1xuXG4gICAgICBzZWxmLl92eC5yZXNldCgpOyAvLyBvdGhlcndpc2UgdGhlIHQyIG1heSBiZSBzdGFsZSBpZiB0aGUgdXNlciB0b3VjaGVzIGFuZCBmbGlja3Mgc3VwZXIgZmFzdCBhbmQgcmVsZWFzZXMgaW4gbGVzcyB0aGFuIDIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRpY2tzLCBjYXVzaW5nIHZlbG9jaXR5IHRvIGJlIDAuXG5cblxuICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgX2FkZExpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgcGFzc2l2ZSwgdHJ1ZSk7XG5cbiAgICAgIHNlbGYuZGVsdGFYID0gc2VsZi5kZWx0YVkgPSAwO1xuICAgICAgb25QcmVzcyAmJiBvblByZXNzKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vblJlbGVhc2UgPSBzZWxmLm9uUmVsZWFzZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3JlbW92ZUxpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgdHJ1ZSk7XG5cbiAgICAgIHZhciBpc1RyYWNraW5nRHJhZyA9ICFpc05hTihzZWxmLnkgLSBzZWxmLnN0YXJ0WSksXG4gICAgICAgICAgd2FzRHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmcsXG4gICAgICAgICAgaXNEcmFnTm90Q2xpY2sgPSB3YXNEcmFnZ2luZyAmJiAoTWF0aC5hYnMoc2VsZi54IC0gc2VsZi5zdGFydFgpID4gMyB8fCBNYXRoLmFicyhzZWxmLnkgLSBzZWxmLnN0YXJ0WSkgPiAzKSxcbiAgICAgICAgICAvLyBzb21lIHRvdWNoIGRldmljZXMgbmVlZCBzb21lIHdpZ2dsZSByb29tIGluIHRlcm1zIG9mIHNlbnNpbmcgY2xpY2tzIC0gdGhlIGZpbmdlciBtYXkgbW92ZSBhIGZldyBwaXhlbHMuXG4gICAgICBldmVudERhdGEgPSBfZ2V0RXZlbnQoZSk7XG5cbiAgICAgIGlmICghaXNEcmFnTm90Q2xpY2sgJiYgaXNUcmFja2luZ0RyYWcpIHtcbiAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgICBzZWxmLl92eS5yZXNldCgpOyAvL2lmIChwcmV2ZW50RGVmYXVsdCAmJiBhbGxvd0NsaWNrcyAmJiBzZWxmLmlzUHJlc3NlZCkgeyAvLyBjaGVjayBpc1ByZXNzZWQgYmVjYXVzZSBpbiBhIHJhcmUgZWRnZSBjYXNlLCB0aGUgaW5wdXRPYnNlcnZlciBpbiBTY3JvbGxUcmlnZ2VyIG1heSBzdG9wUHJvcGFnYXRpb24oKSBvbiB0aGUgcHJlc3MvZHJhZywgc28gdGhlIG9uUmVsZWFzZSBtYXkgZ2V0IGZpcmVkIHdpdGhvdXQgdGhlIG9uUHJlc3Mvb25EcmFnIGV2ZXIgZ2V0dGluZyBjYWxsZWQsIHRodXMgaXQgY291bGQgdHJpZ2dlciBhIGNsaWNrIHRvIG9jY3VyIG9uIGEgbGluayBhZnRlciBzY3JvbGwtZHJhZ2dpbmcgaXQuXG5cblxuICAgICAgICBpZiAocHJldmVudERlZmF1bHQgJiYgYWxsb3dDbGlja3MpIHtcbiAgICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuMDgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgd29uJ3QgdHJ1c3Qgc2NyaXB0LWdlbmVyYXRlZCBjbGlja3MsIHNvIGlmIHRoZSB1c2VyIHRyaWVzIHRvIGNsaWNrIG9uIGEgdmlkZW8gdG8gcGxheSBpdCwgZm9yIGV4YW1wbGUsIGl0IHNpbXBseSB3b24ndCB3b3JrLiBTaW5jZSBhIHJlZ3VsYXIgXCJjbGlja1wiIGV2ZW50IHdpbGwgbW9zdCBsaWtlbHkgYmUgZ2VuZXJhdGVkIGFueXdheSAob25lIHRoYXQgaGFzIGl0cyBpc1RydXN0ZWQgZmxhZyBzZXQgdG8gdHJ1ZSksIHdlIG11c3Qgc2xpZ2h0bHkgZGVsYXkgb3VyIHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2sgc28gdGhhdCB0aGUgXCJyZWFsXCIvdHJ1c3RlZCBvbmUgaXMgcHJpb3JpdGl6ZWQuIFJlbWVtYmVyLCB3aGVuIHRoZXJlIGFyZSBkdXBsaWNhdGUgZXZlbnRzIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHdlIHN1cHByZXNzIGFsbCBidXQgdGhlIGZpcnN0IG9uZS4gU29tZSBicm93c2VycyBkb24ndCBldmVuIHRyaWdnZXIgdGhlIFwicmVhbFwiIG9uZSBhdCBhbGwsIHNvIG91ciBzeW50aGV0aWMgb25lIGlzIGEgc2FmZXR5IHZhbHZlIHRoYXQgZW5zdXJlcyB0aGF0IG5vIG1hdHRlciB3aGF0LCBhIGNsaWNrIGV2ZW50IGRvZXMgZ2V0IGRpc3BhdGNoZWQuXG4gICAgICAgICAgICBpZiAoX2dldFRpbWUoKSAtIG9uQ2xpY2tUaW1lID4gMzAwICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgLy9zb21lIGJyb3dzZXJzIChsaWtlIG1vYmlsZSBTYWZhcmkpIGRvbid0IHByb3Blcmx5IHRyaWdnZXIgdGhlIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICAgICAgZS50YXJnZXQuY2xpY2soKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvd25lckRvYy5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW50aGV0aWNFdmVudCA9IG93bmVyRG9jLmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLCBfd2luLCAxLCBldmVudERhdGEuc2NyZWVuWCwgZXZlbnREYXRhLnNjcmVlblksIGV2ZW50RGF0YS5jbGllbnRYLCBldmVudERhdGEuY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc3ludGhldGljRXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc0dlc3R1cmluZyA9IHNlbGYuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICBvblN0b3AgJiYgd2FzRHJhZ2dpbmcgJiYgIWlzTm9ybWFsaXplciAmJiBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgICAgZHJhZ2dlZCAmJiB1cGRhdGUoKTsgLy8gaW4gY2FzZSBkZWJvdW5jaW5nLCB3ZSBkb24ndCB3YW50IG9uRHJhZyB0byBmaXJlIEFGVEVSIG9uRHJhZ0VuZCgpLlxuXG4gICAgICBvbkRyYWdFbmQgJiYgd2FzRHJhZ2dpbmcgJiYgb25EcmFnRW5kKHNlbGYpO1xuICAgICAgb25SZWxlYXNlICYmIG9uUmVsZWFzZShzZWxmLCBpc0RyYWdOb3RDbGljayk7XG4gICAgfSxcbiAgICAgICAgX29uR2VzdHVyZVN0YXJ0ID0gZnVuY3Rpb24gX29uR2VzdHVyZVN0YXJ0KGUpIHtcbiAgICAgIHJldHVybiBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEgJiYgKHNlbGYuaXNHZXN0dXJpbmcgPSB0cnVlKSAmJiBvbkdlc3R1cmVTdGFydChlLCBzZWxmLmlzRHJhZ2dpbmcpO1xuICAgIH0sXG4gICAgICAgIF9vbkdlc3R1cmVFbmQgPSBmdW5jdGlvbiBfb25HZXN0dXJlRW5kKCkge1xuICAgICAgcmV0dXJuIChzZWxmLmlzR2VzdHVyaW5nID0gZmFsc2UpIHx8IG9uR2VzdHVyZUVuZChzZWxmKTtcbiAgICB9LFxuICAgICAgICBvblNjcm9sbCA9IGZ1bmN0aW9uIG9uU2Nyb2xsKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IHNjcm9sbEZ1bmNYKCksXG4gICAgICAgICAgeSA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgICBvbkRlbHRhKCh4IC0gc2Nyb2xsWCkgKiBzY3JvbGxTcGVlZCwgKHkgLSBzY3JvbGxZKSAqIHNjcm9sbFNwZWVkLCAxKTtcbiAgICAgIHNjcm9sbFggPSB4O1xuICAgICAgc2Nyb2xsWSA9IHk7XG4gICAgICBvblN0b3AgJiYgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICB9LFxuICAgICAgICBfb25XaGVlbCA9IGZ1bmN0aW9uIF9vbldoZWVsKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlID0gX2dldEV2ZW50KGUsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgIG9uV2hlZWwgJiYgKHdoZWVsZWQgPSB0cnVlKTtcbiAgICAgIHZhciBtdWx0aXBsaWVyID0gKGUuZGVsdGFNb2RlID09PSAxID8gbGluZUhlaWdodCA6IGUuZGVsdGFNb2RlID09PSAyID8gX3dpbi5pbm5lckhlaWdodCA6IDEpICogd2hlZWxTcGVlZDtcbiAgICAgIG9uRGVsdGEoZS5kZWx0YVggKiBtdWx0aXBsaWVyLCBlLmRlbHRhWSAqIG11bHRpcGxpZXIsIDApO1xuICAgICAgb25TdG9wICYmICFpc05vcm1hbGl6ZXIgJiYgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICB9LFxuICAgICAgICBfb25Nb3ZlID0gZnVuY3Rpb24gX29uTW92ZShlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBlLmNsaWVudFgsXG4gICAgICAgICAgeSA9IGUuY2xpZW50WSxcbiAgICAgICAgICBkeCA9IHggLSBzZWxmLngsXG4gICAgICAgICAgZHkgPSB5IC0gc2VsZi55O1xuICAgICAgc2VsZi54ID0geDtcbiAgICAgIHNlbGYueSA9IHk7XG4gICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICBvblN0b3AgJiYgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgIChkeCB8fCBkeSkgJiYgb25Ub3VjaE9yUG9pbnRlckRlbHRhKGR4LCBkeSk7XG4gICAgfSxcbiAgICAgICAgX29uSG92ZXIgPSBmdW5jdGlvbiBfb25Ib3ZlcihlKSB7XG4gICAgICBzZWxmLmV2ZW50ID0gZTtcbiAgICAgIG9uSG92ZXIoc2VsZik7XG4gICAgfSxcbiAgICAgICAgX29uSG92ZXJFbmQgPSBmdW5jdGlvbiBfb25Ib3ZlckVuZChlKSB7XG4gICAgICBzZWxmLmV2ZW50ID0gZTtcbiAgICAgIG9uSG92ZXJFbmQoc2VsZik7XG4gICAgfSxcbiAgICAgICAgX29uQ2xpY2sgPSBmdW5jdGlvbiBfb25DbGljayhlKSB7XG4gICAgICByZXR1cm4gX2lnbm9yZUNoZWNrKGUpIHx8IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCkgJiYgb25DbGljayhzZWxmKTtcbiAgICB9O1xuXG4gICAgb25TdG9wRGVsYXllZENhbGwgPSBzZWxmLl9kYyA9IGdzYXAuZGVsYXllZENhbGwob25TdG9wRGVsYXkgfHwgMC4yNSwgb25TdG9wRnVuYykucGF1c2UoKTtcbiAgICBzZWxmLmRlbHRhWCA9IHNlbGYuZGVsdGFZID0gMDtcbiAgICBzZWxmLl92eCA9IF9nZXRWZWxvY2l0eVByb3AoMCwgNTAsIHRydWUpO1xuICAgIHNlbGYuX3Z5ID0gX2dldFZlbG9jaXR5UHJvcCgwLCA1MCwgdHJ1ZSk7XG4gICAgc2VsZi5zY3JvbGxYID0gc2Nyb2xsRnVuY1g7XG4gICAgc2VsZi5zY3JvbGxZID0gc2Nyb2xsRnVuY1k7XG4gICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc0dlc3R1cmluZyA9IHNlbGYuaXNQcmVzc2VkID0gZmFsc2U7XG5cbiAgICBfY29udGV4dCh0aGlzKTtcblxuICAgIHNlbGYuZW5hYmxlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghc2VsZi5pc0VuYWJsZWQpIHtcbiAgICAgICAgX2FkZExpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblxuICAgICAgICB0eXBlLmluZGV4T2YoXCJzY3JvbGxcIikgPj0gMCAmJiBfYWRkTGlzdGVuZXIoaXNWaWV3cG9ydCA/IG93bmVyRG9jIDogdGFyZ2V0LCBcInNjcm9sbFwiLCBvblNjcm9sbCwgcGFzc2l2ZSwgY2FwdHVyZSk7XG4gICAgICAgIHR5cGUuaW5kZXhPZihcIndoZWVsXCIpID49IDAgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJ3aGVlbFwiLCBfb25XaGVlbCwgcGFzc2l2ZSwgY2FwdHVyZSk7XG5cbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZihcInRvdWNoXCIpID49IDAgJiYgX2lzVG91Y2ggfHwgdHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSA+PSAwKSB7XG4gICAgICAgICAgX2FkZExpc3RlbmVyKHRhcmdldCwgX2V2ZW50VHlwZXNbMF0sIF9vblByZXNzLCBwYXNzaXZlLCBjYXB0dXJlKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbMl0sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBfZXZlbnRUeXBlc1szXSwgX29uUmVsZWFzZSk7XG5cbiAgICAgICAgICBhbGxvd0NsaWNrcyAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIGNsaWNrQ2FwdHVyZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgb25DbGljayAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIF9vbkNsaWNrKTtcbiAgICAgICAgICBvbkdlc3R1cmVTdGFydCAmJiBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZXN0YXJ0XCIsIF9vbkdlc3R1cmVTdGFydCk7XG4gICAgICAgICAgb25HZXN0dXJlRW5kICYmIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlZW5kXCIsIF9vbkdlc3R1cmVFbmQpO1xuICAgICAgICAgIG9uSG92ZXIgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJlbnRlclwiLCBfb25Ib3Zlcik7XG4gICAgICAgICAgb25Ib3ZlckVuZCAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcImxlYXZlXCIsIF9vbkhvdmVyRW5kKTtcbiAgICAgICAgICBvbk1vdmUgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJtb3ZlXCIsIF9vbk1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLmlzRHJhZ2dpbmcgPSBzZWxmLmlzR2VzdHVyaW5nID0gc2VsZi5pc1ByZXNzZWQgPSBtb3ZlZCA9IGRyYWdnZWQgPSBmYWxzZTtcblxuICAgICAgICBzZWxmLl92eC5yZXNldCgpO1xuXG4gICAgICAgIHNlbGYuX3Z5LnJlc2V0KCk7XG5cbiAgICAgICAgc2Nyb2xsWCA9IHNjcm9sbEZ1bmNYKCk7XG4gICAgICAgIHNjcm9sbFkgPSBzY3JvbGxGdW5jWSgpO1xuICAgICAgICBlICYmIGUudHlwZSAmJiBfb25QcmVzcyhlKTtcbiAgICAgICAgb25FbmFibGUgJiYgb25FbmFibGUoc2VsZik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBzZWxmLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5pc0VuYWJsZWQpIHtcbiAgICAgICAgLy8gb25seSByZW1vdmUgdGhlIF9vblNjcm9sbCBsaXN0ZW5lciBpZiB0aGVyZSBhcmVuJ3QgYW55IG90aGVycyB0aGF0IHJlbHkgb24gdGhlIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgIF9vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgcmV0dXJuIG8gIT09IHNlbGYgJiYgX2lzVmlld3BvcnQoby50YXJnZXQpO1xuICAgICAgICB9KS5sZW5ndGggfHwgX3JlbW92ZUxpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblxuICAgICAgICBpZiAoc2VsZi5pc1ByZXNzZWQpIHtcbiAgICAgICAgICBzZWxmLl92eC5yZXNldCgpO1xuXG4gICAgICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihpc05vcm1hbGl6ZXIgPyB0YXJnZXQgOiBvd25lckRvYywgX2V2ZW50VHlwZXNbMV0sIF9vbkRyYWcsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgb25TY3JvbGwsIGNhcHR1cmUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIFwid2hlZWxcIiwgX29uV2hlZWwsIGNhcHR1cmUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIF9ldmVudFR5cGVzWzBdLCBfb25QcmVzcywgY2FwdHVyZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBfZXZlbnRUeXBlc1syXSwgX29uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBfZXZlbnRUeXBlc1szXSwgX29uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBjbGlja0NhcHR1cmUsIHRydWUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIFwiY2xpY2tcIiwgX29uQ2xpY2spO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlc3RhcnRcIiwgX29uR2VzdHVyZVN0YXJ0KTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZWVuZFwiLCBfb25HZXN0dXJlRW5kKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcImVudGVyXCIsIF9vbkhvdmVyKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcImxlYXZlXCIsIF9vbkhvdmVyRW5kKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcIm1vdmVcIiwgX29uTW92ZSk7XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBzZWxmLmlzUHJlc3NlZCA9IHNlbGYuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBvbkRpc2FibGUgJiYgb25EaXNhYmxlKHNlbGYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmtpbGwgPSBzZWxmLnJldmVydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZGlzYWJsZSgpO1xuXG4gICAgICB2YXIgaSA9IF9vYnNlcnZlcnMuaW5kZXhPZihzZWxmKTtcblxuICAgICAgaSA+PSAwICYmIF9vYnNlcnZlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgX25vcm1hbGl6ZXIgPT09IHNlbGYgJiYgKF9ub3JtYWxpemVyID0gMCk7XG4gICAgfTtcblxuICAgIF9vYnNlcnZlcnMucHVzaChzZWxmKTtcblxuICAgIGlzTm9ybWFsaXplciAmJiBfaXNWaWV3cG9ydCh0YXJnZXQpICYmIChfbm9ybWFsaXplciA9IHNlbGYpO1xuICAgIHNlbGYuZW5hYmxlKGV2ZW50KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcInZlbG9jaXR5WFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Z4LmdldFZlbG9jaXR5KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZlbG9jaXR5WVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Z5LmdldFZlbG9jaXR5KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmVyO1xufSgpO1xuT2JzZXJ2ZXIudmVyc2lvbiA9IFwiMy4xMi43XCI7XG5cbk9ic2VydmVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIodmFycyk7XG59O1xuXG5PYnNlcnZlci5yZWdpc3RlciA9IF9pbml0Q29yZTtcblxuT2JzZXJ2ZXIuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX29ic2VydmVycy5zbGljZSgpO1xufTtcblxuT2JzZXJ2ZXIuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gX29ic2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gby52YXJzLmlkID09PSBpZDtcbiAgfSlbMF07XG59O1xuXG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oT2JzZXJ2ZXIpO1xuZXhwb3J0IHsgT2JzZXJ2ZXIgYXMgZGVmYXVsdCwgX2lzVmlld3BvcnQsIF9zY3JvbGxlcnMsIF9nZXRTY3JvbGxGdW5jLCBfZ2V0UHJveHlQcm9wLCBfcHJveGllcywgX2dldFZlbG9jaXR5UHJvcCwgX3ZlcnRpY2FsLCBfaG9yaXpvbnRhbCwgX2dldFRhcmdldCB9OyJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiZ3NhcCIsIl9jb3JlSW5pdHRlZCIsIl9jbGFtcCIsIl93aW4iLCJfZG9jIiwiX2RvY0VsIiwiX2JvZHkiLCJfaXNUb3VjaCIsIl9wb2ludGVyVHlwZSIsIlNjcm9sbFRyaWdnZXIiLCJfcm9vdCIsIl9ub3JtYWxpemVyIiwiX2V2ZW50VHlwZXMiLCJfY29udGV4dCIsIl9nZXRHU0FQIiwid2luZG93IiwicmVnaXN0ZXJQbHVnaW4iLCJfc3RhcnR1cCIsIl9vYnNlcnZlcnMiLCJfc2Nyb2xsZXJzIiwiX3Byb3hpZXMiLCJfZ2V0VGltZSIsIkRhdGUiLCJub3ciLCJfYnJpZGdlIiwibmFtZSIsInZhbHVlIiwiX2ludGVncmF0ZSIsImNvcmUiLCJkYXRhIiwiYnJpZGdlIiwic2Nyb2xsZXJzIiwicHJveGllcyIsInB1c2giLCJhcHBseSIsIl9nZXRQcm94eVByb3AiLCJlbGVtZW50IiwicHJvcGVydHkiLCJpbmRleE9mIiwiX2lzVmlld3BvcnQiLCJlbCIsIl9hZGRMaXN0ZW5lciIsInR5cGUiLCJmdW5jIiwicGFzc2l2ZSIsImNhcHR1cmUiLCJhZGRFdmVudExpc3RlbmVyIiwiX3JlbW92ZUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9zY3JvbGxMZWZ0IiwiX3Njcm9sbFRvcCIsIl9vblNjcm9sbCIsImlzUHJlc3NlZCIsImNhY2hlIiwiX3Njcm9sbENhY2hlRnVuYyIsImYiLCJkb05vdENhY2hlIiwiY2FjaGluZ0Z1bmMiLCJoaXN0b3J5Iiwic2Nyb2xsUmVzdG9yYXRpb24iLCJpc05vcm1hbGl6aW5nIiwidiIsIk1hdGgiLCJyb3VuZCIsImlPUyIsImNhY2hlSUQiLCJvZmZzZXQiLCJfaG9yaXpvbnRhbCIsInMiLCJwIiwicDIiLCJvcyIsIm9zMiIsImQiLCJkMiIsImEiLCJzYyIsImFyZ3VtZW50cyIsInNjcm9sbFRvIiwiX3ZlcnRpY2FsIiwicGFnZVhPZmZzZXQiLCJvcCIsInBhZ2VZT2Zmc2V0IiwiX2dldFRhcmdldCIsInQiLCJzZWxmIiwiX2N0eCIsInNlbGVjdG9yIiwidXRpbHMiLCJ0b0FycmF5IiwiY29uZmlnIiwibnVsbFRhcmdldFdhcm4iLCJjb25zb2xlIiwid2FybiIsIl9nZXRTY3JvbGxGdW5jIiwiX3JlZiIsInNjcm9sbGluZ0VsZW1lbnQiLCJwcmV2Iiwic21vb3RoIiwiZ2V0UHJvcGVydHkiLCJfZ2V0VmVsb2NpdHlQcm9wIiwibWluVGltZVJlZnJlc2giLCJ1c2VEZWx0YSIsInYxIiwidjIiLCJ0MSIsInQyIiwibWluIiwiZHJvcFRvWmVyb1RpbWUiLCJtYXgiLCJ1cGRhdGUiLCJmb3JjZSIsInJlc2V0IiwiZ2V0VmVsb2NpdHkiLCJsYXRlc3RWYWx1ZSIsInRPbGQiLCJ2T2xkIiwiX2dldEV2ZW50IiwiZSIsInByZXZlbnREZWZhdWx0IiwiX2dzYXBBbGxvdyIsImNoYW5nZWRUb3VjaGVzIiwiX2dldEFic29sdXRlTWF4IiwiYWJzIiwiX3NldFNjcm9sbFRyaWdnZXIiLCJnbG9iYWxzIiwiX2luaXRDb3JlIiwiZG9jdW1lbnQiLCJib2R5IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xhbXAiLCJjb250ZXh0IiwiT2JzZXJ2ZXIiLCJpc1RvdWNoIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsIm1zTWF4VG91Y2hQb2ludHMiLCJldmVudFR5cGVzIiwic3BsaXQiLCJzZXRUaW1lb3V0IiwidmFycyIsImluaXQiLCJfcHJvdG8iLCJ0b2xlcmFuY2UiLCJkcmFnTWluaW11bSIsImxpbmVIZWlnaHQiLCJkZWJvdW5jZSIsIm9uU3RvcCIsIm9uU3RvcERlbGF5IiwiaWdub3JlIiwid2hlZWxTcGVlZCIsImV2ZW50Iiwib25EcmFnU3RhcnQiLCJvbkRyYWdFbmQiLCJvbkRyYWciLCJvblByZXNzIiwib25SZWxlYXNlIiwib25SaWdodCIsIm9uTGVmdCIsIm9uVXAiLCJvbkRvd24iLCJvbkNoYW5nZVgiLCJvbkNoYW5nZVkiLCJvbkNoYW5nZSIsIm9uVG9nZ2xlWCIsIm9uVG9nZ2xlWSIsIm9uSG92ZXIiLCJvbkhvdmVyRW5kIiwib25Nb3ZlIiwiaWdub3JlQ2hlY2siLCJpc05vcm1hbGl6ZXIiLCJvbkdlc3R1cmVTdGFydCIsIm9uR2VzdHVyZUVuZCIsIm9uV2hlZWwiLCJvbkVuYWJsZSIsIm9uRGlzYWJsZSIsIm9uQ2xpY2siLCJzY3JvbGxTcGVlZCIsImFsbG93Q2xpY2tzIiwibG9ja0F4aXMiLCJvbkxvY2tBeGlzIiwicGFyc2VGbG9hdCIsImdldENvbXB1dGVkU3R5bGUiLCJpZCIsIm9uU3RvcERlbGF5ZWRDYWxsIiwiZHJhZ2dlZCIsIm1vdmVkIiwid2hlZWxlZCIsImxvY2tlZCIsImF4aXMiLCJwcmV2RGVsdGFYIiwicHJldkRlbHRhWSIsInNjcm9sbEZ1bmNYIiwic2Nyb2xsRnVuY1kiLCJzY3JvbGxYIiwic2Nyb2xsWSIsImxpbWl0VG9Ub3VjaCIsImlzVmlld3BvcnQiLCJvd25lckRvYyIsIm93bmVyRG9jdW1lbnQiLCJkZWx0YVgiLCJkZWx0YVkiLCJvbkNsaWNrVGltZSIsImNsaWNrQ2FwdHVyZSIsIl9pZ25vcmVDaGVjayIsImlzUG9pbnRlck9yVG91Y2giLCJwb2ludGVyVHlwZSIsIm9uU3RvcEZ1bmMiLCJfdngiLCJfdnkiLCJwYXVzZSIsImR4IiwiZHkiLCJjaGFuZ2VkWCIsImNoYW5nZWRZIiwib25EZWx0YSIsIngiLCJ5IiwiaW5kZXgiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvblRvdWNoT3JQb2ludGVyRGVsdGEiLCJfb25EcmFnIiwiY2xpZW50WCIsImNsaWVudFkiLCJpc0RyYWdnaW5nIiwic3RhcnRYIiwic3RhcnRZIiwiX29uUHJlc3MiLCJidXR0b24iLCJfb25SZWxlYXNlIiwiaXNUcmFja2luZ0RyYWciLCJpc05hTiIsIndhc0RyYWdnaW5nIiwiaXNEcmFnTm90Q2xpY2siLCJldmVudERhdGEiLCJkZWxheWVkQ2FsbCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjbGljayIsImNyZWF0ZUV2ZW50Iiwic3ludGhldGljRXZlbnQiLCJpbml0TW91c2VFdmVudCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiZGlzcGF0Y2hFdmVudCIsImlzR2VzdHVyaW5nIiwicmVzdGFydCIsIl9vbkdlc3R1cmVTdGFydCIsInRvdWNoZXMiLCJfb25HZXN0dXJlRW5kIiwib25TY3JvbGwiLCJfb25XaGVlbCIsIm11bHRpcGxpZXIiLCJkZWx0YU1vZGUiLCJpbm5lckhlaWdodCIsIl9vbk1vdmUiLCJfb25Ib3ZlciIsIl9vbkhvdmVyRW5kIiwiX29uQ2xpY2siLCJfZGMiLCJlbmFibGUiLCJpc0VuYWJsZWQiLCJkaXNhYmxlIiwiZmlsdGVyIiwibyIsImtpbGwiLCJyZXZlcnQiLCJzcGxpY2UiLCJnZXQiLCJ2ZXJzaW9uIiwiY3JlYXRlIiwicmVnaXN0ZXIiLCJnZXRBbGwiLCJzbGljZSIsImdldEJ5SWQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/gsap/Observer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/gsap/ScrollTrigger.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/ScrollTrigger.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollTrigger: function() { return /* binding */ ScrollTrigger; },\n/* harmony export */   \"default\": function() { return /* binding */ ScrollTrigger; }\n/* harmony export */ });\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observer.js */ \"(app-pages-browser)/./node_modules/gsap/Observer.js\");\n/*!\n * ScrollTrigger 3.12.7\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize, _normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, _context, _scrollRestoration, _div100vh, _100vh, _isReverted, _clampingMax, _limitCallbacks, // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n_startup = 1, _getTime = Date.now, _time1 = _getTime(), _lastScrollTime = 0, _enabled = 0, _parseClamp = function _parseClamp(value, type, self) {\n    var clamp = _isString(value) && (value.substr(0, 6) === \"clamp(\" || value.indexOf(\"max\") > -1);\n    self[\"_\" + type + \"Clamp\"] = clamp;\n    return clamp ? value.substr(6, value.length - 7) : value;\n}, _keepClamp = function _keepClamp(value, clamp) {\n    return clamp && (!_isString(value) || value.substr(0, 6) !== \"clamp(\") ? \"clamp(\" + value + \")\" : value;\n}, _rafBugFix = function _rafBugFix() {\n    return _enabled && requestAnimationFrame(_rafBugFix);\n}, // in some browsers (like Firefox), screen repaints weren't consistent unless we had SOMETHING queued up in requestAnimationFrame()! So this just creates a super simple loop to keep it alive and smooth out repaints.\n_pointerDownHandler = function _pointerDownHandler() {\n    return _pointerIsDown = 1;\n}, _pointerUpHandler = function _pointerUpHandler() {\n    return _pointerIsDown = 0;\n}, _passThrough = function _passThrough(v) {\n    return v;\n}, _round = function _round(value) {\n    return Math.round(value * 100000) / 100000 || 0;\n}, _windowExists = function _windowExists() {\n    return \"object\" !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isViewport = function _isViewport(e) {\n    return !!~_root.indexOf(e);\n}, _getViewportDimension = function _getViewportDimension(dimensionProperty) {\n    return (dimensionProperty === \"Height\" ? _100vh : _win[\"inner\" + dimensionProperty]) || _docEl[\"client\" + dimensionProperty] || _body[\"client\" + dimensionProperty];\n}, _getBoundsFunc = function _getBoundsFunc(element) {\n    return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, \"getBoundingClientRect\") || (_isViewport(element) ? function() {\n        _winOffsets.width = _win.innerWidth;\n        _winOffsets.height = _100vh;\n        return _winOffsets;\n    } : function() {\n        return _getBounds(element);\n    });\n}, _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {\n    var d = _ref.d, d2 = _ref.d2, a = _ref.a;\n    return (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"getBoundingClientRect\")) ? function() {\n        return a()[d];\n    } : function() {\n        return (isViewport ? _getViewportDimension(d2) : scroller[\"client\" + d2]) || 0;\n    };\n}, _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\n    return !isViewport || ~_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.indexOf(element) ? _getBoundsFunc(element) : function() {\n        return _winOffsets;\n    };\n}, _maxScroll = function _maxScroll(element, _ref2) {\n    var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;\n    return Math.max(0, (s = \"scroll\" + d2) && (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - _getViewportDimension(d2) : element[s] - element[\"offset\" + d2]);\n}, _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\n    for(var i = 0; i < _autoRefresh.length; i += 3){\n        (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n    }\n}, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n}, _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n}, _endAnimation = function _endAnimation(animation, reversed, pause) {\n    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();\n}, _callback = function _callback(self, func) {\n    if (self.enabled) {\n        var result = self._ctx ? self._ctx.add(function() {\n            return func(self);\n        }) : func(self);\n        result && result.totalTime && (self.callbackAnimation = result);\n    }\n}, _abs = Math.abs, _left = \"left\", _top = \"top\", _right = \"right\", _bottom = \"bottom\", _width = \"width\", _height = \"height\", _Right = \"Right\", _Left = \"Left\", _Top = \"Top\", _Bottom = \"Bottom\", _padding = \"padding\", _margin = \"margin\", _Width = \"Width\", _Height = \"Height\", _px = \"px\", _getComputedStyle = function _getComputedStyle(element) {\n    return _win.getComputedStyle(element);\n}, _makePositionable = function _makePositionable(element) {\n    // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative\n    var position = _getComputedStyle(element).position;\n    element.style.position = position === \"absolute\" || position === \"fixed\" ? position : \"relative\";\n}, _setDefaults = function _setDefaults(obj, defaults) {\n    for(var p in defaults){\n        p in obj || (obj[p] = defaults[p]);\n    }\n    return obj;\n}, _getBounds = function _getBounds(element, withoutTransforms) {\n    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\n        x: 0,\n        y: 0,\n        xPercent: 0,\n        yPercent: 0,\n        rotation: 0,\n        rotationX: 0,\n        rotationY: 0,\n        scale: 1,\n        skewX: 0,\n        skewY: 0\n    }).progress(1), bounds = element.getBoundingClientRect();\n    tween && tween.progress(0).kill();\n    return bounds;\n}, _getSize = function _getSize(element, _ref3) {\n    var d2 = _ref3.d2;\n    return element[\"offset\" + d2] || element[\"client\" + d2] || 0;\n}, _getLabelRatioArray = function _getLabelRatioArray(timeline) {\n    var a = [], labels = timeline.labels, duration = timeline.duration(), p;\n    for(p in labels){\n        a.push(labels[p] / duration);\n    }\n    return a;\n}, _getClosestLabel = function _getClosestLabel(animation) {\n    return function(value) {\n        return gsap.utils.snap(_getLabelRatioArray(animation), value);\n    };\n}, _snapDirectional = function _snapDirectional(snapIncrementOrArray) {\n    var snap = gsap.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a, b) {\n        return a - b;\n    });\n    return a ? function(value, direction, threshold) {\n        if (threshold === void 0) {\n            threshold = 1e-3;\n        }\n        var i;\n        if (!direction) {\n            return snap(value);\n        }\n        if (direction > 0) {\n            value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.\n            for(i = 0; i < a.length; i++){\n                if (a[i] >= value) {\n                    return a[i];\n                }\n            }\n            return a[i - 1];\n        } else {\n            i = a.length;\n            value += threshold;\n            while(i--){\n                if (a[i] <= value) {\n                    return a[i];\n                }\n            }\n        }\n        return a[0];\n    } : function(value, direction, threshold) {\n        if (threshold === void 0) {\n            threshold = 1e-3;\n        }\n        var snapped = snap(value);\n        return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);\n    };\n}, _getLabelAtDirection = function _getLabelAtDirection(timeline) {\n    return function(value, st) {\n        return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);\n    };\n}, _multiListener = function _multiListener(func, element, types, callback) {\n    return types.split(\",\").forEach(function(type) {\n        return func(element, type, callback);\n    });\n}, _addListener = function _addListener(element, type, func, nonPassive, capture) {\n    return element.addEventListener(type, func, {\n        passive: !nonPassive,\n        capture: !!capture\n    });\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    return element.removeEventListener(type, func, !!capture);\n}, _wheelListener = function _wheelListener(func, el, scrollFunc) {\n    scrollFunc = scrollFunc && scrollFunc.wheelHandler;\n    if (scrollFunc) {\n        func(el, \"wheel\", scrollFunc);\n        func(el, \"touchmove\", scrollFunc);\n    }\n}, _markerDefaults = {\n    startColor: \"green\",\n    endColor: \"red\",\n    indent: 0,\n    fontSize: \"16px\",\n    fontWeight: \"normal\"\n}, _defaults = {\n    toggleActions: \"play\",\n    anticipatePin: 0\n}, _keywords = {\n    top: 0,\n    left: 0,\n    center: 0.5,\n    bottom: 1,\n    right: 1\n}, _offsetToPx = function _offsetToPx(value, size) {\n    if (_isString(value)) {\n        var eqIndex = value.indexOf(\"=\"), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n        if (~eqIndex) {\n            value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\n            value = value.substr(0, eqIndex - 1);\n        }\n        value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n    }\n    return value;\n}, _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {\n    var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;\n    var e = _doc.createElement(\"div\"), useFixedPosition = _isViewport(container) || (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(container, \"pinType\") === \"fixed\", isScroller = type.indexOf(\"scroller\") !== -1, parent = useFixedPosition ? _body : container, isStart = type.indexOf(\"start\") !== -1, color = isStart ? startColor : endColor, css = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n    css += \"position:\" + ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\n    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n    matchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n    e._isStart = isStart;\n    e.setAttribute(\"class\", \"gsap-marker-\" + type + (name ? \" marker-\" + name : \"\"));\n    e.style.cssText = css;\n    e.innerText = name || name === 0 ? type + \"-\" + name : type;\n    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n    e._offset = e[\"offset\" + direction.op.d2];\n    _positionMarker(e, 0, direction, isStart);\n    return e;\n}, _positionMarker = function _positionMarker(marker, start, direction, flipped) {\n    var vars = {\n        display: \"block\"\n    }, side = direction[flipped ? \"os2\" : \"p2\"], oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n    marker._isFlipped = flipped;\n    vars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n    vars[direction.a] = flipped ? \"1px\" : 0;\n    vars[\"border\" + side + _Width] = 1;\n    vars[\"border\" + oppositeSide + _Width] = 0;\n    vars[direction.p] = start + \"px\";\n    gsap.set(marker, vars);\n}, _triggers = [], _ids = {}, _rafID, _sync = function _sync() {\n    return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));\n}, _onScroll = function _onScroll() {\n    // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010\n    if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {\n        // if the user is dragging the scrollbar, allow it.\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n        if (_normalizer) {\n            _rafID || (_rafID = requestAnimationFrame(_updateAll));\n        } else {\n            _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110\n        }\n        _lastScrollTime || _dispatch(\"scrollStart\");\n        _lastScrollTime = _getTime();\n    }\n}, _setBaseDimensions = function _setBaseDimensions() {\n    _baseScreenWidth = _win.innerWidth;\n    _baseScreenHeight = _win.innerHeight;\n}, _onResize = function _onResize(force) {\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n    (force === true || !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25)) && _resizeDelay.restart(true);\n}, // ignore resizes triggered by refresh()\n_listeners = {}, _emptyArray = [], _softRefresh = function _softRefresh() {\n    return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true);\n}, _dispatch = function _dispatch(type) {\n    return _listeners[type] && _listeners[type].map(function(f) {\n        return f();\n    }) || _emptyArray;\n}, _savedStyles = [], // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n_revertRecorded = function _revertRecorded(media) {\n    for(var i = 0; i < _savedStyles.length; i += 5){\n        if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {\n            _savedStyles[i].style.cssText = _savedStyles[i + 1];\n            _savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i + 2] || \"\");\n            _savedStyles[i + 3].uncache = 1;\n        }\n    }\n}, _revertAll = function _revertAll(kill, media) {\n    var trigger;\n    for(_i = 0; _i < _triggers.length; _i++){\n        trigger = _triggers[_i];\n        if (trigger && (!media || trigger._ctx === media)) {\n            if (kill) {\n                trigger.kill(1);\n            } else {\n                trigger.revert(true, true);\n            }\n        }\n    }\n    _isReverted = true;\n    media && _revertRecorded(media);\n    media || _dispatch(\"revert\");\n}, _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {\n    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n    (force || !_refreshingAll) && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);\n    });\n    _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);\n}, _refreshingAll, _refreshID = 0, _queueRefreshID, _queueRefreshAll = function _queueRefreshAll() {\n    // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's \"load\" or \"DOMContentLoaded\" events to trigger it.\n    if (_queueRefreshID !== _refreshID) {\n        var id = _queueRefreshID = _refreshID;\n        requestAnimationFrame(function() {\n            return id === _refreshID && _refreshAll(true);\n        });\n    }\n}, _refresh100vh = function _refresh100vh() {\n    _body.appendChild(_div100vh);\n    _100vh = !_normalizer && _div100vh.offsetHeight || _win.innerHeight;\n    _body.removeChild(_div100vh);\n}, _hideAllMarkers = function _hideAllMarkers(hide) {\n    return _toArray(\".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end\").forEach(function(el) {\n        return el.style.display = hide ? \"none\" : \"block\";\n    });\n}, _refreshAll = function _refreshAll(force, skipRevert) {\n    _docEl = _doc.documentElement; // some frameworks like Astro may cache the <body> and replace it during routing, so we'll just re-record the _docEl and _body for safety (otherwise, the markers may not get added properly).\n    _body = _doc.body;\n    _root = [\n        _win,\n        _doc,\n        _docEl,\n        _body\n    ];\n    if (_lastScrollTime && !force && !_isReverted) {\n        _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n        return;\n    }\n    _refresh100vh();\n    _refreshingAll = ScrollTrigger.isRefreshing = true;\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        return _isFunction(obj) && ++obj.cacheID && (obj.rec = obj());\n    }); // force the clearing of the cache because some browsers take a little while to dispatch the \"scroll\" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away\n    var refreshInits = _dispatch(\"refreshInit\");\n    _sort && ScrollTrigger.sort();\n    skipRevert || _revertAll();\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        if (_isFunction(obj)) {\n            obj.smooth && (obj.target.style.scrollBehavior = \"auto\"); // smooth scrolling interferes\n            obj(0);\n        }\n    });\n    _triggers.slice(0).forEach(function(t) {\n        return t.refresh();\n    }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.\n    _isReverted = false;\n    _triggers.forEach(function(t) {\n        // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.\n        if (t._subPinOffset && t.pin) {\n            var prop = t.vars.horizontal ? \"offsetWidth\" : \"offsetHeight\", original = t.pin[prop];\n            t.revert(true, 1);\n            t.adjustPinSpacing(t.pin[prop] - original);\n            t.refresh();\n        }\n    });\n    _clampingMax = 1; // pinSpacing might be propping a page open, thus when we .setPositions() to clamp a ScrollTrigger's end we should leave the pinSpacing alone. That's what this flag is for.\n    _hideAllMarkers(true);\n    _triggers.forEach(function(t) {\n        // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: \"max\". Same for anything with a clamped end\n        var max = _maxScroll(t.scroller, t._dir), endClamp = t.vars.end === \"max\" || t._endClamp && t.end > max, startClamp = t._startClamp && t.start >= max;\n        (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);\n    });\n    _hideAllMarkers(false);\n    _clampingMax = 0;\n    refreshInits.forEach(function(result) {\n        return result && result.render && result.render(-1);\n    }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        if (_isFunction(obj)) {\n            obj.smooth && requestAnimationFrame(function() {\n                return obj.target.style.scrollBehavior = \"smooth\";\n            });\n            obj.rec && obj(obj.rec);\n        }\n    });\n    _clearScrollMemory(_scrollRestoration, 1);\n    _resizeDelay.pause();\n    _refreshID++;\n    _refreshingAll = 2;\n    _updateAll(2);\n    _triggers.forEach(function(t) {\n        return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);\n    });\n    _refreshingAll = ScrollTrigger.isRefreshing = false;\n    _dispatch(\"refresh\");\n}, _lastScroll = 0, _direction = 1, _primary, _updateAll = function _updateAll(force) {\n    if (force === 2 || !_refreshingAll && !_isReverted) {\n        // _isReverted could be true if, for example, a matchMedia() is in the process of executing. We don't want to update during the time everything is reverted.\n        ScrollTrigger.isUpdating = true;\n        _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.\n        var l = _triggers.length, time = _getTime(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();\n        _direction = _lastScroll > scroll ? -1 : 1;\n        _refreshingAll || (_lastScroll = scroll);\n        if (recordVelocity) {\n            if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n                _lastScrollTime = 0;\n                _dispatch(\"scrollEnd\");\n            }\n            _time2 = _time1;\n            _time1 = time;\n        }\n        if (_direction < 0) {\n            _i = l;\n            while(_i-- > 0){\n                _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n            }\n            _direction = 1;\n        } else {\n            for(_i = 0; _i < l; _i++){\n                _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n            }\n        }\n        ScrollTrigger.isUpdating = false;\n    }\n    _rafID = 0;\n}, _propNamesToCopy = [\n    _left,\n    _top,\n    _bottom,\n    _right,\n    _margin + _Bottom,\n    _margin + _Right,\n    _margin + _Top,\n    _margin + _Left,\n    \"display\",\n    \"flexShrink\",\n    \"float\",\n    \"zIndex\",\n    \"gridColumnStart\",\n    \"gridColumnEnd\",\n    \"gridRowStart\",\n    \"gridRowEnd\",\n    \"gridArea\",\n    \"justifySelf\",\n    \"alignSelf\",\n    \"placeSelf\",\n    \"order\"\n], _stateProps = _propNamesToCopy.concat([\n    _width,\n    _height,\n    \"boxSizing\",\n    \"max\" + _Width,\n    \"max\" + _Height,\n    \"position\",\n    _margin,\n    _padding,\n    _padding + _Top,\n    _padding + _Right,\n    _padding + _Bottom,\n    _padding + _Left\n]), _swapPinOut = function _swapPinOut(pin, spacer, state) {\n    _setState(state);\n    var cache = pin._gsap;\n    if (cache.spacerIsNative) {\n        _setState(cache.spacerState);\n    } else if (pin._gsap.swappedIn) {\n        var parent = spacer.parentNode;\n        if (parent) {\n            parent.insertBefore(pin, spacer);\n            parent.removeChild(spacer);\n        }\n    }\n    pin._gsap.swappedIn = false;\n}, _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\n    if (!pin._gsap.swappedIn) {\n        var i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p;\n        while(i--){\n            p = _propNamesToCopy[i];\n            spacerStyle[p] = cs[p];\n        }\n        spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n        cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\n        pinStyle[_bottom] = pinStyle[_right] = \"auto\";\n        spacerStyle.flexBasis = cs.flexBasis || \"auto\";\n        spacerStyle.overflow = \"visible\";\n        spacerStyle.boxSizing = \"border-box\";\n        spacerStyle[_width] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal) + _px;\n        spacerStyle[_height] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical) + _px;\n        spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n        _setState(spacerState);\n        pinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\n        pinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\n        pinStyle[_padding] = cs[_padding];\n        if (pin.parentNode !== spacer) {\n            pin.parentNode.insertBefore(spacer, pin);\n            spacer.appendChild(pin);\n        }\n        pin._gsap.swappedIn = true;\n    }\n}, _capsExp = /([A-Z])/g, _setState = function _setState(state) {\n    if (state) {\n        var style = state.t.style, l = state.length, i = 0, p, value;\n        (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\n        for(; i < l; i += 2){\n            value = state[i + 1];\n            p = state[i];\n            if (value) {\n                style[p] = value;\n            } else if (style[p]) {\n                style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n            }\n        }\n    }\n}, _getState = function _getState(element) {\n    // returns an Array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n    var l = _stateProps.length, style = element.style, state = [], i = 0;\n    for(; i < l; i++){\n        state.push(_stateProps[i], style[_stateProps[i]]);\n    }\n    state.t = element;\n    return state;\n}, _copyState = function _copyState(state, override, omitOffsets) {\n    var result = [], l = state.length, i = omitOffsets ? 8 : 0, // skip top, left, right, bottom if omitOffsets is true\n    p;\n    for(; i < l; i += 2){\n        p = state[i];\n        result.push(p, p in override ? override[p] : state[i + 1]);\n    }\n    result.t = state.t;\n    return result;\n}, _winOffsets = {\n    left: 0,\n    top: 0\n}, // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition(\"#id\", \"top bottom\")\n// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {\n// \tscroller = _getTarget(scroller || _win);\n// \tlet direction = horizontal ? _horizontal : _vertical,\n// \t\tisViewport = _isViewport(scroller);\n// \t_getSizeFunc(scroller, isViewport, direction);\n// \treturn _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);\n// },\n_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {\n    _isFunction(value) && (value = value(self));\n    if (_isString(value) && value.substr(0, 3) === \"max\") {\n        value = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n    }\n    var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;\n    containerAnimation && containerAnimation.seek(0);\n    isNaN(value) || (value = +value); // convert a string number like \"45\" to an actual number\n    if (!_isNumber(value)) {\n        _isFunction(trigger) && (trigger = trigger(self));\n        var offsets = (value || \"0\").split(\" \"), bounds, localOffset, globalOffset, display;\n        element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger, self) || _body;\n        bounds = _getBounds(element) || {};\n        if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\n            // if display is \"none\", it won't report getBoundingClientRect() properly\n            display = element.style.display;\n            element.style.display = \"block\";\n            bounds = _getBounds(element);\n            display ? element.style.display = display : element.style.removeProperty(\"display\");\n        }\n        localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n        globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n        value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n        markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n        scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n    } else {\n        containerAnimation && (value = gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));\n        markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);\n    }\n    if (clampZeroProp) {\n        self[clampZeroProp] = value || -0.001;\n        value < 0 && (value = 0);\n    }\n    if (marker) {\n        var position = value + scrollerSize, isStart = marker._isStart;\n        p1 = \"scroll\" + direction.d2;\n        _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);\n        if (useFixedPosition) {\n            scrollerBounds = _getBounds(markerScroller);\n            useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n        }\n    }\n    if (containerAnimation && element) {\n        p1 = _getBounds(element);\n        containerAnimation.seek(scrollerMax);\n        p2 = _getBounds(element);\n        containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\n        value = value / containerAnimation._caScrollDist * scrollerMax;\n    }\n    containerAnimation && containerAnimation.seek(time);\n    return containerAnimation ? value : Math.round(value);\n}, _prefixExp = /(webkit|moz|length|cssText|inset)/i, _reparent = function _reparent(element, parent, top, left) {\n    if (element.parentNode !== parent) {\n        var style = element.style, p, cs;\n        if (parent === _body) {\n            element._stOrig = style.cssText; // record original inline styles so we can revert them later\n            cs = _getComputedStyle(element);\n            for(p in cs){\n                // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n                if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n                    style[p] = cs[p];\n                }\n            }\n            style.top = top;\n            style.left = left;\n        } else {\n            style.cssText = element._stOrig;\n        }\n        gsap.core.getCache(element).uncache = 1;\n        parent.appendChild(element);\n    }\n}, _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {\n    var last1 = initialValue, last2 = last1;\n    return function(value) {\n        var current = Math.round(getValueFunc()); // round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.\n        if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {\n            // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.\n            value = current;\n            onInterrupt && onInterrupt();\n        }\n        last2 = last1;\n        last1 = Math.round(value);\n        return last1;\n    };\n}, _shiftMarker = function _shiftMarker(marker, direction, value) {\n    var vars = {};\n    vars[direction.p] = \"+=\" + value;\n    gsap.set(marker, vars);\n}, // _mergeAnimations = animations => {\n// \tlet tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));\n// \tanimations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });\n// \ttl.smoothChildTiming = false;\n// \treturn tl;\n// },\n// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\n    var getScroll = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction), prop = \"_scroll\" + direction.p2, // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n    getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\n        var tween = getTween.tween, onComplete = vars.onComplete, modifiers = {};\n        initialValue = initialValue || getScroll();\n        var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {\n            tween.kill();\n            getTween.tween = 0;\n        });\n        change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.\n        change1 = change1 || scrollTo - initialValue;\n        tween && tween.kill();\n        vars[prop] = scrollTo;\n        vars.inherit = false;\n        vars.modifiers = modifiers;\n        modifiers[prop] = function() {\n            return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);\n        };\n        vars.onUpdate = function() {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n            getTween.tween && _updateAll(); // if it was interrupted/killed, like in a context.revert(), don't force an updateAll()\n        };\n        vars.onComplete = function() {\n            getTween.tween = 0;\n            onComplete && onComplete.call(tween);\n        };\n        tween = getTween.tween = gsap.to(scroller, vars);\n        return tween;\n    };\n    scroller[prop] = getScroll;\n    getScroll.wheelHandler = function() {\n        return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);\n    };\n    _addListener(scroller, \"wheel\", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like \"3 lines per scroll\") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.\n    ScrollTrigger.isTouch && _addListener(scroller, \"touchmove\", getScroll.wheelHandler);\n    return getTween;\n};\nvar ScrollTrigger = /*#__PURE__*/ function() {\n    function ScrollTrigger(vars, animation) {\n        _coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n        _context(this);\n        this.init(vars, animation);\n    }\n    var _proto = ScrollTrigger.prototype;\n    _proto.init = function init(vars, animation) {\n        this.progress = this.start = 0;\n        this.vars && this.kill(true, true); // in case it's being initted again\n        if (!_enabled) {\n            this.update = this.refresh = this.kill = _passThrough;\n            return;\n        }\n        vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n            trigger: vars\n        } : vars, _defaults);\n        var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical, isToggle = !scrub && scrub !== 0, scroller = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.scroller || _win), scrollerCache = gsap.core.getCache(scroller), isViewport = _isViewport(scroller), useFixedPosition = (\"pinType\" in vars ? vars.pinType : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"pinType\") || isViewport && \"fixed\") === \"fixed\", callbacks = [\n            vars.onEnter,\n            vars.onLeave,\n            vars.onEnterBack,\n            vars.onLeaveBack\n        ], toggleActions = isToggle && vars.toggleActions.split(\" \"), markers = \"markers\" in vars ? vars.markers : _defaults.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, self = this, onRefreshInit = vars.onRefreshInit && function() {\n            return vars.onRefreshInit(self);\n        }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn; // for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start=\"clamp(top bottom)\" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.\n        self._startClamp = self._endClamp = false;\n        self._dir = direction;\n        anticipatePin *= 45;\n        self.scroller = scroller;\n        self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\n        scroll1 = scrollFunc();\n        self.vars = vars;\n        animation = animation || vars.animation;\n        if (\"refreshPriority\" in vars) {\n            _sort = 1;\n            vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother\n        }\n        scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n            top: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\n            left: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)\n        };\n        self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n        self.scrubDuration = function(value) {\n            scrubSmooth = _isNumber(value) && value;\n            if (!scrubSmooth) {\n                scrubTween && scrubTween.progress(1).kill();\n                scrubTween = 0;\n            } else {\n                scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {\n                    ease: \"expo\",\n                    totalProgress: \"+=0\",\n                    inherit: false,\n                    duration: scrubSmooth,\n                    paused: true,\n                    onComplete: function onComplete() {\n                        return onScrubComplete && onScrubComplete(self);\n                    }\n                });\n            }\n        };\n        if (animation) {\n            animation.vars.lazy = false;\n            animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true); // special case: if this ScrollTrigger gets re-initted, a from() tween with a stagger could get initted initially and then reverted on the re-init which means it'll need to get rendered again here to properly display things. Otherwise, See https://gsap.com/forums/topic/36777-scrollsmoother-splittext-nextjs/ and https://codepen.io/GreenSock/pen/eYPyPpd?editors=0010\n            self.animation = animation.pause();\n            animation.scrollTrigger = self;\n            self.scrubDuration(scrub);\n            snap1 = 0;\n            id || (id = animation.vars.id);\n        }\n        if (snap) {\n            // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.\n            if (!_isObject(snap) || snap.push) {\n                snap = {\n                    snapTo: snap\n                };\n            }\n            \"scrollBehavior\" in _body.style && gsap.set(isViewport ? [\n                _body,\n                _docEl\n            ] : scroller, {\n                scrollBehavior: \"auto\"\n            }); // smooth scrolling doesn't work with snap.\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(o) {\n                return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = false);\n            }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters\n            snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? function(value, st) {\n                return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);\n            } : gsap.utils.snap(snap.snapTo);\n            snapDurClamp = snap.duration || {\n                min: 0.1,\n                max: 2\n            };\n            snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n            snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function() {\n                var scroll = scrollFunc(), refreshedRecently = _getTime() - lastRefresh < 500, tween = tweenTo.tween;\n                if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {\n                    var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0, change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress + (snap.inertia === false ? 0 : change1), endValue, endScroll, _snap = snap, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;\n                    endValue = snapFunc(naturalEnd, self);\n                    _isNumber(endValue) || (endValue = naturalEnd); // in case the function didn't return a number, fall back to using the naturalEnd\n                    endScroll = Math.max(0, Math.round(start + endValue * change));\n                    if (scroll <= end && scroll >= start && endScroll !== scroll) {\n                        if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {\n                            // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n                            return;\n                        }\n                        if (snap.inertia === false) {\n                            change1 = endValue - progress;\n                        }\n                        tweenTo(endScroll, {\n                            duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n                            ease: snap.ease || \"power3\",\n                            data: _abs(endScroll - scroll),\n                            // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n                            onInterrupt: function onInterrupt() {\n                                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);\n                            },\n                            onComplete: function onComplete() {\n                                self.update();\n                                lastSnap = scrollFunc();\n                                if (animation && !isToggle) {\n                                    // the resolution of the scrollbar is limited, so we should correct the scrubbed animation's playhead at the end to match EXACTLY where it was supposed to snap\n                                    scrubTween ? scrubTween.resetTo(\"totalProgress\", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);\n                                }\n                                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                                onSnapComplete && onSnapComplete(self);\n                                _onComplete && _onComplete(self);\n                            }\n                        }, scroll, change1 * change, endScroll - scroll - change1 * change);\n                        onStart && onStart(self, tweenTo.tween);\n                    }\n                } else if (self.isActive && lastSnap !== scroll) {\n                    snapDelayedCall.restart(true);\n                }\n            }).pause();\n        }\n        id && (_ids[id] = self);\n        trigger = self.trigger = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger || pin !== true && pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the \"y\" or \"x\" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.\n        customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;\n        customRevertReturn && (customRevertReturn = customRevertReturn(self));\n        pin = pin === true ? trigger : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pin);\n        _isString(toggleClass) && (toggleClass = {\n            targets: trigger,\n            className: toggleClass\n        });\n        if (pin) {\n            pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)\n            self.pin = pin;\n            pinCache = gsap.core.getCache(pin);\n            if (!pinCache.spacer) {\n                // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n                if (pinSpacer) {\n                    pinSpacer = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pinSpacer);\n                    pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular\n                    pinCache.spacerIsNative = !!pinSpacer;\n                    pinSpacer && (pinCache.spacerState = _getState(pinSpacer));\n                }\n                pinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\n                spacer.classList.add(\"pin-spacer\");\n                id && spacer.classList.add(\"pin-spacer-\" + id);\n                pinCache.pinState = pinOriginalState = _getState(pin);\n            } else {\n                pinOriginalState = pinCache.pinState;\n            }\n            vars.force3D !== false && gsap.set(pin, {\n                force3D: true\n            });\n            self.spacer = spacer = pinCache.spacer;\n            cs = _getComputedStyle(pin);\n            spacingStart = cs[pinSpacing + direction.os2];\n            pinGetter = gsap.getProperty(pin);\n            pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n            _swapPinIn(pin, spacer, cs);\n            pinState = _getState(pin);\n        }\n        if (markers) {\n            markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n            markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n            markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n            offset = markerStartTrigger[\"offset\" + direction.op.d2];\n            var content = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"content\") || scroller);\n            markerStart = this.markerStart = _createMarker(\"start\", id, content, direction, markerVars, offset, 0, containerAnimation);\n            markerEnd = this.markerEnd = _createMarker(\"end\", id, content, direction, markerVars, offset, 0, containerAnimation);\n            containerAnimation && (caMarkerSetter = gsap.quickSetter([\n                markerStart,\n                markerEnd\n            ], direction.a, _px));\n            if (!useFixedPosition && !(_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.length && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"fixedMarkers\") === true)) {\n                _makePositionable(isViewport ? _body : scroller);\n                gsap.set([\n                    markerStartTrigger,\n                    markerEndTrigger\n                ], {\n                    force3D: true\n                });\n                markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n                markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n            }\n        }\n        if (containerAnimation) {\n            var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;\n            containerAnimation.eventCallback(\"onUpdate\", function() {\n                self.update(0, 0, 1);\n                oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);\n            });\n        }\n        self.previous = function() {\n            return _triggers[_triggers.indexOf(self) - 1];\n        };\n        self.next = function() {\n            return _triggers[_triggers.indexOf(self) + 1];\n        };\n        self.revert = function(revert, temp) {\n            if (!temp) {\n                return self.kill(true);\n            } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()\n            var r = revert !== false || !self.enabled, prevRefreshing = _refreshing;\n            if (r !== self.isReverted) {\n                if (r) {\n                    prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n                    prevProgress = self.progress;\n                    prevAnimProgress = animation && animation.progress();\n                }\n                markerStart && [\n                    markerStart,\n                    markerEnd,\n                    markerStartTrigger,\n                    markerEndTrigger\n                ].forEach(function(m) {\n                    return m.style.display = r ? \"none\" : \"block\";\n                });\n                if (r) {\n                    _refreshing = self;\n                    self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out\n                }\n                if (pin && (!pinReparent || !self.isActive)) {\n                    if (r) {\n                        _swapPinOut(pin, spacer, pinOriginalState);\n                    } else {\n                        _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);\n                    }\n                }\n                r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.\n                _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.\n                self.isReverted = r;\n            }\n        };\n        self.refresh = function(soft, force, position, pinOffset) {\n            // position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects\n            if ((_refreshing || !self.enabled) && !force) {\n                return;\n            }\n            if (pin && soft && _lastScrollTime) {\n                _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n                return;\n            }\n            !_refreshingAll && onRefreshInit && onRefreshInit(self);\n            _refreshing = self;\n            if (tweenTo.tween && !position) {\n                // we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.\n                tweenTo.tween.kill();\n                tweenTo.tween = 0;\n            }\n            scrubTween && scrubTween.pause();\n            invalidateOnRefresh && animation && animation.revert({\n                kill: false\n            }).invalidate();\n            self.isReverted || self.revert(true, true);\n            self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any\n            var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= 0.01, offset = 0, otherPinOffset = pinOffset || 0, parsedEnd = _isObject(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? \"0 0\" : \"0 100%\"), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.pinnedContainer, self), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i = triggerIndex, cs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;\n            if (markers && _isObject(position)) {\n                // if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.\n                markerStartOffset = gsap.getProperty(markerStartTrigger, direction.p);\n                markerEndOffset = gsap.getProperty(markerEndTrigger, direction.p);\n            }\n            while(i-- > 0){\n                // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n                curTrigger = _triggers[i];\n                curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.\n                curPin = curTrigger.pin;\n                if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {\n                    revertedPins || (revertedPins = []);\n                    revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly\n                    curTrigger.revert(true, true);\n                }\n                if (curTrigger !== _triggers[i]) {\n                    // in case it got removed.\n                    triggerIndex--;\n                    i--;\n                }\n            }\n            _isFunction(parsedStart) && (parsedStart = parsedStart(self));\n            parsedStart = _parseClamp(parsedStart, \"start\", self);\n            start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && \"_startClamp\") || (pin ? -0.001 : 0);\n            _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n            if (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n                if (~parsedEnd.indexOf(\" \")) {\n                    parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n                } else {\n                    offset = _offsetToPx(parsedEnd.substr(2), size);\n                    parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n                    parsedEndTrigger = trigger;\n                }\n            }\n            parsedEnd = _parseClamp(parsedEnd, \"end\", self);\n            end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && \"_endClamp\")) || -0.001;\n            offset = 0;\n            i = triggerIndex;\n            while(i--){\n                curTrigger = _triggers[i];\n                curPin = curTrigger.pin;\n                if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {\n                    cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);\n                    if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {\n                        // numeric start values shouldn't be offset at all - treat them as absolute\n                        offset += cs * (1 - curTrigger.progress);\n                    }\n                    curPin === pin && (otherPinOffset += cs);\n                }\n            }\n            start += offset;\n            end += offset;\n            self._startClamp && (self._startClamp += offset);\n            if (self._endClamp && !_refreshingAll) {\n                self._endClamp = end || -0.001;\n                end = Math.min(end, _maxScroll(scroller, direction));\n            }\n            change = end - start || (start -= 0.01) && 0.001;\n            if (isFirstRefresh) {\n                // on the very first refresh(), the prevProgress couldn't have been accurate yet because the start/end were never calculated, so we set it here. Before 3.11.5, it could lead to an inaccurate scroll position restoration with snapping.\n                prevProgress = gsap.utils.clamp(0, 1, gsap.utils.normalize(start, end, prevScroll));\n            }\n            self._pinPush = otherPinOffset;\n            if (markerStart && offset) {\n                // offset the markers if necessary\n                cs = {};\n                cs[direction.a] = \"+=\" + offset;\n                pinnedContainer && (cs[direction.p] = \"-=\" + scrollFunc());\n                gsap.set([\n                    markerStart,\n                    markerEnd\n                ], cs);\n            }\n            if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {\n                cs = _getComputedStyle(pin);\n                isVertical = direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical;\n                scroll = scrollFunc(); // recalculate because the triggers can affect the scroll\n                pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n                if (!max && end > 1) {\n                    // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://gsap.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n                    forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl : scroller).style;\n                    forcedOverflow = {\n                        style: forcedOverflow,\n                        value: forcedOverflow[\"overflow\" + direction.a.toUpperCase()]\n                    };\n                    if (isViewport && _getComputedStyle(_body)[\"overflow\" + direction.a.toUpperCase()] !== \"scroll\") {\n                        // avoid an extra scrollbar if BOTH <html> and <body> have overflow set to \"scroll\"\n                        forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = \"scroll\";\n                    }\n                }\n                _swapPinIn(pin, spacer, cs);\n                pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n                bounds = _getBounds(pin, true);\n                oppositeScroll = useFixedPosition && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, isVertical ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)();\n                if (pinSpacing) {\n                    spacerState = [\n                        pinSpacing + direction.os2,\n                        change + otherPinOffset + _px\n                    ];\n                    spacerState.t = spacer;\n                    i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n                    if (i) {\n                        spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n                        spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n                    }\n                    _setState(spacerState);\n                    if (pinnedContainer) {\n                        // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.\n                        _triggers.forEach(function(t) {\n                            if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {\n                                t._subPinOffset = true;\n                            }\n                        });\n                    }\n                    useFixedPosition && scrollFunc(prevScroll);\n                } else {\n                    i = _getSize(pin, direction);\n                    i && spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n                }\n                if (useFixedPosition) {\n                    override = {\n                        top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\n                        left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\n                        boxSizing: \"border-box\",\n                        position: \"fixed\"\n                    };\n                    override[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n                    override[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n                    override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n                    override[_padding] = cs[_padding];\n                    override[_padding + _Top] = cs[_padding + _Top];\n                    override[_padding + _Right] = cs[_padding + _Right];\n                    override[_padding + _Bottom] = cs[_padding + _Bottom];\n                    override[_padding + _Left] = cs[_padding + _Left];\n                    pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n                    _refreshingAll && scrollFunc(0);\n                }\n                if (animation) {\n                    // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n                    initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\n                    _suppressOverwrites(1);\n                    animation.render(animation.duration(), true, true);\n                    pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n                    pinMoves = Math.abs(change - pinChange) > 1;\n                    useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n                    animation.render(0, true, true);\n                    initted || animation.invalidate(true);\n                    animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.\n                    _suppressOverwrites(0);\n                } else {\n                    pinChange = change;\n                }\n                forcedOverflow && (forcedOverflow.value ? forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty(\"overflow-\" + direction.a));\n            } else if (trigger && scrollFunc() && !containerAnimation) {\n                // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n                bounds = trigger.parentNode;\n                while(bounds && bounds !== _body){\n                    if (bounds._pinOffset) {\n                        start -= bounds._pinOffset;\n                        end -= bounds._pinOffset;\n                    }\n                    bounds = bounds.parentNode;\n                }\n            }\n            revertedPins && revertedPins.forEach(function(t) {\n                return t.revert(false, true);\n            });\n            self.start = start;\n            self.end = end;\n            scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity\n            if (!containerAnimation && !_refreshingAll) {\n                scroll1 < prevScroll && scrollFunc(prevScroll);\n                self.scroll.rec = 0;\n            }\n            self.revert(false, true);\n            lastRefresh = _getTime();\n            if (snapDelayedCall) {\n                lastSnap = -1; // just so snapping gets re-enabled, clear out any recorded last value\n                // self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.\n                snapDelayedCall.restart(true);\n            }\n            _refreshing = 0;\n            animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\n            if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh || animation && !animation._initted) {\n                // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n                animation && !isToggle && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap.utils.normalize(start, end, 0) : prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n                self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;\n            }\n            pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n            scrubTween && scrubTween.invalidate();\n            if (!isNaN(markerStartOffset)) {\n                // numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like \"top\", \"center\", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.\n                markerStartOffset -= gsap.getProperty(markerStartTrigger, direction.p);\n                markerEndOffset -= gsap.getProperty(markerEndTrigger, direction.p);\n                _shiftMarker(markerStartTrigger, direction, markerStartOffset);\n                _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));\n                _shiftMarker(markerEndTrigger, direction, markerEndOffset);\n                _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));\n            }\n            isFirstRefresh && !_refreshingAll && self.update(); // edge case - when you reload a page when it's already scrolled down, some browsers fire a \"scroll\" event before DOMContentLoaded, triggering an updateAll(). If we don't update the self.progress as part of refresh(), then when it happens next, it may record prevProgress as 0 when it really shouldn't, potentially causing a callback in an animation to fire again.\n            if (onRefresh && !_refreshingAll && !executingOnRefresh) {\n                // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.\n                executingOnRefresh = true;\n                onRefresh(self);\n                executingOnRefresh = false;\n            }\n        };\n        self.getVelocity = function() {\n            return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n        };\n        self.endAnimation = function() {\n            _endAnimation(self.callbackAnimation);\n            if (animation) {\n                scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);\n            }\n        };\n        self.labelToScroll = function(label) {\n            return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;\n        };\n        self.getTrailing = function(name) {\n            var i = _triggers.indexOf(self), a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);\n            return (_isString(name) ? a.filter(function(t) {\n                return t.vars.preventOverlaps === name;\n            }) : a).filter(function(t) {\n                return self.direction > 0 ? t.end <= start : t.start >= end;\n            });\n        };\n        self.update = function(reset, recordVelocity, forceFake) {\n            if (containerAnimation && !forceFake && !reset) {\n                return;\n            }\n            var scroll = _refreshingAll === true ? prevScroll : self.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress = self.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;\n            if (recordVelocity) {\n                scroll2 = scroll1;\n                scroll1 = containerAnimation ? scrollFunc() : scroll;\n                if (snap) {\n                    snap2 = snap1;\n                    snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n                }\n            } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n            if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {\n                if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n                    clipped = 0.0001;\n                } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n                    clipped = 0.9999;\n                }\n            }\n            if (clipped !== prevProgress && self.enabled) {\n                isActive = self.isActive = !!clipped && clipped < 1;\n                wasActive = !!prevProgress && prevProgress < 1;\n                toggled = isActive !== wasActive;\n                stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n                self.direction = clipped > prevProgress ? 1 : -1;\n                self.progress = clipped;\n                if (stateChanged && !_refreshing) {\n                    toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n                    if (isToggle) {\n                        action = !toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n                        isTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\n                    }\n                }\n                preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function(t) {\n                    return t.endAnimation();\n                }));\n                if (!isToggle) {\n                    if (scrubTween && !_refreshing && !_startup) {\n                        scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.\n                        if (scrubTween.resetTo) {\n                            scrubTween.resetTo(\"totalProgress\", clipped, animation._tTime / animation._tDur);\n                        } else {\n                            // legacy support (courtesy), before 3.10.0\n                            scrubTween.vars.totalProgress = clipped;\n                            scrubTween.invalidate().restart();\n                        }\n                    } else if (animation) {\n                        animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));\n                    }\n                }\n                if (pin) {\n                    reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n                    if (!useFixedPosition) {\n                        pinSetter(_round(pinStart + pinChange * clipped));\n                    } else if (stateChanged) {\n                        isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n                        if (pinReparent) {\n                            if (!reset && (isActive || isAtMax)) {\n                                var bounds = _getBounds(pin, true), _offset = scroll - start;\n                                _reparent(pin, _body, bounds.top + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? 0 : _offset) + _px);\n                            } else {\n                                _reparent(pin, spacer);\n                            }\n                        }\n                        _setState(isActive || isAtMax ? pinActiveState : pinState);\n                        pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));\n                    }\n                }\n                snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n                toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {\n                    return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\n                }); // classes could affect positioning, so do it even if reset or refreshing is true.\n                onUpdate && !isToggle && !reset && onUpdate(self);\n                if (stateChanged && !_refreshing) {\n                    if (isToggle) {\n                        if (isTakingAction) {\n                            if (action === \"complete\") {\n                                animation.pause().totalProgress(1);\n                            } else if (action === \"reset\") {\n                                animation.restart(true).pause();\n                            } else if (action === \"restart\") {\n                                animation.restart(true);\n                            } else {\n                                animation[action]();\n                            }\n                        }\n                        onUpdate && onUpdate(self);\n                    }\n                    if (toggled || !_limitCallbacks) {\n                        // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n                        onToggle && toggled && _callback(self, onToggle);\n                        callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n                        once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.\n                        if (!toggled) {\n                            // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n                            toggleState = clipped === 1 ? 1 : 3;\n                            callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n                        }\n                    }\n                    if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\n                        _endAnimation(self.callbackAnimation);\n                        scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === \"reverse\" ? 1 : !clipped, 1);\n                    }\n                } else if (isToggle && onUpdate && !_refreshing) {\n                    onUpdate(self);\n                }\n            } // update absolutely-positioned markers (only if the scroller isn't the viewport)\n            if (markerEndSetter) {\n                var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\n                markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));\n                markerEndSetter(n);\n            }\n            caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\n        };\n        self.enable = function(reset, refresh) {\n            if (!self.enabled) {\n                self.enabled = true;\n                _addListener(scroller, \"resize\", _onResize);\n                isViewport || _addListener(scroller, \"scroll\", _onScroll);\n                onRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n                if (reset !== false) {\n                    self.progress = prevProgress = 0;\n                    scroll1 = scroll2 = lastSnap = scrollFunc();\n                }\n                refresh !== false && self.refresh();\n            }\n        };\n        self.getTween = function(snap) {\n            return snap && tweenTo ? tweenTo.tween : scrubTween;\n        };\n        self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {\n            // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()\n            if (containerAnimation) {\n                // convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.\n                var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;\n                newStart = st.start + _change * newStart / duration;\n                newEnd = st.start + _change * newEnd / duration;\n            }\n            self.refresh(false, false, {\n                start: _keepClamp(newStart, keepClamp && !!self._startClamp),\n                end: _keepClamp(newEnd, keepClamp && !!self._endClamp)\n            }, pinOffset);\n            self.update();\n        };\n        self.adjustPinSpacing = function(amount) {\n            if (spacerState && amount) {\n                var i = spacerState.indexOf(direction.d) + 1;\n                spacerState[i] = parseFloat(spacerState[i]) + amount + _px;\n                spacerState[1] = parseFloat(spacerState[1]) + amount + _px;\n                _setState(spacerState);\n            }\n        };\n        self.disable = function(reset, allowAnimation) {\n            if (self.enabled) {\n                reset !== false && self.revert(true, true);\n                self.enabled = self.isActive = false;\n                allowAnimation || scrubTween && scrubTween.pause();\n                prevScroll = 0;\n                pinCache && (pinCache.uncache = 1);\n                onRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n                if (snapDelayedCall) {\n                    snapDelayedCall.pause();\n                    tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n                }\n                if (!isViewport) {\n                    var i = _triggers.length;\n                    while(i--){\n                        if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n                            return; //don't remove the listeners if there are still other triggers referencing it.\n                        }\n                    }\n                    _removeListener(scroller, \"resize\", _onResize);\n                    isViewport || _removeListener(scroller, \"scroll\", _onScroll);\n                }\n            }\n        };\n        self.kill = function(revert, allowAnimation) {\n            self.disable(revert, allowAnimation);\n            scrubTween && !allowAnimation && scrubTween.kill();\n            id && delete _ids[id];\n            var i = _triggers.indexOf(self);\n            i >= 0 && _triggers.splice(i, 1);\n            i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n            // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.\n            i = 0;\n            _triggers.forEach(function(t) {\n                return t.scroller === self.scroller && (i = 1);\n            });\n            i || _refreshingAll || (self.scroll.rec = 0);\n            if (animation) {\n                animation.scrollTrigger = null;\n                revert && animation.revert({\n                    kill: false\n                });\n                allowAnimation || animation.kill();\n            }\n            markerStart && [\n                markerStart,\n                markerEnd,\n                markerStartTrigger,\n                markerEndTrigger\n            ].forEach(function(m) {\n                return m.parentNode && m.parentNode.removeChild(m);\n            });\n            _primary === self && (_primary = 0);\n            if (pin) {\n                pinCache && (pinCache.uncache = 1);\n                i = 0;\n                _triggers.forEach(function(t) {\n                    return t.pin === pin && i++;\n                });\n                i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\n            }\n            vars.onKill && vars.onKill(self);\n        };\n        _triggers.push(self);\n        self.enable(false, false);\n        customRevertReturn && customRevertReturn(self);\n        if (animation && animation.add && !change) {\n            // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If \"change\" is defined, we know it must be re-enabling, thus we can refresh() right away.\n            var updateFunc = self.update; // some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().\n            self.update = function() {\n                self.update = updateFunc;\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++; // otherwise a cached scroll position may get used in the refresh() in a very rare scenario, like if ScrollTriggers are created inside a DOMContentLoaded event and the queued requestAnimationFrame() fires beforehand. See https://gsap.com/community/forums/topic/41267-scrolltrigger-breaks-on-refresh-when-using-domcontentloaded/\n                start || end || self.refresh();\n            };\n            gsap.delayedCall(0.01, self.update);\n            change = 0.01;\n            start = end = 0;\n        } else {\n            self.refresh();\n        }\n        pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()\n    };\n    ScrollTrigger.register = function register(core) {\n        if (!_coreInitted) {\n            gsap = core || _getGSAP();\n            _windowExists() && window.document && ScrollTrigger.enable();\n            _coreInitted = _enabled;\n        }\n        return _coreInitted;\n    };\n    ScrollTrigger.defaults = function defaults(config) {\n        if (config) {\n            for(var p in config){\n                _defaults[p] = config[p];\n            }\n        }\n        return _defaults;\n    };\n    ScrollTrigger.disable = function disable(reset, kill) {\n        _enabled = 0;\n        _triggers.forEach(function(trigger) {\n            return trigger[kill ? \"kill\" : \"disable\"](reset);\n        });\n        _removeListener(_win, \"wheel\", _onScroll);\n        _removeListener(_doc, \"scroll\", _onScroll);\n        clearInterval(_syncInterval);\n        _removeListener(_doc, \"touchcancel\", _passThrough);\n        _removeListener(_body, \"touchstart\", _passThrough);\n        _multiListener(_removeListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n        _multiListener(_removeListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n        _resizeDelay.kill();\n        _iterateAutoRefresh(_removeListener);\n        for(var i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3){\n            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n        }\n    };\n    ScrollTrigger.enable = function enable() {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n        if (gsap) {\n            _toArray = gsap.utils.toArray;\n            _clamp = gsap.utils.clamp;\n            _context = gsap.core.context || _passThrough;\n            _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n            _scrollRestoration = _win.history.scrollRestoration || \"auto\";\n            _lastScroll = _win.pageYOffset || 0;\n            gsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n            if (_body) {\n                _enabled = 1;\n                _div100vh = document.createElement(\"div\"); // to solve mobile browser address bar show/hide resizing, we shouldn't rely on window.innerHeight. Instead, use a <div> with its height set to 100vh and measure that since that's what the scrolling is based on anyway and it's not affected by address bar showing/hiding.\n                _div100vh.style.height = \"100vh\";\n                _div100vh.style.position = \"absolute\";\n                _refresh100vh();\n                _rafBugFix();\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n                ScrollTrigger.isTouch = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch;\n                _fixIOSBug = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503\n                _ignoreMobileResize = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch === 1;\n                _addListener(_win, \"wheel\", _onScroll); // mostly for 3rd party smooth scrolling libraries.\n                _root = [\n                    _win,\n                    _doc,\n                    _docEl,\n                    _body\n                ];\n                if (gsap.matchMedia) {\n                    ScrollTrigger.matchMedia = function(vars) {\n                        var mm = gsap.matchMedia(), p;\n                        for(p in vars){\n                            mm.add(p, vars[p]);\n                        }\n                        return mm;\n                    };\n                    gsap.addEventListener(\"matchMediaInit\", function() {\n                        return _revertAll();\n                    });\n                    gsap.addEventListener(\"matchMediaRevert\", function() {\n                        return _revertRecorded();\n                    });\n                    gsap.addEventListener(\"matchMedia\", function() {\n                        _refreshAll(0, 1);\n                        _dispatch(\"matchMedia\");\n                    });\n                    gsap.matchMedia().add(\"(orientation: portrait)\", function() {\n                        // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.\n                        _setBaseDimensions();\n                        return _setBaseDimensions;\n                    });\n                } else {\n                    console.warn(\"Requires GSAP 3.11.0 or later\");\n                }\n                _setBaseDimensions();\n                _addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n                var bodyHasStyle = _body.hasAttribute(\"style\"), bodyStyle = _body.style, border = bodyStyle.borderTopStyle, AnimationProto = gsap.core.Animation.prototype, bounds, i;\n                AnimationProto.revert || Object.defineProperty(AnimationProto, \"revert\", {\n                    value: function value() {\n                        return this.time(-0.01, true);\n                    }\n                }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)\n                bodyStyle.borderTopStyle = \"solid\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n                bounds = _getBounds(_body);\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.m = Math.round(bounds.top + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.m = Math.round(bounds.left + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.sc()) || 0;\n                border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty(\"border-top-style\");\n                if (!bodyHasStyle) {\n                    // SSR frameworks like Next.js complain if this attribute gets added.\n                    _body.setAttribute(\"style\", \"\"); // it's not enough to just removeAttribute() - we must first set it to empty, otherwise Next.js complains.\n                    _body.removeAttribute(\"style\");\n                } // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.\n                _syncInterval = setInterval(_sync, 250);\n                gsap.delayedCall(0.5, function() {\n                    return _startup = 0;\n                });\n                _addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n                _addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n                _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n                _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n                _transformProp = gsap.utils.checkPrefix(\"transform\");\n                _stateProps.push(_transformProp);\n                _coreInitted = _getTime();\n                _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n                _autoRefresh = [\n                    _doc,\n                    \"visibilitychange\",\n                    function() {\n                        var w = _win.innerWidth, h = _win.innerHeight;\n                        if (_doc.hidden) {\n                            _prevWidth = w;\n                            _prevHeight = h;\n                        } else if (_prevWidth !== w || _prevHeight !== h) {\n                            _onResize();\n                        }\n                    },\n                    _doc,\n                    \"DOMContentLoaded\",\n                    _refreshAll,\n                    _win,\n                    \"load\",\n                    _refreshAll,\n                    _win,\n                    \"resize\",\n                    _onResize\n                ];\n                _iterateAutoRefresh(_addListener);\n                _triggers.forEach(function(trigger) {\n                    return trigger.enable(0, 1);\n                });\n                for(i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3){\n                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n                }\n            }\n        }\n    };\n    ScrollTrigger.config = function config(vars) {\n        \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n        var ms = vars.syncInterval;\n        ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n        \"ignoreMobileResize\" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);\n        if (\"autoRefreshEvents\" in vars) {\n            _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\n            _ignoreResize = (vars.autoRefreshEvents + \"\").indexOf(\"resize\") === -1;\n        }\n    };\n    ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\n        var t = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(target), i = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.indexOf(t), isViewport = _isViewport(t);\n        if (~i) {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.splice(i, isViewport ? 6 : 2);\n        }\n        if (vars) {\n            isViewport ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(t, vars);\n        }\n    };\n    ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {\n        _triggers.forEach(function(t) {\n            return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);\n        });\n    };\n    ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {\n        var bounds = (_isString(element) ? (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;\n        return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;\n    };\n    ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {\n        _isString(element) && (element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element));\n        var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;\n        return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;\n    };\n    ScrollTrigger.killAll = function killAll(allowListeners) {\n        _triggers.slice(0).forEach(function(t) {\n            return t.vars.id !== \"ScrollSmoother\" && t.kill();\n        });\n        if (allowListeners !== true) {\n            var listeners = _listeners.killAll || [];\n            _listeners = {};\n            listeners.forEach(function(f) {\n                return f();\n            });\n        }\n    };\n    return ScrollTrigger;\n}();\nScrollTrigger.version = \"3.12.7\";\nScrollTrigger.saveStyles = function(targets) {\n    return targets ? _toArray(targets).forEach(function(target) {\n        // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]\n        if (target && target.style) {\n            var i = _savedStyles.indexOf(target);\n            i >= 0 && _savedStyles.splice(i, 5);\n            _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _context());\n        }\n    }) : _savedStyles;\n};\nScrollTrigger.revert = function(soft, media) {\n    return _revertAll(!soft, media);\n};\nScrollTrigger.create = function(vars, animation) {\n    return new ScrollTrigger(vars, animation);\n};\nScrollTrigger.refresh = function(safe) {\n    return safe ? _onResize(true) : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\n};\nScrollTrigger.update = function(force) {\n    return ++_Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache && _updateAll(force === true ? 2 : 0);\n};\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\nScrollTrigger.maxScroll = function(element, horizontal) {\n    return _maxScroll(element, horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\nScrollTrigger.getScrollFunc = function(element, horizontal) {\n    return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element), horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\nScrollTrigger.getById = function(id) {\n    return _ids[id];\n};\nScrollTrigger.getAll = function() {\n    return _triggers.filter(function(t) {\n        return t.vars.id !== \"ScrollSmoother\";\n    });\n}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.\nScrollTrigger.isScrolling = function() {\n    return !!_lastScrollTime;\n};\nScrollTrigger.snapDirectional = _snapDirectional;\nScrollTrigger.addEventListener = function(type, callback) {\n    var a = _listeners[type] || (_listeners[type] = []);\n    ~a.indexOf(callback) || a.push(callback);\n};\nScrollTrigger.removeEventListener = function(type, callback) {\n    var a = _listeners[type], i = a && a.indexOf(callback);\n    i >= 0 && a.splice(i, 1);\n};\nScrollTrigger.batch = function(targets, vars) {\n    var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback(type, callback) {\n        var elements = [], triggers = [], delay = gsap.delayedCall(interval, function() {\n            callback(elements, triggers);\n            elements = [];\n            triggers = [];\n        }).pause();\n        return function(self) {\n            elements.length || delay.restart(true);\n            elements.push(self.trigger);\n            triggers.push(self);\n            batchMax <= elements.length && delay.progress(1);\n        };\n    }, p;\n    for(p in vars){\n        varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\n    }\n    if (_isFunction(batchMax)) {\n        batchMax = batchMax();\n        _addListener(ScrollTrigger, \"refresh\", function() {\n            return batchMax = vars.batchMax();\n        });\n    }\n    _toArray(targets).forEach(function(target) {\n        var config = {};\n        for(p in varsCopy){\n            config[p] = varsCopy[p];\n        }\n        config.trigger = target;\n        result.push(ScrollTrigger.create(config));\n    });\n    return result;\n}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).\nvar _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {\n    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);\n    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;\n}, _allowNativePanning = function _allowNativePanning(target, direction) {\n    if (direction === true) {\n        target.style.removeProperty(\"touch-action\");\n    } else {\n        target.style.touchAction = direction === true ? \"auto\" : direction ? \"pan-\" + direction + (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch ? \" pinch-zoom\" : \"\") : \"none\"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.\n    }\n    target === _docEl && _allowNativePanning(_body, direction);\n}, _overflow = {\n    auto: 1,\n    scroll: 1\n}, _nestedScroll = function _nestedScroll(_ref5) {\n    var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;\n    var node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || gsap.core.getCache(node), time = _getTime(), cs;\n    if (!cache._isScrollT || time - cache._isScrollT > 2000) {\n        // cache for 2 seconds to improve performance.\n        while(node && node !== _body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))){\n            node = node.parentNode;\n        }\n        cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);\n        cache._isScrollT = time;\n    }\n    if (cache._isScroll || axis === \"x\") {\n        event.stopPropagation();\n        event._gsapAllow = true;\n    }\n}, // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor\n_inputObserver = function _inputObserver(target, type, inputs, nested) {\n    return _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.create({\n        target: target,\n        capture: true,\n        debounce: false,\n        lockAxis: true,\n        type: type,\n        onWheel: nested = nested && _nestedScroll,\n        onPress: nested,\n        onDrag: nested,\n        onScroll: nested,\n        onEnable: function onEnable() {\n            return inputs && _addListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, false, true);\n        },\n        onDisable: function onDisable() {\n            return _removeListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, true);\n        }\n    });\n}, _inputExp = /(input|label|select|textarea)/i, _inputIsFocused, _captureInputs = function _captureInputs(e) {\n    var isInput = _inputExp.test(e.target.tagName);\n    if (isInput || _inputIsFocused) {\n        e._gsapAllow = true;\n        _inputIsFocused = isInput;\n    }\n}, _getScrollNormalizer = function _getScrollNormalizer(vars) {\n    _isObject(vars) || (vars = {});\n    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;\n    vars.type || (vars.type = \"wheel,touch\");\n    vars.debounce = !!vars.debounce;\n    vars.id = vars.id || \"normalizer\";\n    var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, self, maxY, target = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.target) || _docEl, smoother = gsap.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical), scrollFuncX = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal), scale = 1, initialScale = (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction(momentum) ? function() {\n        return momentum(self);\n    } : function() {\n        return momentum || 2.8;\n    }, lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove() {\n        return skipTouchMove = false;\n    }, scrollClampX = _passThrough, scrollClampY = _passThrough, updateClamps = function updateClamps() {\n        maxY = _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n        scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);\n        normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)));\n        lastRefreshID = _refreshID;\n    }, removeContentOffset = function removeContentOffset() {\n        content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + \"px\";\n        content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + parseFloat(content._gsap.y) + \", 0, 1)\";\n        scrollFuncY.offset = scrollFuncY.cacheID = 0;\n    }, ignoreDrag = function ignoreDrag() {\n        if (skipTouchMove) {\n            requestAnimationFrame(resumeTouchMove);\n            var offset = _round(self.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);\n            if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {\n                scrollFuncY.offset = scroll - scrollFuncY.v;\n                var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);\n                content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n                content._gsap.y = y + \"px\";\n                scrollFuncY.cacheID = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;\n                _updateAll();\n            }\n            return true;\n        }\n        scrollFuncY.offset && removeContentOffset();\n        skipTouchMove = true;\n    }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize = function onResize() {\n        // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.\n        updateClamps();\n        if (tween.isActive() && tween.vars.scrollY > maxY) {\n            scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo(\"scrollY\", maxY);\n        }\n    };\n    content && gsap.set(content, {\n        y: \"+=0\"\n    }); // to ensure there's a cache (element._gsap)\n    vars.ignoreCheck = function(e) {\n        return _fixIOSBug && e.type === \"touchmove\" && ignoreDrag(e) || scale > 1.05 && e.type !== \"touchstart\" || self.isGesturing || e.touches && e.touches.length > 1;\n    };\n    vars.onPress = function() {\n        skipTouchMove = false;\n        var prevScale = scale;\n        scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);\n        tween.pause();\n        prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : \"x\");\n        startScrollX = scrollFuncX();\n        startScrollY = scrollFuncY();\n        updateClamps();\n        lastRefreshID = _refreshID;\n    };\n    vars.onRelease = vars.onGestureStart = function(self, wasDragging) {\n        scrollFuncY.offset && removeContentOffset();\n        if (!wasDragging) {\n            onStopDelayedCall.restart(true);\n        } else {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++; // make sure we're pulling the non-cached value\n            // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),\tdur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)\n            var dur = resolveMomentumDuration(), currentScroll, endScroll;\n            if (normalizeScrollX) {\n                currentScroll = scrollFuncX();\n                endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.\n                dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal));\n                tween.vars.scrollX = scrollClampX(endScroll);\n            }\n            currentScroll = scrollFuncY();\n            endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)\n            dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical));\n            tween.vars.scrollY = scrollClampY(endScroll);\n            tween.invalidate().duration(dur).play(0.01);\n            if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {\n                // iOS bug: it'll show the address bar but NOT fire the window \"resize\" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.\n                gsap.to({}, {\n                    onUpdate: onResize,\n                    duration: dur\n                });\n            }\n        }\n        onRelease && onRelease(self);\n    };\n    vars.onWheel = function() {\n        tween._ts && tween.pause();\n        if (_getTime() - wheelRefresh > 1000) {\n            // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.\n            lastRefreshID = 0;\n            wheelRefresh = _getTime();\n        }\n    };\n    vars.onChange = function(self, dx, dy, xArray, yArray) {\n        _refreshID !== lastRefreshID && updateClamps();\n        dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.\n        if (dy) {\n            scrollFuncY.offset && removeContentOffset();\n            var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);\n            isTouch && y !== yClamped && (startScrollY += yClamped - y);\n            scrollFuncY(yClamped);\n        }\n        (dy || dx) && _updateAll();\n    };\n    vars.onEnable = function() {\n        _allowNativePanning(target, normalizeScrollX ? false : \"x\");\n        ScrollTrigger.addEventListener(\"refresh\", onResize);\n        _addListener(_win, \"resize\", onResize);\n        if (scrollFuncY.smooth) {\n            scrollFuncY.target.style.scrollBehavior = \"auto\";\n            scrollFuncY.smooth = scrollFuncX.smooth = false;\n        }\n        inputObserver.enable();\n    };\n    vars.onDisable = function() {\n        _allowNativePanning(target, true);\n        _removeListener(_win, \"resize\", onResize);\n        ScrollTrigger.removeEventListener(\"refresh\", onResize);\n        inputObserver.kill();\n    };\n    vars.lockAxis = vars.lockAxis !== false;\n    self = new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n    self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.\n    _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.\n    _fixIOSBug && gsap.ticker.add(_passThrough); // prevent the ticker from sleeping\n    onStopDelayedCall = self._dc;\n    tween = gsap.to(self, {\n        ease: \"power4\",\n        paused: true,\n        inherit: false,\n        scrollX: normalizeScrollX ? \"+=0.1\" : \"+=0\",\n        scrollY: \"+=0.1\",\n        modifiers: {\n            scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {\n                return tween.pause();\n            })\n        },\n        onUpdate: _updateAll,\n        onComplete: onStopDelayedCall.vars.onComplete\n    }); // we need the modifier to sense if the scroll position is altered outside of the momentum tween (like with a scrollTo tween) so we can pause() it to prevent conflicts.\n    return self;\n};\nScrollTrigger.sort = function(func) {\n    if (_isFunction(func)) {\n        return _triggers.sort(func);\n    }\n    var scroll = _win.pageYOffset || 0;\n    ScrollTrigger.getAll().forEach(function(t) {\n        return t._sortY = t.trigger ? scroll + t.trigger.getBoundingClientRect().top : t.start + _win.innerHeight;\n    });\n    return _triggers.sort(func || function(a, b) {\n        return (a.vars.refreshPriority || 0) * -1e6 + (a.vars.containerAnimation ? 1e6 : a._sortY) - ((b.vars.containerAnimation ? 1e6 : b._sortY) + (b.vars.refreshPriority || 0) * -1e6);\n    }); // anything with a containerAnimation should refresh last.\n};\nScrollTrigger.observe = function(vars) {\n    return new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n};\nScrollTrigger.normalizeScroll = function(vars) {\n    if (typeof vars === \"undefined\") {\n        return _normalizer;\n    }\n    if (vars === true && _normalizer) {\n        return _normalizer.enable();\n    }\n    if (vars === false) {\n        _normalizer && _normalizer.kill();\n        _normalizer = vars;\n        return;\n    }\n    var normalizer = vars instanceof _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer ? vars : _getScrollNormalizer(vars);\n    _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();\n    _isViewport(normalizer.target) && (_normalizer = normalizer);\n    return normalizer;\n};\nScrollTrigger.core = {\n    // smaller file size way to leverage in ScrollSmoother and Observer\n    _getVelocityProp: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getVelocityProp,\n    _inputObserver: _inputObserver,\n    _scrollers: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers,\n    _proxies: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies,\n    bridge: {\n        // when normalizeScroll sets the scroll position (ss = setScroll)\n        ss: function ss() {\n            _lastScrollTime || _dispatch(\"scrollStart\");\n            _lastScrollTime = _getTime();\n        },\n        // a way to get the _refreshing value in Observer\n        ref: function ref() {\n            return _refreshing;\n        }\n    }\n};\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nc2FwL1Njcm9sbFRyaWdnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUEsR0FFQSxrQkFBa0IsR0FDa0k7QUFFcEosSUFBSVMsTUFDQUMsY0FDQUMsTUFDQUMsTUFDQUMsUUFDQUMsT0FDQUMsT0FDQUMsY0FDQUMsVUFDQUMsUUFDQUMsUUFDQUMsZUFDQUMsYUFDQUMsZ0JBQ0FDLGdCQUNBQyxJQUNBQyxZQUNBQyxhQUNBQyxjQUNBQyxPQUNBQyxxQkFDQUMsZUFDQUMsYUFDQUMscUJBQ0FDLG1CQUNBQyxrQkFDQUMsWUFDQUMsVUFDQUMsb0JBQ0FDLFdBQ0FDLFFBQ0FDLGFBQ0FDLGNBQ0FDLGlCQUNBLHVRQUF1UTtBQUMzUUMsV0FBVyxHQUNQQyxXQUFXQyxLQUFLQyxHQUFHLEVBQ25CQyxTQUFTSCxZQUNUSSxrQkFBa0IsR0FDbEJDLFdBQVcsR0FDWEMsY0FBYyxTQUFTQSxZQUFZQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUN0RCxJQUFJQyxRQUFRQyxVQUFVSixVQUFXQSxDQUFBQSxNQUFNSyxNQUFNLENBQUMsR0FBRyxPQUFPLFlBQVlMLE1BQU1NLE9BQU8sQ0FBQyxTQUFTLENBQUM7SUFDNUZKLElBQUksQ0FBQyxNQUFNRCxPQUFPLFFBQVEsR0FBR0U7SUFDN0IsT0FBT0EsUUFBUUgsTUFBTUssTUFBTSxDQUFDLEdBQUdMLE1BQU1PLE1BQU0sR0FBRyxLQUFLUDtBQUNyRCxHQUNJUSxhQUFhLFNBQVNBLFdBQVdSLEtBQUssRUFBRUcsS0FBSztJQUMvQyxPQUFPQSxTQUFVLEVBQUNDLFVBQVVKLFVBQVVBLE1BQU1LLE1BQU0sQ0FBQyxHQUFHLE9BQU8sUUFBTyxJQUFLLFdBQVdMLFFBQVEsTUFBTUE7QUFDcEcsR0FDSVMsYUFBYSxTQUFTQTtJQUN4QixPQUFPWCxZQUFZWSxzQkFBc0JEO0FBQzNDLEdBQ0ksdU5BQXVOO0FBQzNORSxzQkFBc0IsU0FBU0E7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QUN1TTtBQUNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL1Njcm9sbFRyaWdnZXIuanM/ZTExZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFNjcm9sbFRyaWdnZXIgMy4xMi43XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgT2JzZXJ2ZXIsIF9nZXRUYXJnZXQsIF92ZXJ0aWNhbCwgX2hvcml6b250YWwsIF9zY3JvbGxlcnMsIF9wcm94aWVzLCBfZ2V0U2Nyb2xsRnVuYywgX2dldFByb3h5UHJvcCwgX2dldFZlbG9jaXR5UHJvcCB9IGZyb20gXCIuL09ic2VydmVyLmpzXCI7XG5cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsLFxuICAgIF9ib2R5LFxuICAgIF9yb290LFxuICAgIF9yZXNpemVEZWxheSxcbiAgICBfdG9BcnJheSxcbiAgICBfY2xhbXAsXG4gICAgX3RpbWUyLFxuICAgIF9zeW5jSW50ZXJ2YWwsXG4gICAgX3JlZnJlc2hpbmcsXG4gICAgX3BvaW50ZXJJc0Rvd24sXG4gICAgX3RyYW5zZm9ybVByb3AsXG4gICAgX2ksXG4gICAgX3ByZXZXaWR0aCxcbiAgICBfcHJldkhlaWdodCxcbiAgICBfYXV0b1JlZnJlc2gsXG4gICAgX3NvcnQsXG4gICAgX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICBfaWdub3JlUmVzaXplLFxuICAgIF9ub3JtYWxpemVyLFxuICAgIF9pZ25vcmVNb2JpbGVSZXNpemUsXG4gICAgX2Jhc2VTY3JlZW5IZWlnaHQsXG4gICAgX2Jhc2VTY3JlZW5XaWR0aCxcbiAgICBfZml4SU9TQnVnLFxuICAgIF9jb250ZXh0LFxuICAgIF9zY3JvbGxSZXN0b3JhdGlvbixcbiAgICBfZGl2MTAwdmgsXG4gICAgXzEwMHZoLFxuICAgIF9pc1JldmVydGVkLFxuICAgIF9jbGFtcGluZ01heCxcbiAgICBfbGltaXRDYWxsYmFja3MsXG4gICAgLy8gaWYgdHJ1ZSwgd2UnbGwgb25seSB0cmlnZ2VyIGNhbGxiYWNrcyBpZiB0aGUgYWN0aXZlIHN0YXRlIHRvZ2dsZXMsIHNvIGlmIHlvdSBzY3JvbGwgaW1tZWRpYXRlbHkgcGFzdCBib3RoIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBvZiBhIFNjcm9sbFRyaWdnZXIgKHRodXMgaW5hY3RpdmUgdG8gaW5hY3RpdmUpLCBuZWl0aGVyIGl0cyBvbkVudGVyIG5vciBvbkxlYXZlIHdpbGwgYmUgY2FsbGVkLiBUaGlzIGlzIHVzZWZ1bCBkdXJpbmcgc3RhcnR1cC5cbl9zdGFydHVwID0gMSxcbiAgICBfZ2V0VGltZSA9IERhdGUubm93LFxuICAgIF90aW1lMSA9IF9nZXRUaW1lKCksXG4gICAgX2xhc3RTY3JvbGxUaW1lID0gMCxcbiAgICBfZW5hYmxlZCA9IDAsXG4gICAgX3BhcnNlQ2xhbXAgPSBmdW5jdGlvbiBfcGFyc2VDbGFtcCh2YWx1ZSwgdHlwZSwgc2VsZikge1xuICB2YXIgY2xhbXAgPSBfaXNTdHJpbmcodmFsdWUpICYmICh2YWx1ZS5zdWJzdHIoMCwgNikgPT09IFwiY2xhbXAoXCIgfHwgdmFsdWUuaW5kZXhPZihcIm1heFwiKSA+IC0xKTtcbiAgc2VsZltcIl9cIiArIHR5cGUgKyBcIkNsYW1wXCJdID0gY2xhbXA7XG4gIHJldHVybiBjbGFtcCA/IHZhbHVlLnN1YnN0cig2LCB2YWx1ZS5sZW5ndGggLSA3KSA6IHZhbHVlO1xufSxcbiAgICBfa2VlcENsYW1wID0gZnVuY3Rpb24gX2tlZXBDbGFtcCh2YWx1ZSwgY2xhbXApIHtcbiAgcmV0dXJuIGNsYW1wICYmICghX2lzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZS5zdWJzdHIoMCwgNikgIT09IFwiY2xhbXAoXCIpID8gXCJjbGFtcChcIiArIHZhbHVlICsgXCIpXCIgOiB2YWx1ZTtcbn0sXG4gICAgX3JhZkJ1Z0ZpeCA9IGZ1bmN0aW9uIF9yYWZCdWdGaXgoKSB7XG4gIHJldHVybiBfZW5hYmxlZCAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3JhZkJ1Z0ZpeCk7XG59LFxuICAgIC8vIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCksIHNjcmVlbiByZXBhaW50cyB3ZXJlbid0IGNvbnNpc3RlbnQgdW5sZXNzIHdlIGhhZCBTT01FVEhJTkcgcXVldWVkIHVwIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpISBTbyB0aGlzIGp1c3QgY3JlYXRlcyBhIHN1cGVyIHNpbXBsZSBsb29wIHRvIGtlZXAgaXQgYWxpdmUgYW5kIHNtb290aCBvdXQgcmVwYWludHMuXG5fcG9pbnRlckRvd25IYW5kbGVyID0gZnVuY3Rpb24gX3BvaW50ZXJEb3duSGFuZGxlcigpIHtcbiAgcmV0dXJuIF9wb2ludGVySXNEb3duID0gMTtcbn0sXG4gICAgX3BvaW50ZXJVcEhhbmRsZXIgPSBmdW5jdGlvbiBfcG9pbnRlclVwSGFuZGxlcigpIHtcbiAgcmV0dXJuIF9wb2ludGVySXNEb3duID0gMDtcbn0sXG4gICAgX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24gX3Bhc3NUaHJvdWdoKHYpIHtcbiAgcmV0dXJuIHY7XG59LFxuICAgIF9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMCkgLyAxMDAwMDAgfHwgMDtcbn0sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfaXNWaWV3cG9ydCA9IGZ1bmN0aW9uIF9pc1ZpZXdwb3J0KGUpIHtcbiAgcmV0dXJuICEhfl9yb290LmluZGV4T2YoZSk7XG59LFxuICAgIF9nZXRWaWV3cG9ydERpbWVuc2lvbiA9IGZ1bmN0aW9uIF9nZXRWaWV3cG9ydERpbWVuc2lvbihkaW1lbnNpb25Qcm9wZXJ0eSkge1xuICByZXR1cm4gKGRpbWVuc2lvblByb3BlcnR5ID09PSBcIkhlaWdodFwiID8gXzEwMHZoIDogX3dpbltcImlubmVyXCIgKyBkaW1lbnNpb25Qcm9wZXJ0eV0pIHx8IF9kb2NFbFtcImNsaWVudFwiICsgZGltZW5zaW9uUHJvcGVydHldIHx8IF9ib2R5W1wiY2xpZW50XCIgKyBkaW1lbnNpb25Qcm9wZXJ0eV07XG59LFxuICAgIF9nZXRCb3VuZHNGdW5jID0gZnVuY3Rpb24gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkge1xuICByZXR1cm4gX2dldFByb3h5UHJvcChlbGVtZW50LCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiKSB8fCAoX2lzVmlld3BvcnQoZWxlbWVudCkgPyBmdW5jdGlvbiAoKSB7XG4gICAgX3dpbk9mZnNldHMud2lkdGggPSBfd2luLmlubmVyV2lkdGg7XG4gICAgX3dpbk9mZnNldHMuaGVpZ2h0ID0gXzEwMHZoO1xuICAgIHJldHVybiBfd2luT2Zmc2V0cztcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldEJvdW5kcyhlbGVtZW50KTtcbiAgfSk7XG59LFxuICAgIF9nZXRTaXplRnVuYyA9IGZ1bmN0aW9uIF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgX3JlZikge1xuICB2YXIgZCA9IF9yZWYuZCxcbiAgICAgIGQyID0gX3JlZi5kMixcbiAgICAgIGEgPSBfcmVmLmE7XG4gIHJldHVybiAoYSA9IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpKSA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYSgpW2RdO1xuICB9IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoaXNWaWV3cG9ydCA/IF9nZXRWaWV3cG9ydERpbWVuc2lvbihkMikgOiBzY3JvbGxlcltcImNsaWVudFwiICsgZDJdKSB8fCAwO1xuICB9O1xufSxcbiAgICBfZ2V0T2Zmc2V0c0Z1bmMgPSBmdW5jdGlvbiBfZ2V0T2Zmc2V0c0Z1bmMoZWxlbWVudCwgaXNWaWV3cG9ydCkge1xuICByZXR1cm4gIWlzVmlld3BvcnQgfHwgfl9wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgPyBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3dpbk9mZnNldHM7XG4gIH07XG59LFxuICAgIF9tYXhTY3JvbGwgPSBmdW5jdGlvbiBfbWF4U2Nyb2xsKGVsZW1lbnQsIF9yZWYyKSB7XG4gIHZhciBzID0gX3JlZjIucyxcbiAgICAgIGQyID0gX3JlZjIuZDIsXG4gICAgICBkID0gX3JlZjIuZCxcbiAgICAgIGEgPSBfcmVmMi5hO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgKHMgPSBcInNjcm9sbFwiICsgZDIpICYmIChhID0gX2dldFByb3h5UHJvcChlbGVtZW50LCBzKSkgPyBhKCkgLSBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSgpW2RdIDogX2lzVmlld3BvcnQoZWxlbWVudCkgPyAoX2RvY0VsW3NdIHx8IF9ib2R5W3NdKSAtIF9nZXRWaWV3cG9ydERpbWVuc2lvbihkMikgOiBlbGVtZW50W3NdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdKTtcbn0sXG4gICAgX2l0ZXJhdGVBdXRvUmVmcmVzaCA9IGZ1bmN0aW9uIF9pdGVyYXRlQXV0b1JlZnJlc2goZnVuYywgZXZlbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX2F1dG9SZWZyZXNoLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgKCFldmVudHMgfHwgfmV2ZW50cy5pbmRleE9mKF9hdXRvUmVmcmVzaFtpICsgMV0pKSAmJiBmdW5jKF9hdXRvUmVmcmVzaFtpXSwgX2F1dG9SZWZyZXNoW2kgKyAxXSwgX2F1dG9SZWZyZXNoW2kgKyAyXSk7XG4gIH1cbn0sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzT2JqZWN0ID0gZnVuY3Rpb24gX2lzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59LFxuICAgIF9lbmRBbmltYXRpb24gPSBmdW5jdGlvbiBfZW5kQW5pbWF0aW9uKGFuaW1hdGlvbiwgcmV2ZXJzZWQsIHBhdXNlKSB7XG4gIHJldHVybiBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnByb2dyZXNzKHJldmVyc2VkID8gMCA6IDEpICYmIHBhdXNlICYmIGFuaW1hdGlvbi5wYXVzZSgpO1xufSxcbiAgICBfY2FsbGJhY2sgPSBmdW5jdGlvbiBfY2FsbGJhY2soc2VsZiwgZnVuYykge1xuICBpZiAoc2VsZi5lbmFibGVkKSB7XG4gICAgdmFyIHJlc3VsdCA9IHNlbGYuX2N0eCA/IHNlbGYuX2N0eC5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmMoc2VsZik7XG4gICAgfSkgOiBmdW5jKHNlbGYpO1xuICAgIHJlc3VsdCAmJiByZXN1bHQudG90YWxUaW1lICYmIChzZWxmLmNhbGxiYWNrQW5pbWF0aW9uID0gcmVzdWx0KTtcbiAgfVxufSxcbiAgICBfYWJzID0gTWF0aC5hYnMsXG4gICAgX2xlZnQgPSBcImxlZnRcIixcbiAgICBfdG9wID0gXCJ0b3BcIixcbiAgICBfcmlnaHQgPSBcInJpZ2h0XCIsXG4gICAgX2JvdHRvbSA9IFwiYm90dG9tXCIsXG4gICAgX3dpZHRoID0gXCJ3aWR0aFwiLFxuICAgIF9oZWlnaHQgPSBcImhlaWdodFwiLFxuICAgIF9SaWdodCA9IFwiUmlnaHRcIixcbiAgICBfTGVmdCA9IFwiTGVmdFwiLFxuICAgIF9Ub3AgPSBcIlRvcFwiLFxuICAgIF9Cb3R0b20gPSBcIkJvdHRvbVwiLFxuICAgIF9wYWRkaW5nID0gXCJwYWRkaW5nXCIsXG4gICAgX21hcmdpbiA9IFwibWFyZ2luXCIsXG4gICAgX1dpZHRoID0gXCJXaWR0aFwiLFxuICAgIF9IZWlnaHQgPSBcIkhlaWdodFwiLFxuICAgIF9weCA9IFwicHhcIixcbiAgICBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0sXG4gICAgX21ha2VQb3NpdGlvbmFibGUgPSBmdW5jdGlvbiBfbWFrZVBvc2l0aW9uYWJsZShlbGVtZW50KSB7XG4gIC8vIGlmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIHBvc2l0aW9uOiBhYnNvbHV0ZSBvciBmaXhlZCwgbGVhdmUgdGhhdCwgb3RoZXJ3aXNlIG1ha2UgaXQgcG9zaXRpb246IHJlbGF0aXZlXG4gIHZhciBwb3NpdGlvbiA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uO1xuXG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBwb3NpdGlvbiA6IFwicmVsYXRpdmVcIjtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfZ2V0Qm91bmRzID0gZnVuY3Rpb24gX2dldEJvdW5kcyhlbGVtZW50LCB3aXRob3V0VHJhbnNmb3Jtcykge1xuICB2YXIgdHdlZW4gPSB3aXRob3V0VHJhbnNmb3JtcyAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gIT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIgJiYgZ3NhcC50byhlbGVtZW50LCB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHhQZXJjZW50OiAwLFxuICAgIHlQZXJjZW50OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHJvdGF0aW9uWDogMCxcbiAgICByb3RhdGlvblk6IDAsXG4gICAgc2NhbGU6IDEsXG4gICAgc2tld1g6IDAsXG4gICAgc2tld1k6IDBcbiAgfSkucHJvZ3Jlc3MoMSksXG4gICAgICBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB0d2VlbiAmJiB0d2Vlbi5wcm9ncmVzcygwKS5raWxsKCk7XG4gIHJldHVybiBib3VuZHM7XG59LFxuICAgIF9nZXRTaXplID0gZnVuY3Rpb24gX2dldFNpemUoZWxlbWVudCwgX3JlZjMpIHtcbiAgdmFyIGQyID0gX3JlZjMuZDI7XG4gIHJldHVybiBlbGVtZW50W1wib2Zmc2V0XCIgKyBkMl0gfHwgZWxlbWVudFtcImNsaWVudFwiICsgZDJdIHx8IDA7XG59LFxuICAgIF9nZXRMYWJlbFJhdGlvQXJyYXkgPSBmdW5jdGlvbiBfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSB7XG4gIHZhciBhID0gW10sXG4gICAgICBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBkdXJhdGlvbiA9IHRpbWVsaW5lLmR1cmF0aW9uKCksXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICBhLnB1c2gobGFiZWxzW3BdIC8gZHVyYXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59LFxuICAgIF9nZXRDbG9zZXN0TGFiZWwgPSBmdW5jdGlvbiBfZ2V0Q2xvc2VzdExhYmVsKGFuaW1hdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdzYXAudXRpbHMuc25hcChfZ2V0TGFiZWxSYXRpb0FycmF5KGFuaW1hdGlvbiksIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgX3NuYXBEaXJlY3Rpb25hbCA9IGZ1bmN0aW9uIF9zbmFwRGlyZWN0aW9uYWwoc25hcEluY3JlbWVudE9yQXJyYXkpIHtcbiAgdmFyIHNuYXAgPSBnc2FwLnV0aWxzLnNuYXAoc25hcEluY3JlbWVudE9yQXJyYXkpLFxuICAgICAgYSA9IEFycmF5LmlzQXJyYXkoc25hcEluY3JlbWVudE9yQXJyYXkpICYmIHNuYXBJbmNyZW1lbnRPckFycmF5LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICByZXR1cm4gYSA/IGZ1bmN0aW9uICh2YWx1ZSwgZGlyZWN0aW9uLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDFlLTM7XG4gICAgfVxuXG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIHNuYXAodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICB2YWx1ZSAtPSB0aHJlc2hvbGQ7IC8vIHRvIGF2b2lkIHJvdW5kaW5nIGVycm9ycy4gSWYgd2UncmUgdG9vIHN0cmljdCwgaXQgbWlnaHQgc25hcCBmb3J3YXJkLCB0aGVuIGltbWVkaWF0ZWx5IGFnYWluLCBhbmQgYWdhaW4uXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldID49IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGFbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFbaSAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gYS5sZW5ndGg7XG4gICAgICB2YWx1ZSArPSB0aHJlc2hvbGQ7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGFbaV0gPD0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhWzBdO1xuICB9IDogZnVuY3Rpb24gKHZhbHVlLCBkaXJlY3Rpb24sIHRocmVzaG9sZCkge1xuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMWUtMztcbiAgICB9XG5cbiAgICB2YXIgc25hcHBlZCA9IHNuYXAodmFsdWUpO1xuICAgIHJldHVybiAhZGlyZWN0aW9uIHx8IE1hdGguYWJzKHNuYXBwZWQgLSB2YWx1ZSkgPCB0aHJlc2hvbGQgfHwgc25hcHBlZCAtIHZhbHVlIDwgMCA9PT0gZGlyZWN0aW9uIDwgMCA/IHNuYXBwZWQgOiBzbmFwKGRpcmVjdGlvbiA8IDAgPyB2YWx1ZSAtIHNuYXBJbmNyZW1lbnRPckFycmF5IDogdmFsdWUgKyBzbmFwSW5jcmVtZW50T3JBcnJheSk7XG4gIH07XG59LFxuICAgIF9nZXRMYWJlbEF0RGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsQXREaXJlY3Rpb24odGltZWxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgc3QpIHtcbiAgICByZXR1cm4gX3NuYXBEaXJlY3Rpb25hbChfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSkodmFsdWUsIHN0LmRpcmVjdGlvbik7XG4gIH07XG59LFxuICAgIF9tdWx0aUxpc3RlbmVyID0gZnVuY3Rpb24gX211bHRpTGlzdGVuZXIoZnVuYywgZWxlbWVudCwgdHlwZXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0eXBlcy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBmdW5jKGVsZW1lbnQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgfSk7XG59LFxuICAgIF9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBub25QYXNzaXZlLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywge1xuICAgIHBhc3NpdmU6ICFub25QYXNzaXZlLFxuICAgIGNhcHR1cmU6ICEhY2FwdHVyZVxuICB9KTtcbn0sXG4gICAgX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCAhIWNhcHR1cmUpO1xufSxcbiAgICBfd2hlZWxMaXN0ZW5lciA9IGZ1bmN0aW9uIF93aGVlbExpc3RlbmVyKGZ1bmMsIGVsLCBzY3JvbGxGdW5jKSB7XG4gIHNjcm9sbEZ1bmMgPSBzY3JvbGxGdW5jICYmIHNjcm9sbEZ1bmMud2hlZWxIYW5kbGVyO1xuXG4gIGlmIChzY3JvbGxGdW5jKSB7XG4gICAgZnVuYyhlbCwgXCJ3aGVlbFwiLCBzY3JvbGxGdW5jKTtcbiAgICBmdW5jKGVsLCBcInRvdWNobW92ZVwiLCBzY3JvbGxGdW5jKTtcbiAgfVxufSxcbiAgICBfbWFya2VyRGVmYXVsdHMgPSB7XG4gIHN0YXJ0Q29sb3I6IFwiZ3JlZW5cIixcbiAgZW5kQ29sb3I6IFwicmVkXCIsXG4gIGluZGVudDogMCxcbiAgZm9udFNpemU6IFwiMTZweFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiXG59LFxuICAgIF9kZWZhdWx0cyA9IHtcbiAgdG9nZ2xlQWN0aW9uczogXCJwbGF5XCIsXG4gIGFudGljaXBhdGVQaW46IDBcbn0sXG4gICAgX2tleXdvcmRzID0ge1xuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIGNlbnRlcjogMC41LFxuICBib3R0b206IDEsXG4gIHJpZ2h0OiAxXG59LFxuICAgIF9vZmZzZXRUb1B4ID0gZnVuY3Rpb24gX29mZnNldFRvUHgodmFsdWUsIHNpemUpIHtcbiAgaWYgKF9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgZXFJbmRleCA9IHZhbHVlLmluZGV4T2YoXCI9XCIpLFxuICAgICAgICByZWxhdGl2ZSA9IH5lcUluZGV4ID8gKyh2YWx1ZS5jaGFyQXQoZXFJbmRleCAtIDEpICsgMSkgKiBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cihlcUluZGV4ICsgMSkpIDogMDtcblxuICAgIGlmICh+ZXFJbmRleCkge1xuICAgICAgdmFsdWUuaW5kZXhPZihcIiVcIikgPiBlcUluZGV4ICYmIChyZWxhdGl2ZSAqPSBzaXplIC8gMTAwKTtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIGVxSW5kZXggLSAxKTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHJlbGF0aXZlICsgKHZhbHVlIGluIF9rZXl3b3JkcyA/IF9rZXl3b3Jkc1t2YWx1ZV0gKiBzaXplIDogfnZhbHVlLmluZGV4T2YoXCIlXCIpID8gcGFyc2VGbG9hdCh2YWx1ZSkgKiBzaXplIC8gMTAwIDogcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59LFxuICAgIF9jcmVhdGVNYXJrZXIgPSBmdW5jdGlvbiBfY3JlYXRlTWFya2VyKHR5cGUsIG5hbWUsIGNvbnRhaW5lciwgZGlyZWN0aW9uLCBfcmVmNCwgb2Zmc2V0LCBtYXRjaFdpZHRoRWwsIGNvbnRhaW5lckFuaW1hdGlvbikge1xuICB2YXIgc3RhcnRDb2xvciA9IF9yZWY0LnN0YXJ0Q29sb3IsXG4gICAgICBlbmRDb2xvciA9IF9yZWY0LmVuZENvbG9yLFxuICAgICAgZm9udFNpemUgPSBfcmVmNC5mb250U2l6ZSxcbiAgICAgIGluZGVudCA9IF9yZWY0LmluZGVudCxcbiAgICAgIGZvbnRXZWlnaHQgPSBfcmVmNC5mb250V2VpZ2h0O1xuXG4gIHZhciBlID0gX2RvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgdXNlRml4ZWRQb3NpdGlvbiA9IF9pc1ZpZXdwb3J0KGNvbnRhaW5lcikgfHwgX2dldFByb3h5UHJvcChjb250YWluZXIsIFwicGluVHlwZVwiKSA9PT0gXCJmaXhlZFwiLFxuICAgICAgaXNTY3JvbGxlciA9IHR5cGUuaW5kZXhPZihcInNjcm9sbGVyXCIpICE9PSAtMSxcbiAgICAgIHBhcmVudCA9IHVzZUZpeGVkUG9zaXRpb24gPyBfYm9keSA6IGNvbnRhaW5lcixcbiAgICAgIGlzU3RhcnQgPSB0eXBlLmluZGV4T2YoXCJzdGFydFwiKSAhPT0gLTEsXG4gICAgICBjb2xvciA9IGlzU3RhcnQgPyBzdGFydENvbG9yIDogZW5kQ29sb3IsXG4gICAgICBjc3MgPSBcImJvcmRlci1jb2xvcjpcIiArIGNvbG9yICsgXCI7Zm9udC1zaXplOlwiICsgZm9udFNpemUgKyBcIjtjb2xvcjpcIiArIGNvbG9yICsgXCI7Zm9udC13ZWlnaHQ6XCIgKyBmb250V2VpZ2h0ICsgXCI7cG9pbnRlci1ldmVudHM6bm9uZTt3aGl0ZS1zcGFjZTpub3dyYXA7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZixBcmlhbDt6LWluZGV4OjEwMDA7cGFkZGluZzo0cHggOHB4O2JvcmRlci13aWR0aDowO2JvcmRlci1zdHlsZTpzb2xpZDtcIjtcblxuICBjc3MgKz0gXCJwb3NpdGlvbjpcIiArICgoaXNTY3JvbGxlciB8fCBjb250YWluZXJBbmltYXRpb24pICYmIHVzZUZpeGVkUG9zaXRpb24gPyBcImZpeGVkO1wiIDogXCJhYnNvbHV0ZTtcIik7XG4gIChpc1Njcm9sbGVyIHx8IGNvbnRhaW5lckFuaW1hdGlvbiB8fCAhdXNlRml4ZWRQb3NpdGlvbikgJiYgKGNzcyArPSAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyBfcmlnaHQgOiBfYm90dG9tKSArIFwiOlwiICsgKG9mZnNldCArIHBhcnNlRmxvYXQoaW5kZW50KSkgKyBcInB4O1wiKTtcbiAgbWF0Y2hXaWR0aEVsICYmIChjc3MgKz0gXCJib3gtc2l6aW5nOmJvcmRlci1ib3g7dGV4dC1hbGlnbjpsZWZ0O3dpZHRoOlwiICsgbWF0Y2hXaWR0aEVsLm9mZnNldFdpZHRoICsgXCJweDtcIik7XG4gIGUuX2lzU3RhcnQgPSBpc1N0YXJ0O1xuICBlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiZ3NhcC1tYXJrZXItXCIgKyB0eXBlICsgKG5hbWUgPyBcIiBtYXJrZXItXCIgKyBuYW1lIDogXCJcIikpO1xuICBlLnN0eWxlLmNzc1RleHQgPSBjc3M7XG4gIGUuaW5uZXJUZXh0ID0gbmFtZSB8fCBuYW1lID09PSAwID8gdHlwZSArIFwiLVwiICsgbmFtZSA6IHR5cGU7XG4gIHBhcmVudC5jaGlsZHJlblswXSA/IHBhcmVudC5pbnNlcnRCZWZvcmUoZSwgcGFyZW50LmNoaWxkcmVuWzBdKSA6IHBhcmVudC5hcHBlbmRDaGlsZChlKTtcbiAgZS5fb2Zmc2V0ID0gZVtcIm9mZnNldFwiICsgZGlyZWN0aW9uLm9wLmQyXTtcblxuICBfcG9zaXRpb25NYXJrZXIoZSwgMCwgZGlyZWN0aW9uLCBpc1N0YXJ0KTtcblxuICByZXR1cm4gZTtcbn0sXG4gICAgX3Bvc2l0aW9uTWFya2VyID0gZnVuY3Rpb24gX3Bvc2l0aW9uTWFya2VyKG1hcmtlciwgc3RhcnQsIGRpcmVjdGlvbiwgZmxpcHBlZCkge1xuICB2YXIgdmFycyA9IHtcbiAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgfSxcbiAgICAgIHNpZGUgPSBkaXJlY3Rpb25bZmxpcHBlZCA/IFwib3MyXCIgOiBcInAyXCJdLFxuICAgICAgb3Bwb3NpdGVTaWRlID0gZGlyZWN0aW9uW2ZsaXBwZWQgPyBcInAyXCIgOiBcIm9zMlwiXTtcbiAgbWFya2VyLl9pc0ZsaXBwZWQgPSBmbGlwcGVkO1xuICB2YXJzW2RpcmVjdGlvbi5hICsgXCJQZXJjZW50XCJdID0gZmxpcHBlZCA/IC0xMDAgOiAwO1xuICB2YXJzW2RpcmVjdGlvbi5hXSA9IGZsaXBwZWQgPyBcIjFweFwiIDogMDtcbiAgdmFyc1tcImJvcmRlclwiICsgc2lkZSArIF9XaWR0aF0gPSAxO1xuICB2YXJzW1wiYm9yZGVyXCIgKyBvcHBvc2l0ZVNpZGUgKyBfV2lkdGhdID0gMDtcbiAgdmFyc1tkaXJlY3Rpb24ucF0gPSBzdGFydCArIFwicHhcIjtcbiAgZ3NhcC5zZXQobWFya2VyLCB2YXJzKTtcbn0sXG4gICAgX3RyaWdnZXJzID0gW10sXG4gICAgX2lkcyA9IHt9LFxuICAgIF9yYWZJRCxcbiAgICBfc3luYyA9IGZ1bmN0aW9uIF9zeW5jKCkge1xuICByZXR1cm4gX2dldFRpbWUoKSAtIF9sYXN0U2Nyb2xsVGltZSA+IDM0ICYmIChfcmFmSUQgfHwgKF9yYWZJRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfdXBkYXRlQWxsKSkpO1xufSxcbiAgICBfb25TY3JvbGwgPSBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gIC8vIHByZXZpb3VzbHksIHdlIHRyaWVkIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIGJ5IGJhdGNoaW5nL2RlZmVycmluZyB0byB0aGUgbmV4dCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSwgYnV0IGRpc2NvdmVyZWQgdGhhdCBTYWZhcmkgaGFzIGEgZmV3IGJ1Z3MgdGhhdCBtYWtlIHRoaXMgdW53b3JrYWJsZSAoZXNwZWNpYWxseSBvbiBpT1MpLiBTZWUgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vMTZjNDM1YjEyZWYwOWMzODEyNTIwNDgxOGU3YjQ1ZmM/ZWRpdG9ycz0wMDEwIGFuZCBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9Kak94WXBRLzNkZDY1Y2NlYzVhNjBmMWQ4NjJjMzU1ZDg0ZDE0NTYyP2VkaXRvcnM9MDAxMCBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vRXhiclBOYS8wODdjZWYxOTdkYzM1NDQ1YTA5NTFlODkzNWM0MTUwMz9lZGl0b3JzPTAwMTBcbiAgaWYgKCFfbm9ybWFsaXplciB8fCAhX25vcm1hbGl6ZXIuaXNQcmVzc2VkIHx8IF9ub3JtYWxpemVyLnN0YXJ0WCA+IF9ib2R5LmNsaWVudFdpZHRoKSB7XG4gICAgLy8gaWYgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIHNjcm9sbGJhciwgYWxsb3cgaXQuXG4gICAgX3Njcm9sbGVycy5jYWNoZSsrO1xuXG4gICAgaWYgKF9ub3JtYWxpemVyKSB7XG4gICAgICBfcmFmSUQgfHwgKF9yYWZJRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfdXBkYXRlQWxsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF91cGRhdGVBbGwoKTsgLy8gU2FmYXJpIGluIHBhcnRpY3VsYXIgKG9uIGRlc2t0b3ApIE5FRURTIHRoZSBpbW1lZGlhdGUgdXBkYXRlIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgd2hlcmVhcyBpT1Mgc2VlbXMgdG8gYmVuZWZpdCBmcm9tIHdhaXRpbmcgZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB0aWNrLCBhdCBsZWFzdCB3aGVuIG5vcm1hbGl6aW5nLiBTZWUgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vcUJZb3pxTz9lZGl0b3JzPTAxMTBcblxuICAgIH1cblxuICAgIF9sYXN0U2Nyb2xsVGltZSB8fCBfZGlzcGF0Y2goXCJzY3JvbGxTdGFydFwiKTtcbiAgICBfbGFzdFNjcm9sbFRpbWUgPSBfZ2V0VGltZSgpO1xuICB9XG59LFxuICAgIF9zZXRCYXNlRGltZW5zaW9ucyA9IGZ1bmN0aW9uIF9zZXRCYXNlRGltZW5zaW9ucygpIHtcbiAgX2Jhc2VTY3JlZW5XaWR0aCA9IF93aW4uaW5uZXJXaWR0aDtcbiAgX2Jhc2VTY3JlZW5IZWlnaHQgPSBfd2luLmlubmVySGVpZ2h0O1xufSxcbiAgICBfb25SZXNpemUgPSBmdW5jdGlvbiBfb25SZXNpemUoZm9yY2UpIHtcbiAgX3Njcm9sbGVycy5jYWNoZSsrO1xuICAoZm9yY2UgPT09IHRydWUgfHwgIV9yZWZyZXNoaW5nICYmICFfaWdub3JlUmVzaXplICYmICFfZG9jLmZ1bGxzY3JlZW5FbGVtZW50ICYmICFfZG9jLndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50ICYmICghX2lnbm9yZU1vYmlsZVJlc2l6ZSB8fCBfYmFzZVNjcmVlbldpZHRoICE9PSBfd2luLmlubmVyV2lkdGggfHwgTWF0aC5hYnMoX3dpbi5pbm5lckhlaWdodCAtIF9iYXNlU2NyZWVuSGVpZ2h0KSA+IF93aW4uaW5uZXJIZWlnaHQgKiAwLjI1KSkgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSk7XG59LFxuICAgIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcbl9saXN0ZW5lcnMgPSB7fSxcbiAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgIF9zb2Z0UmVmcmVzaCA9IGZ1bmN0aW9uIF9zb2Z0UmVmcmVzaCgpIHtcbiAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpIHx8IF9yZWZyZXNoQWxsKHRydWUpO1xufSxcbiAgICBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBfZGlzcGF0Y2godHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVyc1t0eXBlXSAmJiBfbGlzdGVuZXJzW3R5cGVdLm1hcChmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKCk7XG4gIH0pIHx8IF9lbXB0eUFycmF5O1xufSxcbiAgICBfc2F2ZWRTdHlsZXMgPSBbXSxcbiAgICAvLyB3aGVuIFNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcygpIGlzIGNhbGxlZCwgdGhlIGlubGluZSBzdHlsZXMgYXJlIHJlY29yZGVkIGluIHRoaXMgQXJyYXkgaW4gYSBzZXF1ZW50aWFsIGZvcm1hdCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCBnc0NhY2hlLCBtZWRpYV0uIFRoaXMga2VlcHMgaXQgdmVyeSBtZW1vcnktZWZmaWNpZW50IGFuZCBmYXN0IHRvIGl0ZXJhdGUgdGhyb3VnaC5cbl9yZXZlcnRSZWNvcmRlZCA9IGZ1bmN0aW9uIF9yZXZlcnRSZWNvcmRlZChtZWRpYSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IF9zYXZlZFN0eWxlcy5sZW5ndGg7IGkgKz0gNSkge1xuICAgIGlmICghbWVkaWEgfHwgX3NhdmVkU3R5bGVzW2kgKyA0XSAmJiBfc2F2ZWRTdHlsZXNbaSArIDRdLnF1ZXJ5ID09PSBtZWRpYSkge1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSArIDFdO1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLmdldEJCb3ggJiYgX3NhdmVkU3R5bGVzW2ldLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBfc2F2ZWRTdHlsZXNbaSArIDJdIHx8IFwiXCIpO1xuICAgICAgX3NhdmVkU3R5bGVzW2kgKyAzXS51bmNhY2hlID0gMTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3JldmVydEFsbCA9IGZ1bmN0aW9uIF9yZXZlcnRBbGwoa2lsbCwgbWVkaWEpIHtcbiAgdmFyIHRyaWdnZXI7XG5cbiAgZm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcnNbX2ldO1xuXG4gICAgaWYgKHRyaWdnZXIgJiYgKCFtZWRpYSB8fCB0cmlnZ2VyLl9jdHggPT09IG1lZGlhKSkge1xuICAgICAgaWYgKGtpbGwpIHtcbiAgICAgICAgdHJpZ2dlci5raWxsKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJpZ2dlci5yZXZlcnQodHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2lzUmV2ZXJ0ZWQgPSB0cnVlO1xuICBtZWRpYSAmJiBfcmV2ZXJ0UmVjb3JkZWQobWVkaWEpO1xuICBtZWRpYSB8fCBfZGlzcGF0Y2goXCJyZXZlcnRcIik7XG59LFxuICAgIF9jbGVhclNjcm9sbE1lbW9yeSA9IGZ1bmN0aW9uIF9jbGVhclNjcm9sbE1lbW9yeShzY3JvbGxSZXN0b3JhdGlvbiwgZm9yY2UpIHtcbiAgLy8gemVyby1vdXQgYWxsIHRoZSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb25zLiBEb24ndCB1c2UgX3RyaWdnZXJzIGJlY2F1c2UgaWYsIGZvciBleGFtcGxlLCAubWF0Y2hNZWRpYSgpIGlzIHVzZWQgdG8gY3JlYXRlIHNvbWUgU2Nyb2xsVHJpZ2dlcnMgYW5kIHRoZW4gdGhlIHVzZXIgcmVzaXplcyBhbmQgaXQgcmVtb3ZlcyBBTEwgU2Nyb2xsVHJpZ2dlcnMsIGFuZCB0aGVuIGdvIGJhY2sgdG8gYSBzaXplIHdoZXJlIHRoZXJlIGFyZSBTY3JvbGxUcmlnZ2VycywgaXQgd291bGQgaGF2ZSBrZXB0IHRoZSBwb3NpdGlvbihzKSBzYXZlZCBmcm9tIHRoZSBpbml0aWFsIHN0YXRlLlxuICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gIChmb3JjZSB8fCAhX3JlZnJlc2hpbmdBbGwpICYmIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKG9iaikgJiYgb2JqLmNhY2hlSUQrKyAmJiAob2JqLnJlYyA9IDApO1xuICB9KTtcbiAgX2lzU3RyaW5nKHNjcm9sbFJlc3RvcmF0aW9uKSAmJiAoX3dpbi5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gX3Njcm9sbFJlc3RvcmF0aW9uID0gc2Nyb2xsUmVzdG9yYXRpb24pO1xufSxcbiAgICBfcmVmcmVzaGluZ0FsbCxcbiAgICBfcmVmcmVzaElEID0gMCxcbiAgICBfcXVldWVSZWZyZXNoSUQsXG4gICAgX3F1ZXVlUmVmcmVzaEFsbCA9IGZ1bmN0aW9uIF9xdWV1ZVJlZnJlc2hBbGwoKSB7XG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBfcmVmcmVzaEFsbCgpIGV2ZXJ5IHRpbWUgd2UgY3JlYXRlIGEgbmV3IFNjcm9sbFRyaWdnZXIgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSAtIGl0J3MgYmV0dGVyIHRvIGJhdGNoIHRoZW0uIFNvbWUgZnJhbWV3b3JrcyBkeW5hbWljYWxseSBsb2FkIGNvbnRlbnQgYW5kIHdlIGNhbid0IHJlbHkgb24gdGhlIHdpbmRvdydzIFwibG9hZFwiIG9yIFwiRE9NQ29udGVudExvYWRlZFwiIGV2ZW50cyB0byB0cmlnZ2VyIGl0LlxuICBpZiAoX3F1ZXVlUmVmcmVzaElEICE9PSBfcmVmcmVzaElEKSB7XG4gICAgdmFyIGlkID0gX3F1ZXVlUmVmcmVzaElEID0gX3JlZnJlc2hJRDtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlkID09PSBfcmVmcmVzaElEICYmIF9yZWZyZXNoQWxsKHRydWUpO1xuICAgIH0pO1xuICB9XG59LFxuICAgIF9yZWZyZXNoMTAwdmggPSBmdW5jdGlvbiBfcmVmcmVzaDEwMHZoKCkge1xuICBfYm9keS5hcHBlbmRDaGlsZChfZGl2MTAwdmgpO1xuXG4gIF8xMDB2aCA9ICFfbm9ybWFsaXplciAmJiBfZGl2MTAwdmgub2Zmc2V0SGVpZ2h0IHx8IF93aW4uaW5uZXJIZWlnaHQ7XG5cbiAgX2JvZHkucmVtb3ZlQ2hpbGQoX2RpdjEwMHZoKTtcbn0sXG4gICAgX2hpZGVBbGxNYXJrZXJzID0gZnVuY3Rpb24gX2hpZGVBbGxNYXJrZXJzKGhpZGUpIHtcbiAgcmV0dXJuIF90b0FycmF5KFwiLmdzYXAtbWFya2VyLXN0YXJ0LCAuZ3NhcC1tYXJrZXItZW5kLCAuZ3NhcC1tYXJrZXItc2Nyb2xsZXItc3RhcnQsIC5nc2FwLW1hcmtlci1zY3JvbGxlci1lbmRcIikuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuc3R5bGUuZGlzcGxheSA9IGhpZGUgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgfSk7XG59LFxuICAgIF9yZWZyZXNoQWxsID0gZnVuY3Rpb24gX3JlZnJlc2hBbGwoZm9yY2UsIHNraXBSZXZlcnQpIHtcbiAgX2RvY0VsID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7IC8vIHNvbWUgZnJhbWV3b3JrcyBsaWtlIEFzdHJvIG1heSBjYWNoZSB0aGUgPGJvZHk+IGFuZCByZXBsYWNlIGl0IGR1cmluZyByb3V0aW5nLCBzbyB3ZSdsbCBqdXN0IHJlLXJlY29yZCB0aGUgX2RvY0VsIGFuZCBfYm9keSBmb3Igc2FmZXR5IChvdGhlcndpc2UsIHRoZSBtYXJrZXJzIG1heSBub3QgZ2V0IGFkZGVkIHByb3Blcmx5KS5cblxuICBfYm9keSA9IF9kb2MuYm9keTtcbiAgX3Jvb3QgPSBbX3dpbiwgX2RvYywgX2RvY0VsLCBfYm9keV07XG5cbiAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhZm9yY2UgJiYgIV9pc1JldmVydGVkKSB7XG4gICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBfcmVmcmVzaDEwMHZoKCk7XG5cbiAgX3JlZnJlc2hpbmdBbGwgPSBTY3JvbGxUcmlnZ2VyLmlzUmVmcmVzaGluZyA9IHRydWU7XG5cbiAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gX2lzRnVuY3Rpb24ob2JqKSAmJiArK29iai5jYWNoZUlEICYmIChvYmoucmVjID0gb2JqKCkpO1xuICB9KTsgLy8gZm9yY2UgdGhlIGNsZWFyaW5nIG9mIHRoZSBjYWNoZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgdGFrZSBhIGxpdHRsZSB3aGlsZSB0byBkaXNwYXRjaCB0aGUgXCJzY3JvbGxcIiBldmVudCBhbmQgdGhlIHVzZXIgbWF5IGhhdmUgY2hhbmdlZCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFuZCB0aGVuIGNhbGxlZCBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSByaWdodCBhd2F5XG5cblxuICB2YXIgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XG5cbiAgX3NvcnQgJiYgU2Nyb2xsVHJpZ2dlci5zb3J0KCk7XG4gIHNraXBSZXZlcnQgfHwgX3JldmVydEFsbCgpO1xuXG4gIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKF9pc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgIG9iai5zbW9vdGggJiYgKG9iai50YXJnZXQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcImF1dG9cIik7IC8vIHNtb290aCBzY3JvbGxpbmcgaW50ZXJmZXJlc1xuXG4gICAgICBvYmooMCk7XG4gICAgfVxuICB9KTtcblxuICBfdHJpZ2dlcnMuc2xpY2UoMCkuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnJlZnJlc2goKTtcbiAgfSk7IC8vIGRvbid0IGxvb3Agd2l0aCBfaSBiZWNhdXNlIGR1cmluZyBhIHJlZnJlc2goKSBzb21lb25lIGNvdWxkIGNhbGwgU2Nyb2xsVHJpZ2dlci51cGRhdGUoKSB3aGljaCB3b3VsZCBpdGVyYXRlIHRocm91Z2ggX2kgcmVzdWx0aW5nIGluIGEgc2tpcC5cblxuXG4gIF9pc1JldmVydGVkID0gZmFsc2U7XG5cbiAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAvLyBuZXN0ZWQgcGlucyAocGlubmVkQ29udGFpbmVyKSB3aXRoIHBpblNwYWNpbmcgbWF5IGV4cGFuZCB0aGUgY29udGFpbmVyLCBzbyB3ZSBtdXN0IGFjY29tbW9kYXRlIHRoYXQgaGVyZS5cbiAgICBpZiAodC5fc3ViUGluT2Zmc2V0ICYmIHQucGluKSB7XG4gICAgICB2YXIgcHJvcCA9IHQudmFycy5ob3Jpem9udGFsID8gXCJvZmZzZXRXaWR0aFwiIDogXCJvZmZzZXRIZWlnaHRcIixcbiAgICAgICAgICBvcmlnaW5hbCA9IHQucGluW3Byb3BdO1xuICAgICAgdC5yZXZlcnQodHJ1ZSwgMSk7XG4gICAgICB0LmFkanVzdFBpblNwYWNpbmcodC5waW5bcHJvcF0gLSBvcmlnaW5hbCk7XG4gICAgICB0LnJlZnJlc2goKTtcbiAgICB9XG4gIH0pO1xuXG4gIF9jbGFtcGluZ01heCA9IDE7IC8vIHBpblNwYWNpbmcgbWlnaHQgYmUgcHJvcHBpbmcgYSBwYWdlIG9wZW4sIHRodXMgd2hlbiB3ZSAuc2V0UG9zaXRpb25zKCkgdG8gY2xhbXAgYSBTY3JvbGxUcmlnZ2VyJ3MgZW5kIHdlIHNob3VsZCBsZWF2ZSB0aGUgcGluU3BhY2luZyBhbG9uZS4gVGhhdCdzIHdoYXQgdGhpcyBmbGFnIGlzIGZvci5cblxuICBfaGlkZUFsbE1hcmtlcnModHJ1ZSk7XG5cbiAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAvLyB0aGUgc2Nyb2xsZXIncyBtYXggc2Nyb2xsIHBvc2l0aW9uIG1heSBjaGFuZ2UgYWZ0ZXIgYWxsIHRoZSBTY3JvbGxUcmlnZ2VycyByZWZyZXNoZWQgKGxpa2UgcGlubmluZyBjb3VsZCBwdXNoIGl0IGRvd24pLCBzbyB3ZSBuZWVkIHRvIGxvb3AgYmFjayBhbmQgY29ycmVjdCBhbnkgd2l0aCBlbmQ6IFwibWF4XCIuIFNhbWUgZm9yIGFueXRoaW5nIHdpdGggYSBjbGFtcGVkIGVuZFxuICAgIHZhciBtYXggPSBfbWF4U2Nyb2xsKHQuc2Nyb2xsZXIsIHQuX2RpciksXG4gICAgICAgIGVuZENsYW1wID0gdC52YXJzLmVuZCA9PT0gXCJtYXhcIiB8fCB0Ll9lbmRDbGFtcCAmJiB0LmVuZCA+IG1heCxcbiAgICAgICAgc3RhcnRDbGFtcCA9IHQuX3N0YXJ0Q2xhbXAgJiYgdC5zdGFydCA+PSBtYXg7XG5cbiAgICAoZW5kQ2xhbXAgfHwgc3RhcnRDbGFtcCkgJiYgdC5zZXRQb3NpdGlvbnMoc3RhcnRDbGFtcCA/IG1heCAtIDEgOiB0LnN0YXJ0LCBlbmRDbGFtcCA/IE1hdGgubWF4KHN0YXJ0Q2xhbXAgPyBtYXggOiB0LnN0YXJ0ICsgMSwgbWF4KSA6IHQuZW5kLCB0cnVlKTtcbiAgfSk7XG5cbiAgX2hpZGVBbGxNYXJrZXJzKGZhbHNlKTtcblxuICBfY2xhbXBpbmdNYXggPSAwO1xuICByZWZyZXNoSW5pdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQucmVuZGVyICYmIHJlc3VsdC5yZW5kZXIoLTEpO1xuICB9KTsgLy8gaWYgdGhlIG9uUmVmcmVzaEluaXQoKSByZXR1cm5zIGFuIGFuaW1hdGlvbiAodHlwaWNhbGx5IGEgZ3NhcC5zZXQoKSksIHJldmVydCBpdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIHB1dCB0aGluZ3MgaW4gYSBjZXJ0YWluIHNwb3QgYmVmb3JlIHJlZnJlc2hpbmcgZm9yIG1lYXN1cmVtZW50IHB1cnBvc2VzLCBhbmQgdGhlbiBwdXQgdGhpbmdzIGJhY2suXG5cbiAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoX2lzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgb2JqLnNtb290aCAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqLnRhcmdldC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwic21vb3RoXCI7XG4gICAgICB9KTtcbiAgICAgIG9iai5yZWMgJiYgb2JqKG9iai5yZWMpO1xuICAgIH1cbiAgfSk7XG5cbiAgX2NsZWFyU2Nyb2xsTWVtb3J5KF9zY3JvbGxSZXN0b3JhdGlvbiwgMSk7XG5cbiAgX3Jlc2l6ZURlbGF5LnBhdXNlKCk7XG5cbiAgX3JlZnJlc2hJRCsrO1xuICBfcmVmcmVzaGluZ0FsbCA9IDI7XG5cbiAgX3VwZGF0ZUFsbCgyKTtcblxuICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBfaXNGdW5jdGlvbih0LnZhcnMub25SZWZyZXNoKSAmJiB0LnZhcnMub25SZWZyZXNoKHQpO1xuICB9KTtcblxuICBfcmVmcmVzaGluZ0FsbCA9IFNjcm9sbFRyaWdnZXIuaXNSZWZyZXNoaW5nID0gZmFsc2U7XG5cbiAgX2Rpc3BhdGNoKFwicmVmcmVzaFwiKTtcbn0sXG4gICAgX2xhc3RTY3JvbGwgPSAwLFxuICAgIF9kaXJlY3Rpb24gPSAxLFxuICAgIF9wcmltYXJ5LFxuICAgIF91cGRhdGVBbGwgPSBmdW5jdGlvbiBfdXBkYXRlQWxsKGZvcmNlKSB7XG4gIGlmIChmb3JjZSA9PT0gMiB8fCAhX3JlZnJlc2hpbmdBbGwgJiYgIV9pc1JldmVydGVkKSB7XG4gICAgLy8gX2lzUmV2ZXJ0ZWQgY291bGQgYmUgdHJ1ZSBpZiwgZm9yIGV4YW1wbGUsIGEgbWF0Y2hNZWRpYSgpIGlzIGluIHRoZSBwcm9jZXNzIG9mIGV4ZWN1dGluZy4gV2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgZHVyaW5nIHRoZSB0aW1lIGV2ZXJ5dGhpbmcgaXMgcmV2ZXJ0ZWQuXG4gICAgU2Nyb2xsVHJpZ2dlci5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICBfcHJpbWFyeSAmJiBfcHJpbWFyeS51cGRhdGUoMCk7IC8vIFNjcm9sbFNtb290aGVyIHVzZXMgcmVmcmVzaFByaW9yaXR5IC05OTk5IHRvIGJlY29tZSB0aGUgcHJpbWFyeSB0aGF0IGdldHMgdXBkYXRlZCBiZWZvcmUgYWxsIG90aGVycyBiZWNhdXNlIGl0IGFmZmVjdHMgdGhlIHNjcm9sbCBwb3NpdGlvbi5cblxuICAgIHZhciBsID0gX3RyaWdnZXJzLmxlbmd0aCxcbiAgICAgICAgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgIHJlY29yZFZlbG9jaXR5ID0gdGltZSAtIF90aW1lMSA+PSA1MCxcbiAgICAgICAgc2Nyb2xsID0gbCAmJiBfdHJpZ2dlcnNbMF0uc2Nyb2xsKCk7XG5cbiAgICBfZGlyZWN0aW9uID0gX2xhc3RTY3JvbGwgPiBzY3JvbGwgPyAtMSA6IDE7XG4gICAgX3JlZnJlc2hpbmdBbGwgfHwgKF9sYXN0U2Nyb2xsID0gc2Nyb2xsKTtcblxuICAgIGlmIChyZWNvcmRWZWxvY2l0eSkge1xuICAgICAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhX3BvaW50ZXJJc0Rvd24gJiYgdGltZSAtIF9sYXN0U2Nyb2xsVGltZSA+IDIwMCkge1xuICAgICAgICBfbGFzdFNjcm9sbFRpbWUgPSAwO1xuXG4gICAgICAgIF9kaXNwYXRjaChcInNjcm9sbEVuZFwiKTtcbiAgICAgIH1cblxuICAgICAgX3RpbWUyID0gX3RpbWUxO1xuICAgICAgX3RpbWUxID0gdGltZTtcbiAgICB9XG5cbiAgICBpZiAoX2RpcmVjdGlvbiA8IDApIHtcbiAgICAgIF9pID0gbDtcblxuICAgICAgd2hpbGUgKF9pLS0gPiAwKSB7XG4gICAgICAgIF90cmlnZ2Vyc1tfaV0gJiYgX3RyaWdnZXJzW19pXS51cGRhdGUoMCwgcmVjb3JkVmVsb2NpdHkpO1xuICAgICAgfVxuXG4gICAgICBfZGlyZWN0aW9uID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChfaSA9IDA7IF9pIDwgbDsgX2krKykge1xuICAgICAgICBfdHJpZ2dlcnNbX2ldICYmIF90cmlnZ2Vyc1tfaV0udXBkYXRlKDAsIHJlY29yZFZlbG9jaXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTY3JvbGxUcmlnZ2VyLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIF9yYWZJRCA9IDA7XG59LFxuICAgIF9wcm9wTmFtZXNUb0NvcHkgPSBbX2xlZnQsIF90b3AsIF9ib3R0b20sIF9yaWdodCwgX21hcmdpbiArIF9Cb3R0b20sIF9tYXJnaW4gKyBfUmlnaHQsIF9tYXJnaW4gKyBfVG9wLCBfbWFyZ2luICsgX0xlZnQsIFwiZGlzcGxheVwiLCBcImZsZXhTaHJpbmtcIiwgXCJmbG9hdFwiLCBcInpJbmRleFwiLCBcImdyaWRDb2x1bW5TdGFydFwiLCBcImdyaWRDb2x1bW5FbmRcIiwgXCJncmlkUm93U3RhcnRcIiwgXCJncmlkUm93RW5kXCIsIFwiZ3JpZEFyZWFcIiwgXCJqdXN0aWZ5U2VsZlwiLCBcImFsaWduU2VsZlwiLCBcInBsYWNlU2VsZlwiLCBcIm9yZGVyXCJdLFxuICAgIF9zdGF0ZVByb3BzID0gX3Byb3BOYW1lc1RvQ29weS5jb25jYXQoW193aWR0aCwgX2hlaWdodCwgXCJib3hTaXppbmdcIiwgXCJtYXhcIiArIF9XaWR0aCwgXCJtYXhcIiArIF9IZWlnaHQsIFwicG9zaXRpb25cIiwgX21hcmdpbiwgX3BhZGRpbmcsIF9wYWRkaW5nICsgX1RvcCwgX3BhZGRpbmcgKyBfUmlnaHQsIF9wYWRkaW5nICsgX0JvdHRvbSwgX3BhZGRpbmcgKyBfTGVmdF0pLFxuICAgIF9zd2FwUGluT3V0ID0gZnVuY3Rpb24gX3N3YXBQaW5PdXQocGluLCBzcGFjZXIsIHN0YXRlKSB7XG4gIF9zZXRTdGF0ZShzdGF0ZSk7XG5cbiAgdmFyIGNhY2hlID0gcGluLl9nc2FwO1xuXG4gIGlmIChjYWNoZS5zcGFjZXJJc05hdGl2ZSkge1xuICAgIF9zZXRTdGF0ZShjYWNoZS5zcGFjZXJTdGF0ZSk7XG4gIH0gZWxzZSBpZiAocGluLl9nc2FwLnN3YXBwZWRJbikge1xuICAgIHZhciBwYXJlbnQgPSBzcGFjZXIucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUocGluLCBzcGFjZXIpO1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHNwYWNlcik7XG4gICAgfVxuICB9XG5cbiAgcGluLl9nc2FwLnN3YXBwZWRJbiA9IGZhbHNlO1xufSxcbiAgICBfc3dhcFBpbkluID0gZnVuY3Rpb24gX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MsIHNwYWNlclN0YXRlKSB7XG4gIGlmICghcGluLl9nc2FwLnN3YXBwZWRJbikge1xuICAgIHZhciBpID0gX3Byb3BOYW1lc1RvQ29weS5sZW5ndGgsXG4gICAgICAgIHNwYWNlclN0eWxlID0gc3BhY2VyLnN0eWxlLFxuICAgICAgICBwaW5TdHlsZSA9IHBpbi5zdHlsZSxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHAgPSBfcHJvcE5hbWVzVG9Db3B5W2ldO1xuICAgICAgc3BhY2VyU3R5bGVbcF0gPSBjc1twXTtcbiAgICB9XG5cbiAgICBzcGFjZXJTdHlsZS5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIgPyBcImFic29sdXRlXCIgOiBcInJlbGF0aXZlXCI7XG4gICAgY3MuZGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiAoc3BhY2VyU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpO1xuICAgIHBpblN0eWxlW19ib3R0b21dID0gcGluU3R5bGVbX3JpZ2h0XSA9IFwiYXV0b1wiO1xuICAgIHNwYWNlclN0eWxlLmZsZXhCYXNpcyA9IGNzLmZsZXhCYXNpcyB8fCBcImF1dG9cIjtcbiAgICBzcGFjZXJTdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuICAgIHNwYWNlclN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiO1xuICAgIHNwYWNlclN0eWxlW193aWR0aF0gPSBfZ2V0U2l6ZShwaW4sIF9ob3Jpem9udGFsKSArIF9weDtcbiAgICBzcGFjZXJTdHlsZVtfaGVpZ2h0XSA9IF9nZXRTaXplKHBpbiwgX3ZlcnRpY2FsKSArIF9weDtcbiAgICBzcGFjZXJTdHlsZVtfcGFkZGluZ10gPSBwaW5TdHlsZVtfbWFyZ2luXSA9IHBpblN0eWxlW190b3BdID0gcGluU3R5bGVbX2xlZnRdID0gXCIwXCI7XG5cbiAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuXG4gICAgcGluU3R5bGVbX3dpZHRoXSA9IHBpblN0eWxlW1wibWF4XCIgKyBfV2lkdGhdID0gY3NbX3dpZHRoXTtcbiAgICBwaW5TdHlsZVtfaGVpZ2h0XSA9IHBpblN0eWxlW1wibWF4XCIgKyBfSGVpZ2h0XSA9IGNzW19oZWlnaHRdO1xuICAgIHBpblN0eWxlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcblxuICAgIGlmIChwaW4ucGFyZW50Tm9kZSAhPT0gc3BhY2VyKSB7XG4gICAgICBwaW4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3BhY2VyLCBwaW4pO1xuICAgICAgc3BhY2VyLmFwcGVuZENoaWxkKHBpbik7XG4gICAgfVxuXG4gICAgcGluLl9nc2FwLnN3YXBwZWRJbiA9IHRydWU7XG4gIH1cbn0sXG4gICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuICAgIF9zZXRTdGF0ZSA9IGZ1bmN0aW9uIF9zZXRTdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50LnN0eWxlLFxuICAgICAgICBsID0gc3RhdGUubGVuZ3RoLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgcCxcbiAgICAgICAgdmFsdWU7XG4gICAgKHN0YXRlLnQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHN0YXRlLnQpKS51bmNhY2hlID0gMTsgLy8gb3RoZXJ3aXNlIHRyYW5zZm9ybXMgbWF5IGJlIG9mZlxuXG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGVbaSArIDFdO1xuICAgICAgcCA9IHN0YXRlW2ldO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc3R5bGVbcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVbcF0pIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldFN0YXRlID0gZnVuY3Rpb24gX2dldFN0YXRlKGVsZW1lbnQpIHtcbiAgLy8gcmV0dXJucyBhbiBBcnJheSB3aXRoIGFsdGVybmF0aW5nIHZhbHVlcyBsaWtlIFtwcm9wZXJ0eSwgdmFsdWUsIHByb3BlcnR5LCB2YWx1ZV0gYW5kIGEgXCJ0XCIgcHJvcGVydHkgcG9pbnRpbmcgdG8gdGhlIHRhcmdldCAoZWxlbWVudCkuIE1ha2VzIGl0IGZhc3QgYW5kIGNoZWFwLlxuICB2YXIgbCA9IF9zdGF0ZVByb3BzLmxlbmd0aCxcbiAgICAgIHN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgIHN0YXRlID0gW10sXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIHN0YXRlLnB1c2goX3N0YXRlUHJvcHNbaV0sIHN0eWxlW19zdGF0ZVByb3BzW2ldXSk7XG4gIH1cblxuICBzdGF0ZS50ID0gZWxlbWVudDtcbiAgcmV0dXJuIHN0YXRlO1xufSxcbiAgICBfY29weVN0YXRlID0gZnVuY3Rpb24gX2NvcHlTdGF0ZShzdGF0ZSwgb3ZlcnJpZGUsIG9taXRPZmZzZXRzKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXG4gICAgICBpID0gb21pdE9mZnNldHMgPyA4IDogMCxcbiAgICAgIC8vIHNraXAgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tIGlmIG9taXRPZmZzZXRzIGlzIHRydWVcbiAgcDtcblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHAgPSBzdGF0ZVtpXTtcbiAgICByZXN1bHQucHVzaChwLCBwIGluIG92ZXJyaWRlID8gb3ZlcnJpZGVbcF0gOiBzdGF0ZVtpICsgMV0pO1xuICB9XG5cbiAgcmVzdWx0LnQgPSBzdGF0ZS50O1xuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfd2luT2Zmc2V0cyA9IHtcbiAgbGVmdDogMCxcbiAgdG9wOiAwXG59LFxuICAgIC8vIC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAoPykgQWxsb3cgdXNlcnMgdG8gY2FsY3VsYXRlIHdoZXJlIGEgdHJpZ2dlciBoaXRzIChzY3JvbGwgcG9zaXRpb24pIGxpa2UgZ2V0U2Nyb2xsUG9zaXRpb24oXCIjaWRcIiwgXCJ0b3AgYm90dG9tXCIpXG4vLyBfZ2V0U2Nyb2xsUG9zaXRpb24gPSAodHJpZ2dlciwgcG9zaXRpb24sIHtzY3JvbGxlciwgY29udGFpbmVyQW5pbWF0aW9uLCBob3Jpem9udGFsfSkgPT4ge1xuLy8gXHRzY3JvbGxlciA9IF9nZXRUYXJnZXQoc2Nyb2xsZXIgfHwgX3dpbik7XG4vLyBcdGxldCBkaXJlY3Rpb24gPSBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwsXG4vLyBcdFx0aXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHNjcm9sbGVyKTtcbi8vIFx0X2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pO1xuLy8gXHRyZXR1cm4gX3BhcnNlUG9zaXRpb24ocG9zaXRpb24sIF9nZXRUYXJnZXQodHJpZ2dlciksIF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgZGlyZWN0aW9uKSgpLCBkaXJlY3Rpb24sIF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pKCksIDAsIDAsIDAsIF9nZXRPZmZzZXRzRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCkoKSwgaXNWaWV3cG9ydCA/IDAgOiBwYXJzZUZsb2F0KF9nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGVyKVtcImJvcmRlclwiICsgZGlyZWN0aW9uLnAyICsgX1dpZHRoXSkgfHwgMCwgMCwgY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgOiBfbWF4U2Nyb2xsKHNjcm9sbGVyKSwgY29udGFpbmVyQW5pbWF0aW9uKTtcbi8vIH0sXG5fcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKHZhbHVlLCB0cmlnZ2VyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsLCBtYXJrZXIsIG1hcmtlclNjcm9sbGVyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIHNjcm9sbGVyTWF4LCBjb250YWluZXJBbmltYXRpb24sIGNsYW1wWmVyb1Byb3ApIHtcbiAgX2lzRnVuY3Rpb24odmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlKHNlbGYpKTtcblxuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdWJzdHIoMCwgMykgPT09IFwibWF4XCIpIHtcbiAgICB2YWx1ZSA9IHNjcm9sbGVyTWF4ICsgKHZhbHVlLmNoYXJBdCg0KSA9PT0gXCI9XCIgPyBfb2Zmc2V0VG9QeChcIjBcIiArIHZhbHVlLnN1YnN0cigzKSwgc2Nyb2xsZXJTaXplKSA6IDApO1xuICB9XG5cbiAgdmFyIHRpbWUgPSBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24udGltZSgpIDogMCxcbiAgICAgIHAxLFxuICAgICAgcDIsXG4gICAgICBlbGVtZW50O1xuICBjb250YWluZXJBbmltYXRpb24gJiYgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsoMCk7XG4gIGlzTmFOKHZhbHVlKSB8fCAodmFsdWUgPSArdmFsdWUpOyAvLyBjb252ZXJ0IGEgc3RyaW5nIG51bWJlciBsaWtlIFwiNDVcIiB0byBhbiBhY3R1YWwgbnVtYmVyXG5cbiAgaWYgKCFfaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgX2lzRnVuY3Rpb24odHJpZ2dlcikgJiYgKHRyaWdnZXIgPSB0cmlnZ2VyKHNlbGYpKTtcbiAgICB2YXIgb2Zmc2V0cyA9ICh2YWx1ZSB8fCBcIjBcIikuc3BsaXQoXCIgXCIpLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIGxvY2FsT2Zmc2V0LFxuICAgICAgICBnbG9iYWxPZmZzZXQsXG4gICAgICAgIGRpc3BsYXk7XG4gICAgZWxlbWVudCA9IF9nZXRUYXJnZXQodHJpZ2dlciwgc2VsZikgfHwgX2JvZHk7XG4gICAgYm91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KSB8fCB7fTtcblxuICAgIGlmICgoIWJvdW5kcyB8fCAhYm91bmRzLmxlZnQgJiYgIWJvdW5kcy50b3ApICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBpZiBkaXNwbGF5IGlzIFwibm9uZVwiLCBpdCB3b24ndCByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgcHJvcGVybHlcbiAgICAgIGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgICAgZGlzcGxheSA/IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgOiBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9XG5cbiAgICBsb2NhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMF0sIGJvdW5kc1tkaXJlY3Rpb24uZF0pO1xuICAgIGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XG4gICAgdmFsdWUgPSBib3VuZHNbZGlyZWN0aW9uLnBdIC0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLnBdIC0gYm9yZGVyV2lkdGggKyBsb2NhbE9mZnNldCArIHNjcm9sbCAtIGdsb2JhbE9mZnNldDtcbiAgICBtYXJrZXJTY3JvbGxlciAmJiBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIGdsb2JhbE9mZnNldCwgZGlyZWN0aW9uLCBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQgPCAyMCB8fCBtYXJrZXJTY3JvbGxlci5faXNTdGFydCAmJiBnbG9iYWxPZmZzZXQgPiAyMCk7XG4gICAgc2Nyb2xsZXJTaXplIC09IHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldDsgLy8gYWRqdXN0IGZvciB0aGUgbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uICYmICh2YWx1ZSA9IGdzYXAudXRpbHMubWFwUmFuZ2UoY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIuc3RhcnQsIGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmVuZCwgMCwgc2Nyb2xsZXJNYXgsIHZhbHVlKSk7XG4gICAgbWFya2VyU2Nyb2xsZXIgJiYgX3Bvc2l0aW9uTWFya2VyKG1hcmtlclNjcm9sbGVyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoY2xhbXBaZXJvUHJvcCkge1xuICAgIHNlbGZbY2xhbXBaZXJvUHJvcF0gPSB2YWx1ZSB8fCAtMC4wMDE7XG4gICAgdmFsdWUgPCAwICYmICh2YWx1ZSA9IDApO1xuICB9XG5cbiAgaWYgKG1hcmtlcikge1xuICAgIHZhciBwb3NpdGlvbiA9IHZhbHVlICsgc2Nyb2xsZXJTaXplLFxuICAgICAgICBpc1N0YXJ0ID0gbWFya2VyLl9pc1N0YXJ0O1xuICAgIHAxID0gXCJzY3JvbGxcIiArIGRpcmVjdGlvbi5kMjtcblxuICAgIF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHBvc2l0aW9uLCBkaXJlY3Rpb24sIGlzU3RhcnQgJiYgcG9zaXRpb24gPiAyMCB8fCAhaXNTdGFydCAmJiAodXNlRml4ZWRQb3NpdGlvbiA/IE1hdGgubWF4KF9ib2R5W3AxXSwgX2RvY0VsW3AxXSkgOiBtYXJrZXIucGFyZW50Tm9kZVtwMV0pIDw9IHBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAodXNlRml4ZWRQb3NpdGlvbikge1xuICAgICAgc2Nyb2xsZXJCb3VuZHMgPSBfZ2V0Qm91bmRzKG1hcmtlclNjcm9sbGVyKTtcbiAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgKG1hcmtlci5zdHlsZVtkaXJlY3Rpb24ub3AucF0gPSBzY3JvbGxlckJvdW5kc1tkaXJlY3Rpb24ub3AucF0gLSBkaXJlY3Rpb24ub3AubSAtIG1hcmtlci5fb2Zmc2V0ICsgX3B4KTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29udGFpbmVyQW5pbWF0aW9uICYmIGVsZW1lbnQpIHtcbiAgICBwMSA9IF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsoc2Nyb2xsZXJNYXgpO1xuICAgIHAyID0gX2dldEJvdW5kcyhlbGVtZW50KTtcbiAgICBjb250YWluZXJBbmltYXRpb24uX2NhU2Nyb2xsRGlzdCA9IHAxW2RpcmVjdGlvbi5wXSAtIHAyW2RpcmVjdGlvbi5wXTtcbiAgICB2YWx1ZSA9IHZhbHVlIC8gY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgKiBzY3JvbGxlck1heDtcbiAgfVxuXG4gIGNvbnRhaW5lckFuaW1hdGlvbiAmJiBjb250YWluZXJBbmltYXRpb24uc2Vlayh0aW1lKTtcbiAgcmV0dXJuIGNvbnRhaW5lckFuaW1hdGlvbiA/IHZhbHVlIDogTWF0aC5yb3VuZCh2YWx1ZSk7XG59LFxuICAgIF9wcmVmaXhFeHAgPSAvKHdlYmtpdHxtb3p8bGVuZ3RofGNzc1RleHR8aW5zZXQpL2ksXG4gICAgX3JlcGFyZW50ID0gZnVuY3Rpb24gX3JlcGFyZW50KGVsZW1lbnQsIHBhcmVudCwgdG9wLCBsZWZ0KSB7XG4gIGlmIChlbGVtZW50LnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHAsXG4gICAgICAgIGNzO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gX2JvZHkpIHtcbiAgICAgIGVsZW1lbnQuX3N0T3JpZyA9IHN0eWxlLmNzc1RleHQ7IC8vIHJlY29yZCBvcmlnaW5hbCBpbmxpbmUgc3R5bGVzIHNvIHdlIGNhbiByZXZlcnQgdGhlbSBsYXRlclxuXG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgICBmb3IgKHAgaW4gY3MpIHtcbiAgICAgICAgLy8gbXVzdCBjb3B5IGFsbCByZWxldmFudCBzdHlsZXMgdG8gZW5zdXJlIHRoYXQgbm90aGluZyBjaGFuZ2VzIHZpc3VhbGx5IHdoZW4gd2UgcmVwYXJlbnQgdG8gdGhlIDxib2R5Pi4gU2tpcCB0aGUgdmVuZG9yIHByZWZpeGVkIG9uZXMuXG4gICAgICAgIGlmICghK3AgJiYgIV9wcmVmaXhFeHAudGVzdChwKSAmJiBjc1twXSAmJiB0eXBlb2Ygc3R5bGVbcF0gPT09IFwic3RyaW5nXCIgJiYgcCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICBzdHlsZVtwXSA9IGNzW3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLnRvcCA9IHRvcDtcbiAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gZWxlbWVudC5fc3RPcmlnO1xuICAgIH1cblxuICAgIGdzYXAuY29yZS5nZXRDYWNoZShlbGVtZW50KS51bmNhY2hlID0gMTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbn0sXG4gICAgX2ludGVycnVwdGlvblRyYWNrZXIgPSBmdW5jdGlvbiBfaW50ZXJydXB0aW9uVHJhY2tlcihnZXRWYWx1ZUZ1bmMsIGluaXRpYWxWYWx1ZSwgb25JbnRlcnJ1cHQpIHtcbiAgdmFyIGxhc3QxID0gaW5pdGlhbFZhbHVlLFxuICAgICAgbGFzdDIgPSBsYXN0MTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBjdXJyZW50ID0gTWF0aC5yb3VuZChnZXRWYWx1ZUZ1bmMoKSk7IC8vIHJvdW5kIGJlY2F1c2UgaW4gc29tZSBbdmVyeSB1bmNvbW1vbl0gV2luZG93cyBlbnZpcm9ubWVudHMsIHNjcm9sbCBjYW4gZ2V0IHJlcG9ydGVkIHdpdGggZGVjaW1hbHMgZXZlbiB0aG91Z2ggaXQgd2FzIHNldCB3aXRob3V0LlxuXG4gICAgaWYgKGN1cnJlbnQgIT09IGxhc3QxICYmIGN1cnJlbnQgIT09IGxhc3QyICYmIE1hdGguYWJzKGN1cnJlbnQgLSBsYXN0MSkgPiAzICYmIE1hdGguYWJzKGN1cnJlbnQgLSBsYXN0MikgPiAzKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBzY3JvbGxzLCBraWxsIHRoZSB0d2Vlbi4gaU9TIFNhZmFyaSBpbnRlcm1pdHRlbnRseSBtaXNyZXBvcnRzIHRoZSBzY3JvbGwgcG9zaXRpb24sIGl0IG1heSBiZSB0aGUgbW9zdCByZWNlbnRseS1zZXQgb25lIG9yIHRoZSBvbmUgYmVmb3JlIHRoYXQhIFdoZW4gU2FmYXJpIGlzIHpvb21lZCAoQ01ELSspLCBpdCBvZnRlbiBtaXNyZXBvcnRzIGFzIDEgcGl4ZWwgb2ZmIHRvbyEgU28gaWYgd2Ugc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gMTI1LCBmb3IgZXhhbXBsZSwgaXQnbGwgYWN0dWFsbHkgcmVwb3J0IGl0IGFzIDEyNC5cbiAgICAgIHZhbHVlID0gY3VycmVudDtcbiAgICAgIG9uSW50ZXJydXB0ICYmIG9uSW50ZXJydXB0KCk7XG4gICAgfVxuXG4gICAgbGFzdDIgPSBsYXN0MTtcbiAgICBsYXN0MSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgIHJldHVybiBsYXN0MTtcbiAgfTtcbn0sXG4gICAgX3NoaWZ0TWFya2VyID0gZnVuY3Rpb24gX3NoaWZ0TWFya2VyKG1hcmtlciwgZGlyZWN0aW9uLCB2YWx1ZSkge1xuICB2YXIgdmFycyA9IHt9O1xuICB2YXJzW2RpcmVjdGlvbi5wXSA9IFwiKz1cIiArIHZhbHVlO1xuICBnc2FwLnNldChtYXJrZXIsIHZhcnMpO1xufSxcbiAgICAvLyBfbWVyZ2VBbmltYXRpb25zID0gYW5pbWF0aW9ucyA9PiB7XG4vLyBcdGxldCB0bCA9IGdzYXAudGltZWxpbmUoe3Ntb290aENoaWxkVGltaW5nOiB0cnVlfSkuc3RhcnRUaW1lKE1hdGgubWluKC4uLmFuaW1hdGlvbnMubWFwKGEgPT4gYS5nbG9iYWxUaW1lKDApKSkpO1xuLy8gXHRhbmltYXRpb25zLmZvckVhY2goYSA9PiB7bGV0IHRpbWUgPSBhLnRvdGFsVGltZSgpOyB0bC5hZGQoYSk7IGEudG90YWxUaW1lKHRpbWUpOyB9KTtcbi8vIFx0dGwuc21vb3RoQ2hpbGRUaW1pbmcgPSBmYWxzZTtcbi8vIFx0cmV0dXJuIHRsO1xuLy8gfSxcbi8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHR3ZWVuIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBwcm92aWRlZCwgYW5kIHdoZW4gZG9pbmcgc28gaXQnbGwgYWRkIGEgLnR3ZWVuIHByb3BlcnR5IHRvIHRoZSBGVU5DVElPTiBpdHNlbGYsIGFuZCByZW1vdmUgaXQgd2hlbiB0aGUgdHdlZW4gY29tcGxldGVzIG9yIGdldHMga2lsbGVkLiBUaGlzIGdpdmVzIHVzIGEgd2F5IHRvIGhhdmUgbXVsdGlwbGUgU2Nyb2xsVHJpZ2dlcnMgdXNlIGEgY2VudHJhbCBmdW5jdGlvbiBmb3IgYW55IGdpdmVuIHNjcm9sbGVyIGFuZCBzZWUgaWYgdGhlcmUncyBhIHNjcm9sbCB0d2VlbiBydW5uaW5nICh3aGljaCB3b3VsZCBhZmZlY3QgaWYvaG93IHRoaW5ncyBnZXQgdXBkYXRlZClcbl9nZXRUd2VlbkNyZWF0b3IgPSBmdW5jdGlvbiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBkaXJlY3Rpb24pIHtcbiAgdmFyIGdldFNjcm9sbCA9IF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuICAgICAgcHJvcCA9IFwiX3Njcm9sbFwiICsgZGlyZWN0aW9uLnAyLFxuICAgICAgLy8gYWRkIGEgdHdlZW5hYmxlIHByb3BlcnR5IHRvIHRoZSBzY3JvbGxlciB0aGF0J3MgYSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9uLCBsaWtlIF9zY3JvbGxUb3Agb3IgX3Njcm9sbExlZnQuIFRoaXMgd2F5LCBpZiBzb21lb25lIGRvZXMgZ3NhcC5raWxsVHdlZW5zT2Yoc2Nyb2xsZXIpIGl0J2xsIGtpbGwgdGhlIHNjcm9sbCB0d2Vlbi5cbiAgZ2V0VHdlZW4gPSBmdW5jdGlvbiBnZXRUd2VlbihzY3JvbGxUbywgdmFycywgaW5pdGlhbFZhbHVlLCBjaGFuZ2UxLCBjaGFuZ2UyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4sXG4gICAgICAgIG9uQ29tcGxldGUgPSB2YXJzLm9uQ29tcGxldGUsXG4gICAgICAgIG1vZGlmaWVycyA9IHt9O1xuICAgIGluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZSB8fCBnZXRTY3JvbGwoKTtcblxuICAgIHZhciBjaGVja0ZvckludGVycnVwdGlvbiA9IF9pbnRlcnJ1cHRpb25UcmFja2VyKGdldFNjcm9sbCwgaW5pdGlhbFZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0d2Vlbi5raWxsKCk7XG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgfSk7XG5cbiAgICBjaGFuZ2UyID0gY2hhbmdlMSAmJiBjaGFuZ2UyIHx8IDA7IC8vIGlmIGNoYW5nZTEgaXMgMCwgd2Ugc2V0IHRoYXQgdG8gdGhlIGRpZmZlcmVuY2UgYW5kIGlnbm9yZSBjaGFuZ2UyLiBPdGhlcndpc2UsIHRoZXJlIHdvdWxkIGJlIGEgY29tcG91bmQgZWZmZWN0LlxuXG4gICAgY2hhbmdlMSA9IGNoYW5nZTEgfHwgc2Nyb2xsVG8gLSBpbml0aWFsVmFsdWU7XG4gICAgdHdlZW4gJiYgdHdlZW4ua2lsbCgpO1xuICAgIHZhcnNbcHJvcF0gPSBzY3JvbGxUbztcbiAgICB2YXJzLmluaGVyaXQgPSBmYWxzZTtcbiAgICB2YXJzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIG1vZGlmaWVyc1twcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjaGVja0ZvckludGVycnVwdGlvbihpbml0aWFsVmFsdWUgKyBjaGFuZ2UxICogdHdlZW4ucmF0aW8gKyBjaGFuZ2UyICogdHdlZW4ucmF0aW8gKiB0d2Vlbi5yYXRpbyk7XG4gICAgfTtcblxuICAgIHZhcnMub25VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gICAgICBnZXRUd2Vlbi50d2VlbiAmJiBfdXBkYXRlQWxsKCk7IC8vIGlmIGl0IHdhcyBpbnRlcnJ1cHRlZC9raWxsZWQsIGxpa2UgaW4gYSBjb250ZXh0LnJldmVydCgpLCBkb24ndCBmb3JjZSBhbiB1cGRhdGVBbGwoKVxuICAgIH07XG5cbiAgICB2YXJzLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUuY2FsbCh0d2Vlbik7XG4gICAgfTtcblxuICAgIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4gPSBnc2FwLnRvKHNjcm9sbGVyLCB2YXJzKTtcbiAgICByZXR1cm4gdHdlZW47XG4gIH07XG5cbiAgc2Nyb2xsZXJbcHJvcF0gPSBnZXRTY3JvbGw7XG5cbiAgZ2V0U2Nyb2xsLndoZWVsSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0VHdlZW4udHdlZW4gJiYgZ2V0VHdlZW4udHdlZW4ua2lsbCgpICYmIChnZXRUd2Vlbi50d2VlbiA9IDApO1xuICB9O1xuXG4gIF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJ3aGVlbFwiLCBnZXRTY3JvbGwud2hlZWxIYW5kbGVyKTsgLy8gV2luZG93cyBtYWNoaW5lcyBoYW5kbGUgbW91c2V3aGVlbCBzY3JvbGxpbmcgaW4gY2h1bmtzIChsaWtlIFwiMyBsaW5lcyBwZXIgc2Nyb2xsXCIpIG1lYW5pbmcgdGhlIHR5cGljYWwgc3RyYXRlZ3kgZm9yIGNhbmNlbGxpbmcgdGhlIHNjcm9sbCBpc24ndCBhcyBzZW5zaXRpdmUuIEl0J3MgbXVjaCBtb3JlIGxpa2VseSB0byBtYXRjaCBvbmUgb2YgdGhlIHByZXZpb3VzIDIgc2Nyb2xsIGV2ZW50IHBvc2l0aW9ucy4gU28gd2Uga2lsbCBhbnkgc25hcHBpbmcgYXMgc29vbiBhcyB0aGVyZSdzIGEgd2hlZWwgZXZlbnQuXG5cblxuICBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggJiYgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcInRvdWNobW92ZVwiLCBnZXRTY3JvbGwud2hlZWxIYW5kbGVyKTtcbiAgcmV0dXJuIGdldFR3ZWVuO1xufTtcblxuZXhwb3J0IHZhciBTY3JvbGxUcmlnZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2Nyb2xsVHJpZ2dlcih2YXJzLCBhbmltYXRpb24pIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgU2Nyb2xsVHJpZ2dlci5yZWdpc3Rlcihnc2FwKSB8fCBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKVwiKTtcblxuICAgIF9jb250ZXh0KHRoaXMpO1xuXG4gICAgdGhpcy5pbml0KHZhcnMsIGFuaW1hdGlvbik7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2Nyb2xsVHJpZ2dlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHZhcnMsIGFuaW1hdGlvbikge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnZhcnMgJiYgdGhpcy5raWxsKHRydWUsIHRydWUpOyAvLyBpbiBjYXNlIGl0J3MgYmVpbmcgaW5pdHRlZCBhZ2FpblxuXG4gICAgaWYgKCFfZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGUgPSB0aGlzLnJlZnJlc2ggPSB0aGlzLmtpbGwgPSBfcGFzc1Rocm91Z2g7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFycyA9IF9zZXREZWZhdWx0cyhfaXNTdHJpbmcodmFycykgfHwgX2lzTnVtYmVyKHZhcnMpIHx8IHZhcnMubm9kZVR5cGUgPyB7XG4gICAgICB0cmlnZ2VyOiB2YXJzXG4gICAgfSA6IHZhcnMsIF9kZWZhdWx0cyk7XG5cbiAgICB2YXIgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBvblVwZGF0ZSA9IF92YXJzLm9uVXBkYXRlLFxuICAgICAgICB0b2dnbGVDbGFzcyA9IF92YXJzLnRvZ2dsZUNsYXNzLFxuICAgICAgICBpZCA9IF92YXJzLmlkLFxuICAgICAgICBvblRvZ2dsZSA9IF92YXJzLm9uVG9nZ2xlLFxuICAgICAgICBvblJlZnJlc2ggPSBfdmFycy5vblJlZnJlc2gsXG4gICAgICAgIHNjcnViID0gX3ZhcnMuc2NydWIsXG4gICAgICAgIHRyaWdnZXIgPSBfdmFycy50cmlnZ2VyLFxuICAgICAgICBwaW4gPSBfdmFycy5waW4sXG4gICAgICAgIHBpblNwYWNpbmcgPSBfdmFycy5waW5TcGFjaW5nLFxuICAgICAgICBpbnZhbGlkYXRlT25SZWZyZXNoID0gX3ZhcnMuaW52YWxpZGF0ZU9uUmVmcmVzaCxcbiAgICAgICAgYW50aWNpcGF0ZVBpbiA9IF92YXJzLmFudGljaXBhdGVQaW4sXG4gICAgICAgIG9uU2NydWJDb21wbGV0ZSA9IF92YXJzLm9uU2NydWJDb21wbGV0ZSxcbiAgICAgICAgb25TbmFwQ29tcGxldGUgPSBfdmFycy5vblNuYXBDb21wbGV0ZSxcbiAgICAgICAgb25jZSA9IF92YXJzLm9uY2UsXG4gICAgICAgIHNuYXAgPSBfdmFycy5zbmFwLFxuICAgICAgICBwaW5SZXBhcmVudCA9IF92YXJzLnBpblJlcGFyZW50LFxuICAgICAgICBwaW5TcGFjZXIgPSBfdmFycy5waW5TcGFjZXIsXG4gICAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiA9IF92YXJzLmNvbnRhaW5lckFuaW1hdGlvbixcbiAgICAgICAgZmFzdFNjcm9sbEVuZCA9IF92YXJzLmZhc3RTY3JvbGxFbmQsXG4gICAgICAgIHByZXZlbnRPdmVybGFwcyA9IF92YXJzLnByZXZlbnRPdmVybGFwcyxcbiAgICAgICAgZGlyZWN0aW9uID0gdmFycy5ob3Jpem9udGFsIHx8IHZhcnMuY29udGFpbmVyQW5pbWF0aW9uICYmIHZhcnMuaG9yaXpvbnRhbCAhPT0gZmFsc2UgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcbiAgICAgICAgaXNUb2dnbGUgPSAhc2NydWIgJiYgc2NydWIgIT09IDAsXG4gICAgICAgIHNjcm9sbGVyID0gX2dldFRhcmdldCh2YXJzLnNjcm9sbGVyIHx8IF93aW4pLFxuICAgICAgICBzY3JvbGxlckNhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHNjcm9sbGVyKSxcbiAgICAgICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHNjcm9sbGVyKSxcbiAgICAgICAgdXNlRml4ZWRQb3NpdGlvbiA9IChcInBpblR5cGVcIiBpbiB2YXJzID8gdmFycy5waW5UeXBlIDogX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJwaW5UeXBlXCIpIHx8IGlzVmlld3BvcnQgJiYgXCJmaXhlZFwiKSA9PT0gXCJmaXhlZFwiLFxuICAgICAgICBjYWxsYmFja3MgPSBbdmFycy5vbkVudGVyLCB2YXJzLm9uTGVhdmUsIHZhcnMub25FbnRlckJhY2ssIHZhcnMub25MZWF2ZUJhY2tdLFxuICAgICAgICB0b2dnbGVBY3Rpb25zID0gaXNUb2dnbGUgJiYgdmFycy50b2dnbGVBY3Rpb25zLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgbWFya2VycyA9IFwibWFya2Vyc1wiIGluIHZhcnMgPyB2YXJzLm1hcmtlcnMgOiBfZGVmYXVsdHMubWFya2VycyxcbiAgICAgICAgYm9yZGVyV2lkdGggPSBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb25SZWZyZXNoSW5pdCA9IHZhcnMub25SZWZyZXNoSW5pdCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFycy5vblJlZnJlc2hJbml0KHNlbGYpO1xuICAgIH0sXG4gICAgICAgIGdldFNjcm9sbGVyU2l6ZSA9IF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgZGlyZWN0aW9uKSxcbiAgICAgICAgZ2V0U2Nyb2xsZXJPZmZzZXRzID0gX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSxcbiAgICAgICAgbGFzdFNuYXAgPSAwLFxuICAgICAgICBsYXN0UmVmcmVzaCA9IDAsXG4gICAgICAgIHByZXZQcm9ncmVzcyA9IDAsXG4gICAgICAgIHNjcm9sbEZ1bmMgPSBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgZGlyZWN0aW9uKSxcbiAgICAgICAgdHdlZW5UbyxcbiAgICAgICAgcGluQ2FjaGUsXG4gICAgICAgIHNuYXBGdW5jLFxuICAgICAgICBzY3JvbGwxLFxuICAgICAgICBzY3JvbGwyLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICBtYXJrZXJTdGFydCxcbiAgICAgICAgbWFya2VyRW5kLFxuICAgICAgICBtYXJrZXJTdGFydFRyaWdnZXIsXG4gICAgICAgIG1hcmtlckVuZFRyaWdnZXIsXG4gICAgICAgIG1hcmtlclZhcnMsXG4gICAgICAgIGV4ZWN1dGluZ09uUmVmcmVzaCxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBwaW5PcmlnaW5hbFN0YXRlLFxuICAgICAgICBwaW5BY3RpdmVTdGF0ZSxcbiAgICAgICAgcGluU3RhdGUsXG4gICAgICAgIHNwYWNlcixcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBwaW5HZXR0ZXIsXG4gICAgICAgIHBpblNldHRlcixcbiAgICAgICAgcGluU3RhcnQsXG4gICAgICAgIHBpbkNoYW5nZSxcbiAgICAgICAgc3BhY2luZ1N0YXJ0LFxuICAgICAgICBzcGFjZXJTdGF0ZSxcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIsXG4gICAgICAgIHBpbk1vdmVzLFxuICAgICAgICBtYXJrZXJFbmRTZXR0ZXIsXG4gICAgICAgIGNzLFxuICAgICAgICBzbmFwMSxcbiAgICAgICAgc25hcDIsXG4gICAgICAgIHNjcnViVHdlZW4sXG4gICAgICAgIHNjcnViU21vb3RoLFxuICAgICAgICBzbmFwRHVyQ2xhbXAsXG4gICAgICAgIHNuYXBEZWxheWVkQ2FsbCxcbiAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgcHJldkFuaW1Qcm9ncmVzcyxcbiAgICAgICAgY2FNYXJrZXJTZXR0ZXIsXG4gICAgICAgIGN1c3RvbVJldmVydFJldHVybjsgLy8gZm9yIHRoZSBzYWtlIG9mIGVmZmljaWVuY3ksIF9zdGFydENsYW1wL19lbmRDbGFtcCBzZXJ2ZSBsaWtlIGEgdHJ1dGh5IHZhbHVlIGluZGljYXRpbmcgdGhhdCBjbGFtcGluZyB3YXMgZW5hYmxlZCBvbiB0aGUgc3RhcnQvZW5kLCBhbmQgQUxTTyBzdG9yZSB0aGUgYWN0dWFsIHByZS1jbGFtcGVkIG51bWVyaWMgdmFsdWUuIFdlIHRhcCBpbnRvIHRoYXQgaW4gU2Nyb2xsU21vb3RoZXIgZm9yIHNwZWVkIGVmZmVjdHMuIFNvIGZvciBleGFtcGxlLCBpZiBzdGFydD1cImNsYW1wKHRvcCBib3R0b20pXCIgcmVzdWx0cyBpbiBhIHN0YXJ0IG9mIC0xMDAgbmF0dXJhbGx5LCBpdCB3b3VsZCBnZXQgY2xhbXBlZCB0byAwIGJ1dCAtMTAwIHdvdWxkIGJlIHN0b3JlZCBpbiBfc3RhcnRDbGFtcC5cblxuXG4gICAgc2VsZi5fc3RhcnRDbGFtcCA9IHNlbGYuX2VuZENsYW1wID0gZmFsc2U7XG4gICAgc2VsZi5fZGlyID0gZGlyZWN0aW9uO1xuICAgIGFudGljaXBhdGVQaW4gKj0gNDU7XG4gICAgc2VsZi5zY3JvbGxlciA9IHNjcm9sbGVyO1xuICAgIHNlbGYuc2Nyb2xsID0gY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLnRpbWUuYmluZChjb250YWluZXJBbmltYXRpb24pIDogc2Nyb2xsRnVuYztcbiAgICBzY3JvbGwxID0gc2Nyb2xsRnVuYygpO1xuICAgIHNlbGYudmFycyA9IHZhcnM7XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uIHx8IHZhcnMuYW5pbWF0aW9uO1xuXG4gICAgaWYgKFwicmVmcmVzaFByaW9yaXR5XCIgaW4gdmFycykge1xuICAgICAgX3NvcnQgPSAxO1xuICAgICAgdmFycy5yZWZyZXNoUHJpb3JpdHkgPT09IC05OTk5ICYmIChfcHJpbWFyeSA9IHNlbGYpOyAvLyB1c2VkIGJ5IFNjcm9sbFNtb290aGVyXG4gICAgfVxuXG4gICAgc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCA9IHNjcm9sbGVyQ2FjaGUudHdlZW5TY3JvbGwgfHwge1xuICAgICAgdG9wOiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfdmVydGljYWwpLFxuICAgICAgbGVmdDogX2dldFR3ZWVuQ3JlYXRvcihzY3JvbGxlciwgX2hvcml6b250YWwpXG4gICAgfTtcbiAgICBzZWxmLnR3ZWVuVG8gPSB0d2VlblRvID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbFtkaXJlY3Rpb24ucF07XG5cbiAgICBzZWxmLnNjcnViRHVyYXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHNjcnViU21vb3RoID0gX2lzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZTtcblxuICAgICAgaWYgKCFzY3J1YlNtb290aCkge1xuICAgICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucHJvZ3Jlc3MoMSkua2lsbCgpO1xuICAgICAgICBzY3J1YlR3ZWVuID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLmR1cmF0aW9uKHZhbHVlKSA6IHNjcnViVHdlZW4gPSBnc2FwLnRvKGFuaW1hdGlvbiwge1xuICAgICAgICAgIGVhc2U6IFwiZXhwb1wiLFxuICAgICAgICAgIHRvdGFsUHJvZ3Jlc3M6IFwiKz0wXCIsXG4gICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgZHVyYXRpb246IHNjcnViU21vb3RoLFxuICAgICAgICAgIHBhdXNlZDogdHJ1ZSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uU2NydWJDb21wbGV0ZSAmJiBvblNjcnViQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgYW5pbWF0aW9uLnZhcnMubGF6eSA9IGZhbHNlO1xuICAgICAgYW5pbWF0aW9uLl9pbml0dGVkICYmICFzZWxmLmlzUmV2ZXJ0ZWQgfHwgYW5pbWF0aW9uLnZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSAmJiB2YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UgJiYgYW5pbWF0aW9uLmR1cmF0aW9uKCkgJiYgYW5pbWF0aW9uLnJlbmRlcigwLCB0cnVlLCB0cnVlKTsgLy8gc3BlY2lhbCBjYXNlOiBpZiB0aGlzIFNjcm9sbFRyaWdnZXIgZ2V0cyByZS1pbml0dGVkLCBhIGZyb20oKSB0d2VlbiB3aXRoIGEgc3RhZ2dlciBjb3VsZCBnZXQgaW5pdHRlZCBpbml0aWFsbHkgYW5kIHRoZW4gcmV2ZXJ0ZWQgb24gdGhlIHJlLWluaXQgd2hpY2ggbWVhbnMgaXQnbGwgbmVlZCB0byBnZXQgcmVuZGVyZWQgYWdhaW4gaGVyZSB0byBwcm9wZXJseSBkaXNwbGF5IHRoaW5ncy4gT3RoZXJ3aXNlLCBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMzY3Nzctc2Nyb2xsc21vb3RoZXItc3BsaXR0ZXh0LW5leHRqcy8gYW5kIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL2VZUHlQcGQ/ZWRpdG9ycz0wMDEwXG5cbiAgICAgIHNlbGYuYW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciA9IHNlbGY7XG4gICAgICBzZWxmLnNjcnViRHVyYXRpb24oc2NydWIpO1xuICAgICAgc25hcDEgPSAwO1xuICAgICAgaWQgfHwgKGlkID0gYW5pbWF0aW9uLnZhcnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChzbmFwKSB7XG4gICAgICAvLyBUT0RPOiBwb3RlbnRpYWwgaWRlYTogdXNlIGxlZ2l0aW1hdGUgQ1NTIHNjcm9sbCBzbmFwcGluZyBieSBwdXNoaW5nIGludmlzaWJsZSBlbGVtZW50cyBpbnRvIHRoZSBET00gdGhhdCBzZXJ2ZSBhcyBzbmFwIHBvc2l0aW9ucywgYW5kIHRvZ2dsZSB0aGUgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zdHlsZS5zY3JvbGxTbmFwVHlwZSBvblRvZ2dsZS4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0pqTHJnV00gZm9yIGEgcXVpY2sgcHJvb2Ygb2YgY29uY2VwdC5cbiAgICAgIGlmICghX2lzT2JqZWN0KHNuYXApIHx8IHNuYXAucHVzaCkge1xuICAgICAgICBzbmFwID0ge1xuICAgICAgICAgIHNuYXBUbzogc25hcFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBcInNjcm9sbEJlaGF2aW9yXCIgaW4gX2JvZHkuc3R5bGUgJiYgZ3NhcC5zZXQoaXNWaWV3cG9ydCA/IFtfYm9keSwgX2RvY0VsXSA6IHNjcm9sbGVyLCB7XG4gICAgICAgIHNjcm9sbEJlaGF2aW9yOiBcImF1dG9cIlxuICAgICAgfSk7IC8vIHNtb290aCBzY3JvbGxpbmcgZG9lc24ndCB3b3JrIHdpdGggc25hcC5cblxuICAgICAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBfaXNGdW5jdGlvbihvKSAmJiBvLnRhcmdldCA9PT0gKGlzVmlld3BvcnQgPyBfZG9jLnNjcm9sbGluZ0VsZW1lbnQgfHwgX2RvY0VsIDogc2Nyb2xsZXIpICYmIChvLnNtb290aCA9IGZhbHNlKTtcbiAgICAgIH0pOyAvLyBub3RlOiBzZXQgc21vb3RoIHRvIGZhbHNlIG9uIGJvdGggdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHNjcm9sbCBnZXR0ZXJzL3NldHRlcnNcblxuXG4gICAgICBzbmFwRnVuYyA9IF9pc0Z1bmN0aW9uKHNuYXAuc25hcFRvKSA/IHNuYXAuc25hcFRvIDogc25hcC5zbmFwVG8gPT09IFwibGFiZWxzXCIgPyBfZ2V0Q2xvc2VzdExhYmVsKGFuaW1hdGlvbikgOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNEaXJlY3Rpb25hbFwiID8gX2dldExhYmVsQXREaXJlY3Rpb24oYW5pbWF0aW9uKSA6IHNuYXAuZGlyZWN0aW9uYWwgIT09IGZhbHNlID8gZnVuY3Rpb24gKHZhbHVlLCBzdCkge1xuICAgICAgICByZXR1cm4gX3NuYXBEaXJlY3Rpb25hbChzbmFwLnNuYXBUbykodmFsdWUsIF9nZXRUaW1lKCkgLSBsYXN0UmVmcmVzaCA8IDUwMCA/IDAgOiBzdC5kaXJlY3Rpb24pO1xuICAgICAgfSA6IGdzYXAudXRpbHMuc25hcChzbmFwLnNuYXBUbyk7XG4gICAgICBzbmFwRHVyQ2xhbXAgPSBzbmFwLmR1cmF0aW9uIHx8IHtcbiAgICAgICAgbWluOiAwLjEsXG4gICAgICAgIG1heDogMlxuICAgICAgfTtcbiAgICAgIHNuYXBEdXJDbGFtcCA9IF9pc09iamVjdChzbmFwRHVyQ2xhbXApID8gX2NsYW1wKHNuYXBEdXJDbGFtcC5taW4sIHNuYXBEdXJDbGFtcC5tYXgpIDogX2NsYW1wKHNuYXBEdXJDbGFtcCwgc25hcER1ckNsYW1wKTtcbiAgICAgIHNuYXBEZWxheWVkQ2FsbCA9IGdzYXAuZGVsYXllZENhbGwoc25hcC5kZWxheSB8fCBzY3J1YlNtb290aCAvIDIgfHwgMC4xLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGwgPSBzY3JvbGxGdW5jKCksXG4gICAgICAgICAgICByZWZyZXNoZWRSZWNlbnRseSA9IF9nZXRUaW1lKCkgLSBsYXN0UmVmcmVzaCA8IDUwMCxcbiAgICAgICAgICAgIHR3ZWVuID0gdHdlZW5Uby50d2VlbjtcblxuICAgICAgICBpZiAoKHJlZnJlc2hlZFJlY2VudGx5IHx8IE1hdGguYWJzKHNlbGYuZ2V0VmVsb2NpdHkoKSkgPCAxMCkgJiYgIXR3ZWVuICYmICFfcG9pbnRlcklzRG93biAmJiBsYXN0U25hcCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgdmFyIHByb2dyZXNzID0gKHNjcm9sbCAtIHN0YXJ0KSAvIGNoYW5nZSxcbiAgICAgICAgICAgICAgdG90YWxQcm9ncmVzcyA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogcHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHZlbG9jaXR5ID0gcmVmcmVzaGVkUmVjZW50bHkgPyAwIDogKHRvdGFsUHJvZ3Jlc3MgLSBzbmFwMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiAxMDAwIHx8IDAsXG4gICAgICAgICAgICAgIGNoYW5nZTEgPSBnc2FwLnV0aWxzLmNsYW1wKC1wcm9ncmVzcywgMSAtIHByb2dyZXNzLCBfYWJzKHZlbG9jaXR5IC8gMikgKiB2ZWxvY2l0eSAvIDAuMTg1KSxcbiAgICAgICAgICAgICAgbmF0dXJhbEVuZCA9IHByb2dyZXNzICsgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UgPyAwIDogY2hhbmdlMSksXG4gICAgICAgICAgICAgIGVuZFZhbHVlLFxuICAgICAgICAgICAgICBlbmRTY3JvbGwsXG4gICAgICAgICAgICAgIF9zbmFwID0gc25hcCxcbiAgICAgICAgICAgICAgb25TdGFydCA9IF9zbmFwLm9uU3RhcnQsXG4gICAgICAgICAgICAgIF9vbkludGVycnVwdCA9IF9zbmFwLm9uSW50ZXJydXB0LFxuICAgICAgICAgICAgICBfb25Db21wbGV0ZSA9IF9zbmFwLm9uQ29tcGxldGU7XG4gICAgICAgICAgZW5kVmFsdWUgPSBzbmFwRnVuYyhuYXR1cmFsRW5kLCBzZWxmKTtcbiAgICAgICAgICBfaXNOdW1iZXIoZW5kVmFsdWUpIHx8IChlbmRWYWx1ZSA9IG5hdHVyYWxFbmQpOyAvLyBpbiBjYXNlIHRoZSBmdW5jdGlvbiBkaWRuJ3QgcmV0dXJuIGEgbnVtYmVyLCBmYWxsIGJhY2sgdG8gdXNpbmcgdGhlIG5hdHVyYWxFbmRcblxuICAgICAgICAgIGVuZFNjcm9sbCA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoc3RhcnQgKyBlbmRWYWx1ZSAqIGNoYW5nZSkpO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbCA8PSBlbmQgJiYgc2Nyb2xsID49IHN0YXJ0ICYmIGVuZFNjcm9sbCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgICBpZiAodHdlZW4gJiYgIXR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmRhdGEgPD0gX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW4gb3ZlcmxhcHBpbmcgc25hcCEgU28gd2UgbXVzdCBmaWd1cmUgb3V0IHdoaWNoIG9uZSBpcyBjbG9zZXIgYW5kIGxldCB0aGF0IHR3ZWVuIGxpdmUuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY2hhbmdlMSA9IGVuZFZhbHVlIC0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHR3ZWVuVG8oZW5kU2Nyb2xsLCB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBzbmFwRHVyQ2xhbXAoX2FicyhNYXRoLm1heChfYWJzKG5hdHVyYWxFbmQgLSB0b3RhbFByb2dyZXNzKSwgX2FicyhlbmRWYWx1ZSAtIHRvdGFsUHJvZ3Jlc3MpKSAqIDAuMTg1IC8gdmVsb2NpdHkgLyAwLjA1IHx8IDApKSxcbiAgICAgICAgICAgICAgZWFzZTogc25hcC5lYXNlIHx8IFwicG93ZXIzXCIsXG4gICAgICAgICAgICAgIGRhdGE6IF9hYnMoZW5kU2Nyb2xsIC0gc2Nyb2xsKSxcbiAgICAgICAgICAgICAgLy8gcmVjb3JkIHRoZSBkaXN0YW5jZSBzbyB0aGF0IGlmIGFub3RoZXIgc25hcCB0d2VlbiBvY2N1cnMgKGNvbmZsaWN0KSB3ZSBjYW4gcHJpb3JpdGl6ZSB0aGUgY2xvc2VzdCBzbmFwLlxuICAgICAgICAgICAgICBvbkludGVycnVwdDogZnVuY3Rpb24gb25JbnRlcnJ1cHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpICYmIF9vbkludGVycnVwdCAmJiBfb25JbnRlcnJ1cHQoc2VsZik7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBsYXN0U25hcCA9IHNjcm9sbEZ1bmMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24gJiYgIWlzVG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAvLyB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgc2Nyb2xsYmFyIGlzIGxpbWl0ZWQsIHNvIHdlIHNob3VsZCBjb3JyZWN0IHRoZSBzY3J1YmJlZCBhbmltYXRpb24ncyBwbGF5aGVhZCBhdCB0aGUgZW5kIHRvIG1hdGNoIEVYQUNUTFkgd2hlcmUgaXQgd2FzIHN1cHBvc2VkIHRvIHNuYXBcbiAgICAgICAgICAgICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnJlc2V0VG8oXCJ0b3RhbFByb2dyZXNzXCIsIGVuZFZhbHVlLCBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyKSA6IGFuaW1hdGlvbi5wcm9ncmVzcyhlbmRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc25hcDEgPSBzbmFwMiA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogc2VsZi5wcm9ncmVzcztcbiAgICAgICAgICAgICAgICBvblNuYXBDb21wbGV0ZSAmJiBvblNuYXBDb21wbGV0ZShzZWxmKTtcbiAgICAgICAgICAgICAgICBfb25Db21wbGV0ZSAmJiBfb25Db21wbGV0ZShzZWxmKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc2Nyb2xsLCBjaGFuZ2UxICogY2hhbmdlLCBlbmRTY3JvbGwgLSBzY3JvbGwgLSBjaGFuZ2UxICogY2hhbmdlKTtcbiAgICAgICAgICAgIG9uU3RhcnQgJiYgb25TdGFydChzZWxmLCB0d2VlblRvLnR3ZWVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5pc0FjdGl2ZSAmJiBsYXN0U25hcCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgaWQgJiYgKF9pZHNbaWRdID0gc2VsZik7XG4gICAgdHJpZ2dlciA9IHNlbGYudHJpZ2dlciA9IF9nZXRUYXJnZXQodHJpZ2dlciB8fCBwaW4gIT09IHRydWUgJiYgcGluKTsgLy8gaWYgYSB0cmlnZ2VyIGhhcyBzb21lIGtpbmQgb2Ygc2Nyb2xsLXJlbGF0ZWQgZWZmZWN0IGFwcGxpZWQgdGhhdCBjb3VsZCBjb250YW1pbmF0ZSB0aGUgXCJ5XCIgb3IgXCJ4XCIgcG9zaXRpb24gKGxpa2UgYSBTY3JvbGxTbW9vdGhlciBlZmZlY3QpLCB3ZSBuZWVkZWQgYSB3YXkgdG8gdGVtcG9yYXJpbHkgcmV2ZXJ0IGl0LCBzbyB3ZSB1c2UgdGhlIHN0UmV2ZXJ0IHByb3BlcnR5IG9mIHRoZSBnc0NhY2hlLiBJdCBjYW4gcmV0dXJuIGFub3RoZXIgZnVuY3Rpb24gdGhhdCB3ZSdsbCBjYWxsIGF0IHRoZSBlbmQgc28gaXQgY2FuIHJldHVybiB0byBpdHMgbm9ybWFsIHN0YXRlLlxuXG4gICAgY3VzdG9tUmV2ZXJ0UmV0dXJuID0gdHJpZ2dlciAmJiB0cmlnZ2VyLl9nc2FwICYmIHRyaWdnZXIuX2dzYXAuc3RSZXZlcnQ7XG4gICAgY3VzdG9tUmV2ZXJ0UmV0dXJuICYmIChjdXN0b21SZXZlcnRSZXR1cm4gPSBjdXN0b21SZXZlcnRSZXR1cm4oc2VsZikpO1xuICAgIHBpbiA9IHBpbiA9PT0gdHJ1ZSA/IHRyaWdnZXIgOiBfZ2V0VGFyZ2V0KHBpbik7XG4gICAgX2lzU3RyaW5nKHRvZ2dsZUNsYXNzKSAmJiAodG9nZ2xlQ2xhc3MgPSB7XG4gICAgICB0YXJnZXRzOiB0cmlnZ2VyLFxuICAgICAgY2xhc3NOYW1lOiB0b2dnbGVDbGFzc1xuICAgIH0pO1xuXG4gICAgaWYgKHBpbikge1xuICAgICAgcGluU3BhY2luZyA9PT0gZmFsc2UgfHwgcGluU3BhY2luZyA9PT0gX21hcmdpbiB8fCAocGluU3BhY2luZyA9ICFwaW5TcGFjaW5nICYmIHBpbi5wYXJlbnROb2RlICYmIHBpbi5wYXJlbnROb2RlLnN0eWxlICYmIF9nZXRDb21wdXRlZFN0eWxlKHBpbi5wYXJlbnROb2RlKS5kaXNwbGF5ID09PSBcImZsZXhcIiA/IGZhbHNlIDogX3BhZGRpbmcpOyAvLyBpZiB0aGUgcGFyZW50IGlzIGRpc3BsYXk6IGZsZXgsIGRvbid0IGFwcGx5IHBpblNwYWNpbmcgYnkgZGVmYXVsdC4gV2Ugc2hvdWxkIGNoZWNrIHRoYXQgcGluLnBhcmVudE5vZGUgaXMgYW4gZWxlbWVudCAobm90IHNoYWRvdyBkb20gd2luZG93KVxuXG4gICAgICBzZWxmLnBpbiA9IHBpbjtcbiAgICAgIHBpbkNhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHBpbik7XG5cbiAgICAgIGlmICghcGluQ2FjaGUuc3BhY2VyKSB7XG4gICAgICAgIC8vIHJlY29yZCB0aGUgc3BhY2VyIGFuZCBwaW5PcmlnaW5hbFN0YXRlIG9uIHRoZSBjYWNoZSBpbiBjYXNlIHNvbWVvbmUgdHJpZXMgcGlubmluZyB0aGUgc2FtZSBlbGVtZW50IHdpdGggTVVMVElQTEUgU2Nyb2xsVHJpZ2dlcnMgLSB3ZSBkb24ndCB3YW50IHRvIGhhdmUgbXVsdGlwbGUgc3BhY2VycyBvciByZWNvcmQgdGhlIFwib3JpZ2luYWxcIiBwaW4gc3RhdGUgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhZmZlY3RlZCBieSBhbm90aGVyIFNjcm9sbFRyaWdnZXIuXG4gICAgICAgIGlmIChwaW5TcGFjZXIpIHtcbiAgICAgICAgICBwaW5TcGFjZXIgPSBfZ2V0VGFyZ2V0KHBpblNwYWNlcik7XG4gICAgICAgICAgcGluU3BhY2VyICYmICFwaW5TcGFjZXIubm9kZVR5cGUgJiYgKHBpblNwYWNlciA9IHBpblNwYWNlci5jdXJyZW50IHx8IHBpblNwYWNlci5uYXRpdmVFbGVtZW50KTsgLy8gZm9yIFJlYWN0ICYgQW5ndWxhclxuXG4gICAgICAgICAgcGluQ2FjaGUuc3BhY2VySXNOYXRpdmUgPSAhIXBpblNwYWNlcjtcbiAgICAgICAgICBwaW5TcGFjZXIgJiYgKHBpbkNhY2hlLnNwYWNlclN0YXRlID0gX2dldFN0YXRlKHBpblNwYWNlcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGluQ2FjaGUuc3BhY2VyID0gc3BhY2VyID0gcGluU3BhY2VyIHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgc3BhY2VyLmNsYXNzTGlzdC5hZGQoXCJwaW4tc3BhY2VyXCIpO1xuICAgICAgICBpZCAmJiBzcGFjZXIuY2xhc3NMaXN0LmFkZChcInBpbi1zcGFjZXItXCIgKyBpZCk7XG4gICAgICAgIHBpbkNhY2hlLnBpblN0YXRlID0gcGluT3JpZ2luYWxTdGF0ZSA9IF9nZXRTdGF0ZShwaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGluT3JpZ2luYWxTdGF0ZSA9IHBpbkNhY2hlLnBpblN0YXRlO1xuICAgICAgfVxuXG4gICAgICB2YXJzLmZvcmNlM0QgIT09IGZhbHNlICYmIGdzYXAuc2V0KHBpbiwge1xuICAgICAgICBmb3JjZTNEOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHNlbGYuc3BhY2VyID0gc3BhY2VyID0gcGluQ2FjaGUuc3BhY2VyO1xuICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pO1xuICAgICAgc3BhY2luZ1N0YXJ0ID0gY3NbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczJdO1xuICAgICAgcGluR2V0dGVyID0gZ3NhcC5nZXRQcm9wZXJ0eShwaW4pO1xuICAgICAgcGluU2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihwaW4sIGRpcmVjdGlvbi5hLCBfcHgpOyAvLyBwaW4uZmlyc3RDaGlsZCAmJiAhX21heFNjcm9sbChwaW4sIGRpcmVjdGlvbikgJiYgKHBpbi5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIpOyAvLyBwcm90ZWN0cyBmcm9tIGNvbGxhcHNpbmcgbWFyZ2lucywgYnV0IGNhbiBoYXZlIHVuaW50ZW5kZWQgY29uc2VxdWVuY2VzIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi8xZTQyYzdhNzNiZmE0MDlkMmNmMWUxODRlN2E0MjQ4ZCBzbyBpdCB3YXMgcmVtb3ZlZCBpbiBmYXZvciBvZiBqdXN0IHRlbGxpbmcgcGVvcGxlIHRvIHNldCB1cCB0aGVpciBDU1MgdG8gYXZvaWQgdGhlIGNvbGxhcHNpbmcgbWFyZ2lucyAob3ZlcmZsb3c6IGhpZGRlbiB8IGF1dG8gaXMganVzdCBvbmUgb3B0aW9uLiBBbm90aGVyIGlzIGJvcmRlci10b3A6IDFweCBzb2xpZCB0cmFuc3BhcmVudCkuXG5cbiAgICAgIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzKTtcblxuICAgICAgcGluU3RhdGUgPSBfZ2V0U3RhdGUocGluKTtcbiAgICB9XG5cbiAgICBpZiAobWFya2Vycykge1xuICAgICAgbWFya2VyVmFycyA9IF9pc09iamVjdChtYXJrZXJzKSA/IF9zZXREZWZhdWx0cyhtYXJrZXJzLCBfbWFya2VyRGVmYXVsdHMpIDogX21hcmtlckRlZmF1bHRzO1xuICAgICAgbWFya2VyU3RhcnRUcmlnZ2VyID0gX2NyZWF0ZU1hcmtlcihcInNjcm9sbGVyLXN0YXJ0XCIsIGlkLCBzY3JvbGxlciwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCAwKTtcbiAgICAgIG1hcmtlckVuZFRyaWdnZXIgPSBfY3JlYXRlTWFya2VyKFwic2Nyb2xsZXItZW5kXCIsIGlkLCBzY3JvbGxlciwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCAwLCBtYXJrZXJTdGFydFRyaWdnZXIpO1xuICAgICAgb2Zmc2V0ID0gbWFya2VyU3RhcnRUcmlnZ2VyW1wib2Zmc2V0XCIgKyBkaXJlY3Rpb24ub3AuZDJdO1xuXG4gICAgICB2YXIgY29udGVudCA9IF9nZXRUYXJnZXQoX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJjb250ZW50XCIpIHx8IHNjcm9sbGVyKTtcblxuICAgICAgbWFya2VyU3RhcnQgPSB0aGlzLm1hcmtlclN0YXJ0ID0gX2NyZWF0ZU1hcmtlcihcInN0YXJ0XCIsIGlkLCBjb250ZW50LCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIG9mZnNldCwgMCwgY29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgIG1hcmtlckVuZCA9IHRoaXMubWFya2VyRW5kID0gX2NyZWF0ZU1hcmtlcihcImVuZFwiLCBpZCwgY29udGVudCwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCBvZmZzZXQsIDAsIGNvbnRhaW5lckFuaW1hdGlvbik7XG4gICAgICBjb250YWluZXJBbmltYXRpb24gJiYgKGNhTWFya2VyU2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihbbWFya2VyU3RhcnQsIG1hcmtlckVuZF0sIGRpcmVjdGlvbi5hLCBfcHgpKTtcblxuICAgICAgaWYgKCF1c2VGaXhlZFBvc2l0aW9uICYmICEoX3Byb3hpZXMubGVuZ3RoICYmIF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiZml4ZWRNYXJrZXJzXCIpID09PSB0cnVlKSkge1xuICAgICAgICBfbWFrZVBvc2l0aW9uYWJsZShpc1ZpZXdwb3J0ID8gX2JvZHkgOiBzY3JvbGxlcik7XG5cbiAgICAgICAgZ3NhcC5zZXQoW21hcmtlclN0YXJ0VHJpZ2dlciwgbWFya2VyRW5kVHJpZ2dlcl0sIHtcbiAgICAgICAgICBmb3JjZTNEOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrZXJTdGFydFNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIobWFya2VyU3RhcnRUcmlnZ2VyLCBkaXJlY3Rpb24uYSwgX3B4KTtcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihtYXJrZXJFbmRUcmlnZ2VyLCBkaXJlY3Rpb24uYSwgX3B4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICB2YXIgb2xkT25VcGRhdGUgPSBjb250YWluZXJBbmltYXRpb24udmFycy5vblVwZGF0ZSxcbiAgICAgICAgICBvbGRQYXJhbXMgPSBjb250YWluZXJBbmltYXRpb24udmFycy5vblVwZGF0ZVBhcmFtcztcbiAgICAgIGNvbnRhaW5lckFuaW1hdGlvbi5ldmVudENhbGxiYWNrKFwib25VcGRhdGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnVwZGF0ZSgwLCAwLCAxKTtcbiAgICAgICAgb2xkT25VcGRhdGUgJiYgb2xkT25VcGRhdGUuYXBwbHkoY29udGFpbmVyQW5pbWF0aW9uLCBvbGRQYXJhbXMgfHwgW10pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZi5wcmV2aW91cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdHJpZ2dlcnNbX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikgLSAxXTtcbiAgICB9O1xuXG4gICAgc2VsZi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90cmlnZ2Vyc1tfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSArIDFdO1xuICAgIH07XG5cbiAgICBzZWxmLnJldmVydCA9IGZ1bmN0aW9uIChyZXZlcnQsIHRlbXApIHtcbiAgICAgIGlmICghdGVtcCkge1xuICAgICAgICByZXR1cm4gc2VsZi5raWxsKHRydWUpO1xuICAgICAgfSAvLyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGdzYXAuY29udGV4dCgpIGFuZCBnc2FwLm1hdGNoTWVkaWEoKSB3aGljaCBjYWxsIHJldmVydCgpXG5cblxuICAgICAgdmFyIHIgPSByZXZlcnQgIT09IGZhbHNlIHx8ICFzZWxmLmVuYWJsZWQsXG4gICAgICAgICAgcHJldlJlZnJlc2hpbmcgPSBfcmVmcmVzaGluZztcblxuICAgICAgaWYgKHIgIT09IHNlbGYuaXNSZXZlcnRlZCkge1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHByZXZTY3JvbGwgPSBNYXRoLm1heChzY3JvbGxGdW5jKCksIHNlbGYuc2Nyb2xsLnJlYyB8fCAwKTsgLy8gcmVjb3JkIHRoZSBzY3JvbGwgc28gd2UgY2FuIHJldmVydCBsYXRlciAocmVwb3NpdGlvbmluZy9waW5uaW5nIHRoaW5ncyBjYW4gYWZmZWN0IHNjcm9sbCBwb3NpdGlvbikuIEluIHRoZSBzdGF0aWMgcmVmcmVzaCgpIG1ldGhvZCwgd2UgZmlyc3QgcmVjb3JkIGFsbCB0aGUgc2Nyb2xsIHBvc2l0aW9ucyBhcyBhIHJlZmVyZW5jZS5cblxuICAgICAgICAgIHByZXZQcm9ncmVzcyA9IHNlbGYucHJvZ3Jlc3M7XG4gICAgICAgICAgcHJldkFuaW1Qcm9ncmVzcyA9IGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucHJvZ3Jlc3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtlclN0YXJ0ICYmIFttYXJrZXJTdGFydCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5zdHlsZS5kaXNwbGF5ID0gciA/IFwibm9uZVwiIDogXCJibG9ja1wiO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocikge1xuICAgICAgICAgIF9yZWZyZXNoaW5nID0gc2VsZjtcbiAgICAgICAgICBzZWxmLnVwZGF0ZShyKTsgLy8gbWFrZSBzdXJlIHRoZSBwaW4gaXMgYmFjayBpbiBpdHMgb3JpZ2luYWwgcG9zaXRpb24gc28gdGhhdCBhbGwgdGhlIG1lYXN1cmVtZW50cyBhcmUgY29ycmVjdC4gZG8gdGhpcyBCRUZPUkUgc3dhcHBpbmcgdGhlIHBpbiBvdXRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaW4gJiYgKCFwaW5SZXBhcmVudCB8fCAhc2VsZi5pc0FjdGl2ZSkpIHtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgX3N3YXBQaW5PdXQocGluLCBzcGFjZXIsIHBpbk9yaWdpbmFsU3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pLCBzcGFjZXJTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgciB8fCBzZWxmLnVwZGF0ZShyKTsgLy8gd2hlbiB3ZSdyZSByZXN0b3JpbmcsIHRoZSB1cGRhdGUgc2hvdWxkIHJ1biBBRlRFUiBzd2FwcGluZyB0aGUgcGluIGludG8gaXRzIHBpbi1zcGFjZXIuXG5cbiAgICAgICAgX3JlZnJlc2hpbmcgPSBwcmV2UmVmcmVzaGluZzsgLy8gcmVzdG9yZS4gV2Ugc2V0IGl0IHRvIHRydWUgZHVyaW5nIHRoZSB1cGRhdGUoKSBzbyB0aGF0IHRoaW5ncyBmaXJlIHByb3Blcmx5IGluIHRoZXJlLlxuXG4gICAgICAgIHNlbGYuaXNSZXZlcnRlZCA9IHI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uIChzb2Z0LCBmb3JjZSwgcG9zaXRpb24sIHBpbk9mZnNldCkge1xuICAgICAgLy8gcG9zaXRpb24gaXMgdHlwaWNhbGx5IG9ubHkgZGVmaW5lZCBpZiBpdCdzIGNvbWluZyBmcm9tIHNldFBvc2l0aW9ucygpIC0gaXQncyBhIHdheSB0byBza2lwIHRoZSBub3JtYWwgcGFyc2luZy4gcGluT2Zmc2V0IGlzIGFsc28gb25seSBmcm9tIHNldFBvc2l0aW9ucygpIGFuZCBpcyBtb3N0bHkgcmVsYXRlZCB0byBmYW5jeSBzdHVmZiB3ZSBuZWVkIHRvIGRvIGluIFNjcm9sbFNtb290aGVyIHdpdGggZWZmZWN0c1xuICAgICAgaWYgKChfcmVmcmVzaGluZyB8fCAhc2VsZi5lbmFibGVkKSAmJiAhZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluICYmIHNvZnQgJiYgX2xhc3RTY3JvbGxUaW1lKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgIV9yZWZyZXNoaW5nQWxsICYmIG9uUmVmcmVzaEluaXQgJiYgb25SZWZyZXNoSW5pdChzZWxmKTtcbiAgICAgIF9yZWZyZXNoaW5nID0gc2VsZjtcblxuICAgICAgaWYgKHR3ZWVuVG8udHdlZW4gJiYgIXBvc2l0aW9uKSB7XG4gICAgICAgIC8vIHdlIHNraXAgdGhpcyBpZiBhIHBvc2l0aW9uIGlzIHBhc3NlZCBpbiBiZWNhdXNlIHR5cGljYWxseSB0aGF0J3MgZnJvbSAuc2V0UG9zaXRpb25zKCkgYW5kIGl0J3MgYmVzdCB0byBhbGxvdyBpbi1wcm9ncmVzcyBzbmFwcGluZyB0byBjb250aW51ZS5cbiAgICAgICAgdHdlZW5Uby50d2Vlbi5raWxsKCk7XG4gICAgICAgIHR3ZWVuVG8udHdlZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucGF1c2UoKTtcbiAgICAgIGludmFsaWRhdGVPblJlZnJlc2ggJiYgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5yZXZlcnQoe1xuICAgICAgICBraWxsOiBmYWxzZVxuICAgICAgfSkuaW52YWxpZGF0ZSgpO1xuICAgICAgc2VsZi5pc1JldmVydGVkIHx8IHNlbGYucmV2ZXJ0KHRydWUsIHRydWUpO1xuICAgICAgc2VsZi5fc3ViUGluT2Zmc2V0ID0gZmFsc2U7IC8vIHdlJ2xsIHNldCB0aGlzIHRvIHRydWUgaW4gdGhlIHN1Yi1waW5zIGlmIHdlIGZpbmQgYW55XG5cbiAgICAgIHZhciBzaXplID0gZ2V0U2Nyb2xsZXJTaXplKCksXG4gICAgICAgICAgc2Nyb2xsZXJCb3VuZHMgPSBnZXRTY3JvbGxlck9mZnNldHMoKSxcbiAgICAgICAgICBtYXggPSBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSA6IF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXG4gICAgICAgICAgaXNGaXJzdFJlZnJlc2ggPSBjaGFuZ2UgPD0gMC4wMSxcbiAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgIG90aGVyUGluT2Zmc2V0ID0gcGluT2Zmc2V0IHx8IDAsXG4gICAgICAgICAgcGFyc2VkRW5kID0gX2lzT2JqZWN0KHBvc2l0aW9uKSA/IHBvc2l0aW9uLmVuZCA6IHZhcnMuZW5kLFxuICAgICAgICAgIHBhcnNlZEVuZFRyaWdnZXIgPSB2YXJzLmVuZFRyaWdnZXIgfHwgdHJpZ2dlcixcbiAgICAgICAgICBwYXJzZWRTdGFydCA9IF9pc09iamVjdChwb3NpdGlvbikgPyBwb3NpdGlvbi5zdGFydCA6IHZhcnMuc3RhcnQgfHwgKHZhcnMuc3RhcnQgPT09IDAgfHwgIXRyaWdnZXIgPyAwIDogcGluID8gXCIwIDBcIiA6IFwiMCAxMDAlXCIpLFxuICAgICAgICAgIHBpbm5lZENvbnRhaW5lciA9IHNlbGYucGlubmVkQ29udGFpbmVyID0gdmFycy5waW5uZWRDb250YWluZXIgJiYgX2dldFRhcmdldCh2YXJzLnBpbm5lZENvbnRhaW5lciwgc2VsZiksXG4gICAgICAgICAgdHJpZ2dlckluZGV4ID0gdHJpZ2dlciAmJiBNYXRoLm1heCgwLCBfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSkgfHwgMCxcbiAgICAgICAgICBpID0gdHJpZ2dlckluZGV4LFxuICAgICAgICAgIGNzLFxuICAgICAgICAgIGJvdW5kcyxcbiAgICAgICAgICBzY3JvbGwsXG4gICAgICAgICAgaXNWZXJ0aWNhbCxcbiAgICAgICAgICBvdmVycmlkZSxcbiAgICAgICAgICBjdXJUcmlnZ2VyLFxuICAgICAgICAgIGN1clBpbixcbiAgICAgICAgICBvcHBvc2l0ZVNjcm9sbCxcbiAgICAgICAgICBpbml0dGVkLFxuICAgICAgICAgIHJldmVydGVkUGlucyxcbiAgICAgICAgICBmb3JjZWRPdmVyZmxvdyxcbiAgICAgICAgICBtYXJrZXJTdGFydE9mZnNldCxcbiAgICAgICAgICBtYXJrZXJFbmRPZmZzZXQ7XG5cbiAgICAgIGlmIChtYXJrZXJzICYmIF9pc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgLy8gaWYgd2UgYWx0ZXIgdGhlIHN0YXJ0L2VuZCBwb3NpdGlvbnMgd2l0aCAuc2V0UG9zaXRpb25zKCksIGl0IGdlbmVyYWxseSBmZWVkcyBpbiBhYnNvbHV0ZSBOVU1CRVJTIHdoaWNoIGRvbid0IGNvbnZleSBpbmZvcm1hdGlvbiBhYm91dCB3aGVyZSB0byBsaW5lIHVwIHRoZSBtYXJrZXJzLCBzbyB0byBrZWVwIGl0IGludHVpdGl2ZSwgd2UgcmVjb3JkIGhvdyBmYXIgdGhlIHRyaWdnZXIgcG9zaXRpb25zIHNoaWZ0IGFmdGVyIGFwcGx5aW5nIHRoZSBuZXcgbnVtYmVycyBhbmQgdGhlbiBvZmZzZXQgYnkgdGhhdCBtdWNoIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uIFdlIGRvIHRoZSBzYW1lIHRvIHRoZSBhc3NvY2lhdGVkIHRyaWdnZXIgbWFya2VycyB0b28gb2YgY291cnNlLlxuICAgICAgICBtYXJrZXJTdGFydE9mZnNldCA9IGdzYXAuZ2V0UHJvcGVydHkobWFya2VyU3RhcnRUcmlnZ2VyLCBkaXJlY3Rpb24ucCk7XG4gICAgICAgIG1hcmtlckVuZE9mZnNldCA9IGdzYXAuZ2V0UHJvcGVydHkobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLnApO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAvLyB1c2VyIG1pZ2h0IHRyeSB0byBwaW4gdGhlIHNhbWUgZWxlbWVudCBtb3JlIHRoYW4gb25jZSwgc28gd2UgbXVzdCBmaW5kIGFueSBwcmlvciB0cmlnZ2VycyB3aXRoIHRoZSBzYW1lIHBpbiwgcmV2ZXJ0IHRoZW0sIGFuZCBkZXRlcm1pbmUgaG93IGxvbmcgdGhleSdyZSBwaW5uaW5nIHNvIHRoYXQgd2UgY2FuIG9mZnNldCB0aGluZ3MgYXBwcm9wcmlhdGVseS4gTWFrZSBzdXJlIHdlIHJldmVydCBmcm9tIGxhc3QgdG8gZmlyc3Qgc28gdGhhdCB0aGluZ3MgXCJyZXdpbmRcIiBwcm9wZXJseS5cbiAgICAgICAgY3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXTtcbiAgICAgICAgY3VyVHJpZ2dlci5lbmQgfHwgY3VyVHJpZ2dlci5yZWZyZXNoKDAsIDEpIHx8IChfcmVmcmVzaGluZyA9IHNlbGYpOyAvLyBpZiBpdCdzIGEgdGltZWxpbmUtYmFzZWQgdHJpZ2dlciB0aGF0IGhhc24ndCBiZWVuIGZ1bGx5IGluaXRpYWxpemVkIHlldCBiZWNhdXNlIGl0J3Mgd2FpdGluZyBmb3IgMSB0aWNrLCBqdXN0IGZvcmNlIHRoZSByZWZyZXNoKCkgaGVyZSwgb3RoZXJ3aXNlIGlmIGl0IGNvbnRhaW5zIGEgcGluIHRoYXQncyBzdXBwb3NlZCB0byBhZmZlY3Qgb3RoZXIgU2Nyb2xsVHJpZ2dlcnMgZnVydGhlciBkb3duIHRoZSBwYWdlLCB0aGV5IHdvbid0IGJlIGFkanVzdGVkIHByb3Blcmx5LlxuXG4gICAgICAgIGN1clBpbiA9IGN1clRyaWdnZXIucGluO1xuXG4gICAgICAgIGlmIChjdXJQaW4gJiYgKGN1clBpbiA9PT0gdHJpZ2dlciB8fCBjdXJQaW4gPT09IHBpbiB8fCBjdXJQaW4gPT09IHBpbm5lZENvbnRhaW5lcikgJiYgIWN1clRyaWdnZXIuaXNSZXZlcnRlZCkge1xuICAgICAgICAgIHJldmVydGVkUGlucyB8fCAocmV2ZXJ0ZWRQaW5zID0gW10pO1xuICAgICAgICAgIHJldmVydGVkUGlucy51bnNoaWZ0KGN1clRyaWdnZXIpOyAvLyB3ZSdsbCByZXZlcnQgZnJvbSBmaXJzdCB0byBsYXN0IHRvIG1ha2Ugc3VyZSB0aGluZ3MgcmVhY2ggdGhlaXIgZW5kIHN0YXRlIHByb3Blcmx5XG5cbiAgICAgICAgICBjdXJUcmlnZ2VyLnJldmVydCh0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJUcmlnZ2VyICE9PSBfdHJpZ2dlcnNbaV0pIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIGl0IGdvdCByZW1vdmVkLlxuICAgICAgICAgIHRyaWdnZXJJbmRleC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfaXNGdW5jdGlvbihwYXJzZWRTdGFydCkgJiYgKHBhcnNlZFN0YXJ0ID0gcGFyc2VkU3RhcnQoc2VsZikpO1xuICAgICAgcGFyc2VkU3RhcnQgPSBfcGFyc2VDbGFtcChwYXJzZWRTdGFydCwgXCJzdGFydFwiLCBzZWxmKTtcbiAgICAgIHN0YXJ0ID0gX3BhcnNlUG9zaXRpb24ocGFyc2VkU3RhcnQsIHRyaWdnZXIsIHNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsRnVuYygpLCBtYXJrZXJTdGFydCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIG1heCwgY29udGFpbmVyQW5pbWF0aW9uLCBzZWxmLl9zdGFydENsYW1wICYmIFwiX3N0YXJ0Q2xhbXBcIikgfHwgKHBpbiA/IC0wLjAwMSA6IDApO1xuICAgICAgX2lzRnVuY3Rpb24ocGFyc2VkRW5kKSAmJiAocGFyc2VkRW5kID0gcGFyc2VkRW5kKHNlbGYpKTtcblxuICAgICAgaWYgKF9pc1N0cmluZyhwYXJzZWRFbmQpICYmICFwYXJzZWRFbmQuaW5kZXhPZihcIis9XCIpKSB7XG4gICAgICAgIGlmICh+cGFyc2VkRW5kLmluZGV4T2YoXCIgXCIpKSB7XG4gICAgICAgICAgcGFyc2VkRW5kID0gKF9pc1N0cmluZyhwYXJzZWRTdGFydCkgPyBwYXJzZWRTdGFydC5zcGxpdChcIiBcIilbMF0gOiBcIlwiKSArIHBhcnNlZEVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0VG9QeChwYXJzZWRFbmQuc3Vic3RyKDIpLCBzaXplKTtcbiAgICAgICAgICBwYXJzZWRFbmQgPSBfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQgOiAoY29udGFpbmVyQW5pbWF0aW9uID8gZ3NhcC51dGlscy5tYXBSYW5nZSgwLCBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSwgY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIuc3RhcnQsIGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmVuZCwgc3RhcnQpIDogc3RhcnQpICsgb2Zmc2V0OyAvLyBfcGFyc2VQb3NpdGlvbiB3b24ndCBmYWN0b3IgaW4gdGhlIG9mZnNldCBpZiB0aGUgc3RhcnQgaXMgYSBudW1iZXIsIHNvIGRvIGl0IGhlcmUuXG5cbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdHJpZ2dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXJzZWRFbmQgPSBfcGFyc2VDbGFtcChwYXJzZWRFbmQsIFwiZW5kXCIsIHNlbGYpO1xuICAgICAgZW5kID0gTWF0aC5tYXgoc3RhcnQsIF9wYXJzZVBvc2l0aW9uKHBhcnNlZEVuZCB8fCAocGFyc2VkRW5kVHJpZ2dlciA/IFwiMTAwJSAwXCIgOiBtYXgpLCBwYXJzZWRFbmRUcmlnZ2VyLCBzaXplLCBkaXJlY3Rpb24sIHNjcm9sbEZ1bmMoKSArIG9mZnNldCwgbWFya2VyRW5kLCBtYXJrZXJFbmRUcmlnZ2VyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIG1heCwgY29udGFpbmVyQW5pbWF0aW9uLCBzZWxmLl9lbmRDbGFtcCAmJiBcIl9lbmRDbGFtcFwiKSkgfHwgLTAuMDAxO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGkgPSB0cmlnZ2VySW5kZXg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXTtcbiAgICAgICAgY3VyUGluID0gY3VyVHJpZ2dlci5waW47XG5cbiAgICAgICAgaWYgKGN1clBpbiAmJiBjdXJUcmlnZ2VyLnN0YXJ0IC0gY3VyVHJpZ2dlci5fcGluUHVzaCA8PSBzdGFydCAmJiAhY29udGFpbmVyQW5pbWF0aW9uICYmIGN1clRyaWdnZXIuZW5kID4gMCkge1xuICAgICAgICAgIGNzID0gY3VyVHJpZ2dlci5lbmQgLSAoc2VsZi5fc3RhcnRDbGFtcCA/IE1hdGgubWF4KDAsIGN1clRyaWdnZXIuc3RhcnQpIDogY3VyVHJpZ2dlci5zdGFydCk7XG5cbiAgICAgICAgICBpZiAoKGN1clBpbiA9PT0gdHJpZ2dlciAmJiBjdXJUcmlnZ2VyLnN0YXJ0IC0gY3VyVHJpZ2dlci5fcGluUHVzaCA8IHN0YXJ0IHx8IGN1clBpbiA9PT0gcGlubmVkQ29udGFpbmVyKSAmJiBpc05hTihwYXJzZWRTdGFydCkpIHtcbiAgICAgICAgICAgIC8vIG51bWVyaWMgc3RhcnQgdmFsdWVzIHNob3VsZG4ndCBiZSBvZmZzZXQgYXQgYWxsIC0gdHJlYXQgdGhlbSBhcyBhYnNvbHV0ZVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGNzICogKDEgLSBjdXJUcmlnZ2VyLnByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJQaW4gPT09IHBpbiAmJiAob3RoZXJQaW5PZmZzZXQgKz0gY3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgICBzZWxmLl9zdGFydENsYW1wICYmIChzZWxmLl9zdGFydENsYW1wICs9IG9mZnNldCk7XG5cbiAgICAgIGlmIChzZWxmLl9lbmRDbGFtcCAmJiAhX3JlZnJlc2hpbmdBbGwpIHtcbiAgICAgICAgc2VsZi5fZW5kQ2xhbXAgPSBlbmQgfHwgLTAuMDAxO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbikpO1xuICAgICAgfVxuXG4gICAgICBjaGFuZ2UgPSBlbmQgLSBzdGFydCB8fCAoc3RhcnQgLT0gMC4wMSkgJiYgMC4wMDE7XG5cbiAgICAgIGlmIChpc0ZpcnN0UmVmcmVzaCkge1xuICAgICAgICAvLyBvbiB0aGUgdmVyeSBmaXJzdCByZWZyZXNoKCksIHRoZSBwcmV2UHJvZ3Jlc3MgY291bGRuJ3QgaGF2ZSBiZWVuIGFjY3VyYXRlIHlldCBiZWNhdXNlIHRoZSBzdGFydC9lbmQgd2VyZSBuZXZlciBjYWxjdWxhdGVkLCBzbyB3ZSBzZXQgaXQgaGVyZS4gQmVmb3JlIDMuMTEuNSwgaXQgY291bGQgbGVhZCB0byBhbiBpbmFjY3VyYXRlIHNjcm9sbCBwb3NpdGlvbiByZXN0b3JhdGlvbiB3aXRoIHNuYXBwaW5nLlxuICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBnc2FwLnV0aWxzLmNsYW1wKDAsIDEsIGdzYXAudXRpbHMubm9ybWFsaXplKHN0YXJ0LCBlbmQsIHByZXZTY3JvbGwpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fcGluUHVzaCA9IG90aGVyUGluT2Zmc2V0O1xuXG4gICAgICBpZiAobWFya2VyU3RhcnQgJiYgb2Zmc2V0KSB7XG4gICAgICAgIC8vIG9mZnNldCB0aGUgbWFya2VycyBpZiBuZWNlc3NhcnlcbiAgICAgICAgY3MgPSB7fTtcbiAgICAgICAgY3NbZGlyZWN0aW9uLmFdID0gXCIrPVwiICsgb2Zmc2V0O1xuICAgICAgICBwaW5uZWRDb250YWluZXIgJiYgKGNzW2RpcmVjdGlvbi5wXSA9IFwiLT1cIiArIHNjcm9sbEZ1bmMoKSk7XG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgY3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluICYmICEoX2NsYW1waW5nTWF4ICYmIHNlbGYuZW5kID49IF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbikpKSB7XG4gICAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcbiAgICAgICAgaXNWZXJ0aWNhbCA9IGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsO1xuICAgICAgICBzY3JvbGwgPSBzY3JvbGxGdW5jKCk7IC8vIHJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHRyaWdnZXJzIGNhbiBhZmZlY3QgdGhlIHNjcm9sbFxuXG4gICAgICAgIHBpblN0YXJ0ID0gcGFyc2VGbG9hdChwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpKSArIG90aGVyUGluT2Zmc2V0O1xuXG4gICAgICAgIGlmICghbWF4ICYmIGVuZCA+IDEpIHtcbiAgICAgICAgICAvLyBtYWtlcyBzdXJlIHRoZSBzY3JvbGxlciBoYXMgYSBzY3JvbGxiYXIsIG90aGVyd2lzZSBpZiBzb21ldGhpbmcgaGFzIHdpZHRoOiAxMDAlLCBmb3IgZXhhbXBsZSwgaXQgd291bGQgYmUgdG9vIGJpZyAoZXhjbHVkZSB0aGUgc2Nyb2xsYmFyKS4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzI1MTgyLXNjcm9sbHRyaWdnZXItd2lkdGgtb2YtcGFnZS1pbmNyZWFzZS13aGVyZS1tYXJrZXJzLWFyZS1zZXQtdG8tZmFsc2UvXG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3cgPSAoaXNWaWV3cG9ydCA/IF9kb2Muc2Nyb2xsaW5nRWxlbWVudCB8fCBfZG9jRWwgOiBzY3JvbGxlcikuc3R5bGU7XG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3cgPSB7XG4gICAgICAgICAgICBzdHlsZTogZm9yY2VkT3ZlcmZsb3csXG4gICAgICAgICAgICB2YWx1ZTogZm9yY2VkT3ZlcmZsb3dbXCJvdmVyZmxvd1wiICsgZGlyZWN0aW9uLmEudG9VcHBlckNhc2UoKV1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGlzVmlld3BvcnQgJiYgX2dldENvbXB1dGVkU3R5bGUoX2JvZHkpW1wib3ZlcmZsb3dcIiArIGRpcmVjdGlvbi5hLnRvVXBwZXJDYXNlKCldICE9PSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBhbiBleHRyYSBzY3JvbGxiYXIgaWYgQk9USCA8aHRtbD4gYW5kIDxib2R5PiBoYXZlIG92ZXJmbG93IHNldCB0byBcInNjcm9sbFwiXG4gICAgICAgICAgICBmb3JjZWRPdmVyZmxvdy5zdHlsZVtcIm92ZXJmbG93XCIgKyBkaXJlY3Rpb24uYS50b1VwcGVyQ2FzZSgpXSA9IFwic2Nyb2xsXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xuXG4gICAgICAgIHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7IC8vIHRyYW5zZm9ybXMgd2lsbCBpbnRlcmZlcmUgd2l0aCB0aGUgdG9wL2xlZnQvcmlnaHQvYm90dG9tIHBsYWNlbWVudCwgc28gcmVtb3ZlIHRoZW0gdGVtcG9yYXJpbHkuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGZhY3RvcnMgaW4gdHJhbnNmb3Jtcy5cblxuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSk7XG4gICAgICAgIG9wcG9zaXRlU2Nyb2xsID0gdXNlRml4ZWRQb3NpdGlvbiAmJiBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgaXNWZXJ0aWNhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKSgpO1xuXG4gICAgICAgIGlmIChwaW5TcGFjaW5nKSB7XG4gICAgICAgICAgc3BhY2VyU3RhdGUgPSBbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczIsIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0ICsgX3B4XTtcbiAgICAgICAgICBzcGFjZXJTdGF0ZS50ID0gc3BhY2VyO1xuICAgICAgICAgIGkgPSBwaW5TcGFjaW5nID09PSBfcGFkZGluZyA/IF9nZXRTaXplKHBpbiwgZGlyZWN0aW9uKSArIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0IDogMDtcblxuICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBzcGFjZXJTdGF0ZS5wdXNoKGRpcmVjdGlvbi5kLCBpICsgX3B4KTsgLy8gZm9yIGJveC1zaXppbmc6IGJvcmRlci1ib3ggKG11c3QgaW5jbHVkZSBwYWRkaW5nKS5cblxuICAgICAgICAgICAgc3BhY2VyLnN0eWxlLmZsZXhCYXNpcyAhPT0gXCJhdXRvXCIgJiYgKHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgPSBpICsgX3B4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuXG4gICAgICAgICAgaWYgKHBpbm5lZENvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gaW4gU2Nyb2xsVHJpZ2dlci5yZWZyZXNoKCksIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhlIHBpbkNvbnRhaW5lcidzIHNpemUgYmVjYXVzZSB0aGlzIHBpblNwYWNpbmcgbWF5IHN0cmV0Y2ggaXQgb3V0LCBidXQgd2UgY2FuJ3QganVzdCBhZGQgdGhlIGV4YWN0IGRpc3RhbmNlIGJlY2F1c2UgZGVwZW5kaW5nIG9uIGxheW91dCwgaXQgbWF5IG5vdCBwdXNoIHRoaW5ncyBkb3duIG9yIGl0IG1heSBvbmx5IGRvIHNvIHBhcnRpYWxseS5cbiAgICAgICAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIGlmICh0LnBpbiA9PT0gcGlubmVkQ29udGFpbmVyICYmIHQudmFycy5waW5TcGFjaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHQuX3N1YlBpbk9mZnNldCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgc2Nyb2xsRnVuYyhwcmV2U2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gX2dldFNpemUocGluLCBkaXJlY3Rpb24pO1xuICAgICAgICAgIGkgJiYgc3BhY2VyLnN0eWxlLmZsZXhCYXNpcyAhPT0gXCJhdXRvXCIgJiYgKHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgPSBpICsgX3B4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VGaXhlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgb3ZlcnJpZGUgPSB7XG4gICAgICAgICAgICB0b3A6IGJvdW5kcy50b3AgKyAoaXNWZXJ0aWNhbCA/IHNjcm9sbCAtIHN0YXJ0IDogb3Bwb3NpdGVTY3JvbGwpICsgX3B4LFxuICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnQgKyAoaXNWZXJ0aWNhbCA/IG9wcG9zaXRlU2Nyb2xsIDogc2Nyb2xsIC0gc3RhcnQpICsgX3B4LFxuICAgICAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIG92ZXJyaWRlW193aWR0aF0gPSBvdmVycmlkZVtcIm1heFwiICsgX1dpZHRoXSA9IE1hdGguY2VpbChib3VuZHMud2lkdGgpICsgX3B4O1xuICAgICAgICAgIG92ZXJyaWRlW19oZWlnaHRdID0gb3ZlcnJpZGVbXCJtYXhcIiArIF9IZWlnaHRdID0gTWF0aC5jZWlsKGJvdW5kcy5oZWlnaHQpICsgX3B4O1xuICAgICAgICAgIG92ZXJyaWRlW19tYXJnaW5dID0gb3ZlcnJpZGVbX21hcmdpbiArIF9Ub3BdID0gb3ZlcnJpZGVbX21hcmdpbiArIF9SaWdodF0gPSBvdmVycmlkZVtfbWFyZ2luICsgX0JvdHRvbV0gPSBvdmVycmlkZVtfbWFyZ2luICsgX0xlZnRdID0gXCIwXCI7XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmddID0gY3NbX3BhZGRpbmddO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX1RvcF0gPSBjc1tfcGFkZGluZyArIF9Ub3BdO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX1JpZ2h0XSA9IGNzW19wYWRkaW5nICsgX1JpZ2h0XTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9Cb3R0b21dID0gY3NbX3BhZGRpbmcgKyBfQm90dG9tXTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9MZWZ0XSA9IGNzW19wYWRkaW5nICsgX0xlZnRdO1xuICAgICAgICAgIHBpbkFjdGl2ZVN0YXRlID0gX2NvcHlTdGF0ZShwaW5PcmlnaW5hbFN0YXRlLCBvdmVycmlkZSwgcGluUmVwYXJlbnQpO1xuICAgICAgICAgIF9yZWZyZXNoaW5nQWxsICYmIHNjcm9sbEZ1bmMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBtaWdodCBiZSBhZmZlY3RpbmcgdGhlIHRyYW5zZm9ybSwgc28gd2UgbXVzdCBqdW1wIHRvIHRoZSBlbmQsIGNoZWNrIHRoZSB2YWx1ZSwgYW5kIGNvbXBlbnNhdGUgYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgd2hlbiBpdCBiZWNvbWVzIHVucGlubmVkLCB0aGUgcGluU2V0dGVyKCkgd2lsbCBnZXQgc2V0IHRvIGEgdmFsdWUgdGhhdCBkb2Vzbid0IGluY2x1ZGUgd2hhdGV2ZXIgdGhlIGFuaW1hdGlvbiBkaWQuXG4gICAgICAgICAgaW5pdHRlZCA9IGFuaW1hdGlvbi5faW5pdHRlZDsgLy8gaWYgbm90LCB3ZSBtdXN0IGludmFsaWRhdGUoKSBhZnRlciB0aGlzIHN0ZXAsIG90aGVyd2lzZSBpdCBjb3VsZCBsb2NrIGluIHN0YXJ0aW5nIHZhbHVlcyBwcmVtYXR1cmVseS5cblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMSk7XG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKGFuaW1hdGlvbi5kdXJhdGlvbigpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBwaW5DaGFuZ2UgPSBwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpIC0gcGluU3RhcnQgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldDtcbiAgICAgICAgICBwaW5Nb3ZlcyA9IE1hdGguYWJzKGNoYW5nZSAtIHBpbkNoYW5nZSkgPiAxO1xuICAgICAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgcGluTW92ZXMgJiYgcGluQWN0aXZlU3RhdGUuc3BsaWNlKHBpbkFjdGl2ZVN0YXRlLmxlbmd0aCAtIDIsIDIpOyAvLyB0cmFuc2Zvcm0gaXMgdGhlIGxhc3QgcHJvcGVydHkvdmFsdWUgc2V0IGluIHRoZSBzdGF0ZSBBcnJheS4gU2luY2UgdGhlIGFuaW1hdGlvbiBpcyBjb250cm9sbGluZyB0aGF0LCB3ZSBzaG91bGQgb21pdCBpdC5cblxuICAgICAgICAgIGFuaW1hdGlvbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgaW5pdHRlZCB8fCBhbmltYXRpb24uaW52YWxpZGF0ZSh0cnVlKTtcbiAgICAgICAgICBhbmltYXRpb24ucGFyZW50IHx8IGFuaW1hdGlvbi50b3RhbFRpbWUoYW5pbWF0aW9uLnRvdGFsVGltZSgpKTsgLy8gaWYsIGZvciBleGFtcGxlLCBhIHRvZ2dsZUFjdGlvbiBjYWxsZWQgcGxheSgpIGFuZCB0aGVuIHJlZnJlc2goKSBoYXBwZW5zIGFuZCB3aGVuIHdlIHJlbmRlcigxKSBhYm92ZSwgaXQgd291bGQgY2F1c2UgdGhlIGFuaW1hdGlvbiB0byBjb21wbGV0ZSBhbmQgZ2V0IHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50LCBzbyB0aGlzIG1ha2VzIHN1cmUgaXQgZ2V0cyBwdXQgYmFjayBpbi5cblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGluQ2hhbmdlID0gY2hhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yY2VkT3ZlcmZsb3cgJiYgKGZvcmNlZE92ZXJmbG93LnZhbHVlID8gZm9yY2VkT3ZlcmZsb3cuc3R5bGVbXCJvdmVyZmxvd1wiICsgZGlyZWN0aW9uLmEudG9VcHBlckNhc2UoKV0gPSBmb3JjZWRPdmVyZmxvdy52YWx1ZSA6IGZvcmNlZE92ZXJmbG93LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwib3ZlcmZsb3ctXCIgKyBkaXJlY3Rpb24uYSkpO1xuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICYmIHNjcm9sbEZ1bmMoKSAmJiAhY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIC8vIGl0IG1heSBiZSBJTlNJREUgYSBwaW5uZWQgZWxlbWVudCwgc28gd2FsayB1cCB0aGUgdHJlZSBhbmQgbG9vayBmb3IgYW55IGVsZW1lbnRzIHdpdGggX3Bpbk9mZnNldCB0byBjb21wZW5zYXRlIGJlY2F1c2UgYW55dGhpbmcgd2l0aCBwaW5TcGFjaW5nIHRoYXQncyBhbHJlYWR5IHNjcm9sbGVkIHdvdWxkIHRocm93IG9mZiB0aGUgbWVhc3VyZW1lbnRzIGluIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIGJvdW5kcyA9IHRyaWdnZXIucGFyZW50Tm9kZTtcblxuICAgICAgICB3aGlsZSAoYm91bmRzICYmIGJvdW5kcyAhPT0gX2JvZHkpIHtcbiAgICAgICAgICBpZiAoYm91bmRzLl9waW5PZmZzZXQpIHtcbiAgICAgICAgICAgIHN0YXJ0IC09IGJvdW5kcy5fcGluT2Zmc2V0O1xuICAgICAgICAgICAgZW5kIC09IGJvdW5kcy5fcGluT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kcyA9IGJvdW5kcy5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldmVydGVkUGlucyAmJiByZXZlcnRlZFBpbnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5yZXZlcnQoZmFsc2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICBzZWxmLmVuZCA9IGVuZDtcbiAgICAgIHNjcm9sbDEgPSBzY3JvbGwyID0gX3JlZnJlc2hpbmdBbGwgPyBwcmV2U2Nyb2xsIDogc2Nyb2xsRnVuYygpOyAvLyByZXNldCB2ZWxvY2l0eVxuXG4gICAgICBpZiAoIWNvbnRhaW5lckFuaW1hdGlvbiAmJiAhX3JlZnJlc2hpbmdBbGwpIHtcbiAgICAgICAgc2Nyb2xsMSA8IHByZXZTY3JvbGwgJiYgc2Nyb2xsRnVuYyhwcmV2U2Nyb2xsKTtcbiAgICAgICAgc2VsZi5zY3JvbGwucmVjID0gMDtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yZXZlcnQoZmFsc2UsIHRydWUpO1xuICAgICAgbGFzdFJlZnJlc2ggPSBfZ2V0VGltZSgpO1xuXG4gICAgICBpZiAoc25hcERlbGF5ZWRDYWxsKSB7XG4gICAgICAgIGxhc3RTbmFwID0gLTE7IC8vIGp1c3Qgc28gc25hcHBpbmcgZ2V0cyByZS1lbmFibGVkLCBjbGVhciBvdXQgYW55IHJlY29yZGVkIGxhc3QgdmFsdWVcbiAgICAgICAgLy8gc2VsZi5pc0FjdGl2ZSAmJiBzY3JvbGxGdW5jKHN0YXJ0ICsgY2hhbmdlICogcHJldlByb2dyZXNzKTsgLy8gcHJldmlvdXNseSB0aGlzIGxpbmUgd2FzIGhlcmUgdG8gZW5zdXJlIHRoYXQgd2hlbiBzbmFwcGluZyBraWNrcyBpbiwgaXQncyBmcm9tIHRoZSBwcmV2aW91cyBwcm9ncmVzcyBidXQgaW4gc29tZSBjYXNlcyB0aGF0J3Mgbm90IGRlc2lyYWJsZSwgbGlrZSBhbiBhbGwtcGFnZSBTY3JvbGxUcmlnZ2VyIHdoZW4gbmV3IGNvbnRlbnQgZ2V0cyBhZGRlZCB0byB0aGUgcGFnZSwgdGhhdCdkIHRvdGFsbHkgY2hhbmdlIHRoZSBwcm9ncmVzcy5cblxuICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgX3JlZnJlc2hpbmcgPSAwO1xuICAgICAgYW5pbWF0aW9uICYmIGlzVG9nZ2xlICYmIChhbmltYXRpb24uX2luaXR0ZWQgfHwgcHJldkFuaW1Qcm9ncmVzcykgJiYgYW5pbWF0aW9uLnByb2dyZXNzKCkgIT09IHByZXZBbmltUHJvZ3Jlc3MgJiYgYW5pbWF0aW9uLnByb2dyZXNzKHByZXZBbmltUHJvZ3Jlc3MgfHwgMCwgdHJ1ZSkucmVuZGVyKGFuaW1hdGlvbi50aW1lKCksIHRydWUsIHRydWUpOyAvLyBtdXN0IGZvcmNlIGEgcmUtcmVuZGVyIGJlY2F1c2UgaWYgc2F2ZVN0eWxlcygpIHdhcyB1c2VkIG9uIHRoZSB0YXJnZXQocyksIHRoZSBzdHlsZXMgY291bGQgaGF2ZSBiZWVuIHdpcGVkIG91dCBkdXJpbmcgdGhlIHJlZnJlc2goKS5cblxuICAgICAgaWYgKGlzRmlyc3RSZWZyZXNoIHx8IHByZXZQcm9ncmVzcyAhPT0gc2VsZi5wcm9ncmVzcyB8fCBjb250YWluZXJBbmltYXRpb24gfHwgaW52YWxpZGF0ZU9uUmVmcmVzaCB8fCBhbmltYXRpb24gJiYgIWFuaW1hdGlvbi5faW5pdHRlZCkge1xuICAgICAgICAvLyBlbnN1cmVzIHRoYXQgdGhlIGRpcmVjdGlvbiBpcyBzZXQgcHJvcGVybHkgKHdoZW4gcmVmcmVzaGluZywgcHJvZ3Jlc3MgaXMgc2V0IGJhY2sgdG8gMCBpbml0aWFsbHksIHRoZW4gYmFjayBhZ2FpbiB0byB3aGVyZXZlciBpdCBuZWVkcyB0byBiZSkgYW5kIHRoYXQgY2FsbGJhY2tzIGFyZSB0cmlnZ2VyZWQuXG4gICAgICAgIGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgJiYgYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoY29udGFpbmVyQW5pbWF0aW9uICYmIHN0YXJ0IDwgLTAuMDAxICYmICFwcmV2UHJvZ3Jlc3MgPyBnc2FwLnV0aWxzLm5vcm1hbGl6ZShzdGFydCwgZW5kLCAwKSA6IHByZXZQcm9ncmVzcywgdHJ1ZSk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aGVyZSBhbmltYXRpb24gY2FsbGJhY2tzIGxpa2Ugb25TdGFydCBhcmVuJ3QgdHJpZ2dlcmVkLlxuXG4gICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBpc0ZpcnN0UmVmcmVzaCB8fCAoc2Nyb2xsMSAtIHN0YXJ0KSAvIGNoYW5nZSA9PT0gcHJldlByb2dyZXNzID8gMCA6IHByZXZQcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgcGluICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5fcGluT2Zmc2V0ID0gTWF0aC5yb3VuZChzZWxmLnByb2dyZXNzICogcGluQ2hhbmdlKSk7XG4gICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4uaW52YWxpZGF0ZSgpO1xuXG4gICAgICBpZiAoIWlzTmFOKG1hcmtlclN0YXJ0T2Zmc2V0KSkge1xuICAgICAgICAvLyBudW1iZXJzIHdlcmUgcGFzc2VkIGluIGZvciB0aGUgcG9zaXRpb24gd2hpY2ggYXJlIGFic29sdXRlLCBzbyBpbnN0ZWFkIG9mIGp1c3QgcHV0dGluZyB0aGUgbWFya2VycyBhdCB0aGUgdmVyeSBib3R0b20gb2YgdGhlIHZpZXdwb3J0LCB3ZSBmaWd1cmUgb3V0IGhvdyBmYXIgdGhleSBzaGlmdGVkIGRvd24gKGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhleSB3ZXJlIG9yaWdpbmFsbHkgcG9zaXRpb25lZCBpbiBjbG9zZXIgcmVsYXRpb24gdG8gdGhlIHRyaWdnZXIgZWxlbWVudCB3aXRoIHZhbHVlcyBsaWtlIFwidG9wXCIsIFwiY2VudGVyXCIsIGEgcGVyY2VudGFnZSBvciB3aGF0ZXZlciwgc28gd2Ugb2Zmc2V0IHRoYXQgbXVjaCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIHRvIGJhc2ljYWxseSByZXZlcnQgdGhlbSB0byB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdGh5IHdlcmUgYXQgcHJldmlvdXNseS5cbiAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQgLT0gZ3NhcC5nZXRQcm9wZXJ0eShtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbi5wKTtcbiAgICAgICAgbWFya2VyRW5kT2Zmc2V0IC09IGdzYXAuZ2V0UHJvcGVydHkobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLnApO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbiwgbWFya2VyU3RhcnRPZmZzZXQpO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJTdGFydCwgZGlyZWN0aW9uLCBtYXJrZXJTdGFydE9mZnNldCAtIChwaW5PZmZzZXQgfHwgMCkpO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJFbmRUcmlnZ2VyLCBkaXJlY3Rpb24sIG1hcmtlckVuZE9mZnNldCk7XG5cbiAgICAgICAgX3NoaWZ0TWFya2VyKG1hcmtlckVuZCwgZGlyZWN0aW9uLCBtYXJrZXJFbmRPZmZzZXQgLSAocGluT2Zmc2V0IHx8IDApKTtcbiAgICAgIH1cblxuICAgICAgaXNGaXJzdFJlZnJlc2ggJiYgIV9yZWZyZXNoaW5nQWxsICYmIHNlbGYudXBkYXRlKCk7IC8vIGVkZ2UgY2FzZSAtIHdoZW4geW91IHJlbG9hZCBhIHBhZ2Ugd2hlbiBpdCdzIGFscmVhZHkgc2Nyb2xsZWQgZG93biwgc29tZSBicm93c2VycyBmaXJlIGEgXCJzY3JvbGxcIiBldmVudCBiZWZvcmUgRE9NQ29udGVudExvYWRlZCwgdHJpZ2dlcmluZyBhbiB1cGRhdGVBbGwoKS4gSWYgd2UgZG9uJ3QgdXBkYXRlIHRoZSBzZWxmLnByb2dyZXNzIGFzIHBhcnQgb2YgcmVmcmVzaCgpLCB0aGVuIHdoZW4gaXQgaGFwcGVucyBuZXh0LCBpdCBtYXkgcmVjb3JkIHByZXZQcm9ncmVzcyBhcyAwIHdoZW4gaXQgcmVhbGx5IHNob3VsZG4ndCwgcG90ZW50aWFsbHkgY2F1c2luZyBhIGNhbGxiYWNrIGluIGFuIGFuaW1hdGlvbiB0byBmaXJlIGFnYWluLlxuXG4gICAgICBpZiAob25SZWZyZXNoICYmICFfcmVmcmVzaGluZ0FsbCAmJiAhZXhlY3V0aW5nT25SZWZyZXNoKSB7XG4gICAgICAgIC8vIHdoZW4gcmVmcmVzaGluZyBhbGwsIHdlIGRvIGV4dHJhIHdvcmsgdG8gY29ycmVjdCBwaW5uZWRDb250YWluZXIgc2l6ZXMgYW5kIGVuc3VyZSB0aGluZ3MgZG9uJ3QgZXhjZWVkIHRoZSBtYXhTY3JvbGwsIHNvIHdlIHNob3VsZCBkbyBhbGwgdGhlIHJlZnJlc2hlcyBhdCB0aGUgZW5kIGFmdGVyIGFsbCB0aGF0IHdvcmsgc28gdGhhdCB0aGUgc3RhcnQvZW5kIHZhbHVlcyBhcmUgY29ycmVjdGVkLlxuICAgICAgICBleGVjdXRpbmdPblJlZnJlc2ggPSB0cnVlO1xuICAgICAgICBvblJlZnJlc2goc2VsZik7XG4gICAgICAgIGV4ZWN1dGluZ09uUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChzY3JvbGxGdW5jKCkgLSBzY3JvbGwyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIDEwMDAgfHwgMDtcbiAgICB9O1xuXG4gICAgc2VsZi5lbmRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfZW5kQW5pbWF0aW9uKHNlbGYuY2FsbGJhY2tBbmltYXRpb24pO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogIWFuaW1hdGlvbi5wYXVzZWQoKSA/IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24ucmV2ZXJzZWQoKSkgOiBpc1RvZ2dsZSB8fCBfZW5kQW5pbWF0aW9uKGFuaW1hdGlvbiwgc2VsZi5kaXJlY3Rpb24gPCAwLCAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5sYWJlbFRvU2Nyb2xsID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5sYWJlbHMgJiYgKHN0YXJ0IHx8IHNlbGYucmVmcmVzaCgpIHx8IHN0YXJ0KSArIGFuaW1hdGlvbi5sYWJlbHNbbGFiZWxdIC8gYW5pbWF0aW9uLmR1cmF0aW9uKCkgKiBjaGFuZ2UgfHwgMDtcbiAgICB9O1xuXG4gICAgc2VsZi5nZXRUcmFpbGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgaSA9IF90cmlnZ2Vycy5pbmRleE9mKHNlbGYpLFxuICAgICAgICAgIGEgPSBzZWxmLmRpcmVjdGlvbiA+IDAgPyBfdHJpZ2dlcnMuc2xpY2UoMCwgaSkucmV2ZXJzZSgpIDogX3RyaWdnZXJzLnNsaWNlKGkgKyAxKTtcblxuICAgICAgcmV0dXJuIChfaXNTdHJpbmcobmFtZSkgPyBhLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC52YXJzLnByZXZlbnRPdmVybGFwcyA9PT0gbmFtZTtcbiAgICAgIH0pIDogYSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBzZWxmLmRpcmVjdGlvbiA+IDAgPyB0LmVuZCA8PSBzdGFydCA6IHQuc3RhcnQgPj0gZW5kO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHNlbGYudXBkYXRlID0gZnVuY3Rpb24gKHJlc2V0LCByZWNvcmRWZWxvY2l0eSwgZm9yY2VGYWtlKSB7XG4gICAgICBpZiAoY29udGFpbmVyQW5pbWF0aW9uICYmICFmb3JjZUZha2UgJiYgIXJlc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjcm9sbCA9IF9yZWZyZXNoaW5nQWxsID09PSB0cnVlID8gcHJldlNjcm9sbCA6IHNlbGYuc2Nyb2xsKCksXG4gICAgICAgICAgcCA9IHJlc2V0ID8gMCA6IChzY3JvbGwgLSBzdGFydCkgLyBjaGFuZ2UsXG4gICAgICAgICAgY2xpcHBlZCA9IHAgPCAwID8gMCA6IHAgPiAxID8gMSA6IHAgfHwgMCxcbiAgICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBzZWxmLnByb2dyZXNzLFxuICAgICAgICAgIGlzQWN0aXZlLFxuICAgICAgICAgIHdhc0FjdGl2ZSxcbiAgICAgICAgICB0b2dnbGVTdGF0ZSxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgc3RhdGVDaGFuZ2VkLFxuICAgICAgICAgIHRvZ2dsZWQsXG4gICAgICAgICAgaXNBdE1heCxcbiAgICAgICAgICBpc1Rha2luZ0FjdGlvbjtcblxuICAgICAgaWYgKHJlY29yZFZlbG9jaXR5KSB7XG4gICAgICAgIHNjcm9sbDIgPSBzY3JvbGwxO1xuICAgICAgICBzY3JvbGwxID0gY29udGFpbmVyQW5pbWF0aW9uID8gc2Nyb2xsRnVuYygpIDogc2Nyb2xsO1xuXG4gICAgICAgIGlmIChzbmFwKSB7XG4gICAgICAgICAgc25hcDIgPSBzbmFwMTtcbiAgICAgICAgICBzbmFwMSA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogY2xpcHBlZDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhbnRpY2lwYXRlIHRoZSBwaW5uaW5nIGEgZmV3IHRpY2tzIGFoZWFkIG9mIHRpbWUgYmFzZWQgb24gdmVsb2NpdHkgdG8gYXZvaWQgYSB2aXN1YWwgZ2xpdGNoIGR1ZSB0byB0aGUgZmFjdCB0aGF0IG1vc3QgYnJvd3NlcnMgZG8gc2Nyb2xsaW5nIG9uIGEgc2VwYXJhdGUgdGhyZWFkIChub3Qgc3luY2VkIHdpdGggcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS5cblxuXG4gICAgICBpZiAoYW50aWNpcGF0ZVBpbiAmJiBwaW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCAmJiBfbGFzdFNjcm9sbFRpbWUpIHtcbiAgICAgICAgaWYgKCFjbGlwcGVkICYmIHN0YXJ0IDwgc2Nyb2xsICsgKHNjcm9sbCAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogYW50aWNpcGF0ZVBpbikge1xuICAgICAgICAgIGNsaXBwZWQgPSAwLjAwMDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xpcHBlZCA9PT0gMSAmJiBlbmQgPiBzY3JvbGwgKyAoc2Nyb2xsIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiBhbnRpY2lwYXRlUGluKSB7XG4gICAgICAgICAgY2xpcHBlZCA9IDAuOTk5OTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2xpcHBlZCAhPT0gcHJldlByb2dyZXNzICYmIHNlbGYuZW5hYmxlZCkge1xuICAgICAgICBpc0FjdGl2ZSA9IHNlbGYuaXNBY3RpdmUgPSAhIWNsaXBwZWQgJiYgY2xpcHBlZCA8IDE7XG4gICAgICAgIHdhc0FjdGl2ZSA9ICEhcHJldlByb2dyZXNzICYmIHByZXZQcm9ncmVzcyA8IDE7XG4gICAgICAgIHRvZ2dsZWQgPSBpc0FjdGl2ZSAhPT0gd2FzQWN0aXZlO1xuICAgICAgICBzdGF0ZUNoYW5nZWQgPSB0b2dnbGVkIHx8ICEhY2xpcHBlZCAhPT0gISFwcmV2UHJvZ3Jlc3M7IC8vIGNvdWxkIGdvIGZyb20gc3RhcnQgYWxsIHRoZSB3YXkgdG8gZW5kLCB0aHVzIGl0IGRpZG4ndCB0b2dnbGUgYnV0IGl0IGRpZCBjaGFuZ2Ugc3RhdGUgaW4gYSBzZW5zZSAobWF5IG5lZWQgdG8gZmlyZSBhIGNhbGxiYWNrKVxuXG4gICAgICAgIHNlbGYuZGlyZWN0aW9uID0gY2xpcHBlZCA+IHByZXZQcm9ncmVzcyA/IDEgOiAtMTtcbiAgICAgICAgc2VsZi5wcm9ncmVzcyA9IGNsaXBwZWQ7XG5cbiAgICAgICAgaWYgKHN0YXRlQ2hhbmdlZCAmJiAhX3JlZnJlc2hpbmcpIHtcbiAgICAgICAgICB0b2dnbGVTdGF0ZSA9IGNsaXBwZWQgJiYgIXByZXZQcm9ncmVzcyA/IDAgOiBjbGlwcGVkID09PSAxID8gMSA6IHByZXZQcm9ncmVzcyA9PT0gMSA/IDIgOiAzOyAvLyAwID0gZW50ZXIsIDEgPSBsZWF2ZSwgMiA9IGVudGVyQmFjaywgMyA9IGxlYXZlQmFjayAod2UgcHJpb3JpdGl6ZSB0aGUgRklSU1QgZW5jb3VudGVyLCB0aHVzIGlmIHlvdSBzY3JvbGwgcmVhbGx5IGZhc3QgcGFzdCB0aGUgb25FbnRlciBhbmQgb25MZWF2ZSBpbiBvbmUgdGljaywgaXQnZCBwcmlvcml0aXplIG9uRW50ZXIuXG5cbiAgICAgICAgICBpZiAoaXNUb2dnbGUpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9ICF0b2dnbGVkICYmIHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGUgKyAxXSAhPT0gXCJub25lXCIgJiYgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZSArIDFdIHx8IHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGVdOyAvLyBpZiBpdCBkaWRuJ3QgdG9nZ2xlLCB0aGF0IG1lYW5zIGl0IHNob3QgcmlnaHQgcGFzdCBhbmQgc2luY2Ugd2UgcHJpb3JpdGl6ZSB0aGUgXCJlbnRlclwiIGFjdGlvbiwgd2Ugc2hvdWxkIHN3aXRjaCB0byB0aGUgXCJsZWF2ZVwiIGluIHRoaXMgY2FzZSAoYnV0IG9ubHkgaWYgb25lIGlzIGRlZmluZWQpXG5cbiAgICAgICAgICAgIGlzVGFraW5nQWN0aW9uID0gYW5pbWF0aW9uICYmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIiB8fCBhY3Rpb24gPT09IFwicmVzZXRcIiB8fCBhY3Rpb24gaW4gYW5pbWF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2ZW50T3ZlcmxhcHMgJiYgKHRvZ2dsZWQgfHwgaXNUYWtpbmdBY3Rpb24pICYmIChpc1Rha2luZ0FjdGlvbiB8fCBzY3J1YiB8fCAhYW5pbWF0aW9uKSAmJiAoX2lzRnVuY3Rpb24ocHJldmVudE92ZXJsYXBzKSA/IHByZXZlbnRPdmVybGFwcyhzZWxmKSA6IHNlbGYuZ2V0VHJhaWxpbmcocHJldmVudE92ZXJsYXBzKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuZW5kQW5pbWF0aW9uKCk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAoIWlzVG9nZ2xlKSB7XG4gICAgICAgICAgaWYgKHNjcnViVHdlZW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCkge1xuICAgICAgICAgICAgc2NydWJUd2Vlbi5fZHAuX3RpbWUgLSBzY3J1YlR3ZWVuLl9zdGFydCAhPT0gc2NydWJUd2Vlbi5fdGltZSAmJiBzY3J1YlR3ZWVuLnJlbmRlcihzY3J1YlR3ZWVuLl9kcC5fdGltZSAtIHNjcnViVHdlZW4uX3N0YXJ0KTsgLy8gaWYgdGhlcmUncyBhIHNjcnViIG9uIGJvdGggdGhlIGNvbnRhaW5lciBhbmltYXRpb24gYW5kIHRoaXMgb25lIChvciBhIFNjcm9sbFNtb290aGVyKSwgdGhlIHVwZGF0ZSBvcmRlciB3b3VsZCBjYXVzZSB0aGlzIG9uZSBub3QgdG8gaGF2ZSByZW5kZXJlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IG1ha2UgYW55IHByb2dyZXNzIGJlZm9yZSB3ZSAucmVzdGFydCgpIGl0IGhlYWRpbmcgdG93YXJkIHRoZSBuZXcgcHJvZ3Jlc3Mgc28gaXQnZCBhcHBlYXIgc3R1Y2sgdGh1cyB3ZSBmb3JjZSBhIHJlbmRlciBoZXJlLlxuXG4gICAgICAgICAgICBpZiAoc2NydWJUd2Vlbi5yZXNldFRvKSB7XG4gICAgICAgICAgICAgIHNjcnViVHdlZW4ucmVzZXRUbyhcInRvdGFsUHJvZ3Jlc3NcIiwgY2xpcHBlZCwgYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsZWdhY3kgc3VwcG9ydCAoY291cnRlc3kpLCBiZWZvcmUgMy4xMC4wXG4gICAgICAgICAgICAgIHNjcnViVHdlZW4udmFycy50b3RhbFByb2dyZXNzID0gY2xpcHBlZDtcbiAgICAgICAgICAgICAgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCkucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb24udG90YWxQcm9ncmVzcyhjbGlwcGVkLCAhIShfcmVmcmVzaGluZyAmJiAobGFzdFJlZnJlc2ggfHwgcmVzZXQpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBpbikge1xuICAgICAgICAgIHJlc2V0ICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5zdHlsZVtwaW5TcGFjaW5nICsgZGlyZWN0aW9uLm9zMl0gPSBzcGFjaW5nU3RhcnQpO1xuXG4gICAgICAgICAgaWYgKCF1c2VGaXhlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwaW5TZXR0ZXIoX3JvdW5kKHBpblN0YXJ0ICsgcGluQ2hhbmdlICogY2xpcHBlZCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpc0F0TWF4ID0gIXJlc2V0ICYmIGNsaXBwZWQgPiBwcmV2UHJvZ3Jlc3MgJiYgZW5kICsgMSA+IHNjcm9sbCAmJiBzY3JvbGwgKyAxID49IF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbik7IC8vIGlmIGl0J3MgYXQgdGhlIFZFUlkgZW5kIG9mIHRoZSBwYWdlLCBkb24ndCBzd2l0Y2ggYXdheSBmcm9tIHBvc2l0aW9uOiBmaXhlZCBiZWNhdXNlIGl0J3MgcG9pbnRsZXNzIGFuZCBpdCBjb3VsZCBjYXVzZSBhIGJyaWVmIGZsYXNoIHdoZW4gdGhlIHVzZXIgc2Nyb2xscyBiYWNrIHVwICh3aGVuIGl0IGdldHMgcGlubmVkIGFnYWluKVxuXG4gICAgICAgICAgICBpZiAocGluUmVwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKCFyZXNldCAmJiAoaXNBY3RpdmUgfHwgaXNBdE1heCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gX2dldEJvdW5kcyhwaW4sIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBfb2Zmc2V0ID0gc2Nyb2xsIC0gc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICBfcmVwYXJlbnQocGluLCBfYm9keSwgYm91bmRzLnRvcCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IF9vZmZzZXQgOiAwKSArIF9weCwgYm91bmRzLmxlZnQgKyAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyAwIDogX29mZnNldCkgKyBfcHgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9yZXBhcmVudChwaW4sIHNwYWNlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3NldFN0YXRlKGlzQWN0aXZlIHx8IGlzQXRNYXggPyBwaW5BY3RpdmVTdGF0ZSA6IHBpblN0YXRlKTtcblxuICAgICAgICAgICAgcGluTW92ZXMgJiYgY2xpcHBlZCA8IDEgJiYgaXNBY3RpdmUgfHwgcGluU2V0dGVyKHBpblN0YXJ0ICsgKGNsaXBwZWQgPT09IDEgJiYgIWlzQXRNYXggPyBwaW5DaGFuZ2UgOiAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc25hcCAmJiAhdHdlZW5Uby50d2VlbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwICYmIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgICAgICB0b2dnbGVDbGFzcyAmJiAodG9nZ2xlZCB8fCBvbmNlICYmIGNsaXBwZWQgJiYgKGNsaXBwZWQgPCAxIHx8ICFfbGltaXRDYWxsYmFja3MpKSAmJiBfdG9BcnJheSh0b2dnbGVDbGFzcy50YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3RbaXNBY3RpdmUgfHwgb25jZSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXSh0b2dnbGVDbGFzcy5jbGFzc05hbWUpO1xuICAgICAgICB9KTsgLy8gY2xhc3NlcyBjb3VsZCBhZmZlY3QgcG9zaXRpb25pbmcsIHNvIGRvIGl0IGV2ZW4gaWYgcmVzZXQgb3IgcmVmcmVzaGluZyBpcyB0cnVlLlxuXG4gICAgICAgIG9uVXBkYXRlICYmICFpc1RvZ2dsZSAmJiAhcmVzZXQgJiYgb25VcGRhdGUoc2VsZik7XG5cbiAgICAgICAgaWYgKHN0YXRlQ2hhbmdlZCAmJiAhX3JlZnJlc2hpbmcpIHtcbiAgICAgICAgICBpZiAoaXNUb2dnbGUpIHtcbiAgICAgICAgICAgIGlmIChpc1Rha2luZ0FjdGlvbikge1xuICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucGF1c2UoKS50b3RhbFByb2dyZXNzKDEpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXNldFwiKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnJlc3RhcnQodHJ1ZSkucGF1c2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwicmVzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uW2FjdGlvbl0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvblVwZGF0ZSAmJiBvblVwZGF0ZShzZWxmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9nZ2xlZCB8fCAhX2xpbWl0Q2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBvbiBzdGFydHVwLCB0aGUgcGFnZSBjb3VsZCBiZSBzY3JvbGxlZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGNhbGxiYWNrcyB0aGF0IGRpZG4ndCB0b2dnbGUuIEZvciBleGFtcGxlIG9uRW50ZXIgc2hvdWxkbid0IGZpcmUgaWYgdGhlIFNjcm9sbFRyaWdnZXIgaXNuJ3QgYWN0dWFsbHkgZW50ZXJlZC5cbiAgICAgICAgICAgIG9uVG9nZ2xlICYmIHRvZ2dsZWQgJiYgX2NhbGxiYWNrKHNlbGYsIG9uVG9nZ2xlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gJiYgX2NhbGxiYWNrKHNlbGYsIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0pO1xuICAgICAgICAgICAgb25jZSAmJiAoY2xpcHBlZCA9PT0gMSA/IHNlbGYua2lsbChmYWxzZSwgMSkgOiBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdID0gMCk7IC8vIGEgY2FsbGJhY2sgc2hvdWxkbid0IGJlIGNhbGxlZCBhZ2FpbiBpZiBvbmNlIGlzIHRydWUuXG5cbiAgICAgICAgICAgIGlmICghdG9nZ2xlZCkge1xuICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRvIGdvIGNvbXBsZXRlbHkgcGFzdCwgbGlrZSBmcm9tIGJlZm9yZSB0aGUgc3RhcnQgdG8gYWZ0ZXIgdGhlIGVuZCAob3IgdmljZS12ZXJzYSkgaW4gd2hpY2ggY2FzZSBCT1RIIGNhbGxiYWNrcyBzaG91bGQgYmUgZmlyZWQgaW4gdGhhdCBvcmRlclxuICAgICAgICAgICAgICB0b2dnbGVTdGF0ZSA9IGNsaXBwZWQgPT09IDEgPyAxIDogMztcbiAgICAgICAgICAgICAgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSAmJiBfY2FsbGJhY2soc2VsZiwgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZhc3RTY3JvbGxFbmQgJiYgIWlzQWN0aXZlICYmIE1hdGguYWJzKHNlbGYuZ2V0VmVsb2NpdHkoKSkgPiAoX2lzTnVtYmVyKGZhc3RTY3JvbGxFbmQpID8gZmFzdFNjcm9sbEVuZCA6IDI1MDApKSB7XG4gICAgICAgICAgICBfZW5kQW5pbWF0aW9uKHNlbGYuY2FsbGJhY2tBbmltYXRpb24pO1xuXG4gICAgICAgICAgICBzY3J1YlR3ZWVuID8gc2NydWJUd2Vlbi5wcm9ncmVzcygxKSA6IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBhY3Rpb24gPT09IFwicmV2ZXJzZVwiID8gMSA6ICFjbGlwcGVkLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUb2dnbGUgJiYgb25VcGRhdGUgJiYgIV9yZWZyZXNoaW5nKSB7XG4gICAgICAgICAgb25VcGRhdGUoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdXBkYXRlIGFic29sdXRlbHktcG9zaXRpb25lZCBtYXJrZXJzIChvbmx5IGlmIHRoZSBzY3JvbGxlciBpc24ndCB0aGUgdmlld3BvcnQpXG5cblxuICAgICAgaWYgKG1hcmtlckVuZFNldHRlcikge1xuICAgICAgICB2YXIgbiA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IHNjcm9sbCAvIGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpICogKGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0IHx8IDApIDogc2Nyb2xsO1xuICAgICAgICBtYXJrZXJTdGFydFNldHRlcihuICsgKG1hcmtlclN0YXJ0VHJpZ2dlci5faXNGbGlwcGVkID8gMSA6IDApKTtcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyKG4pO1xuICAgICAgfVxuXG4gICAgICBjYU1hcmtlclNldHRlciAmJiBjYU1hcmtlclNldHRlcigtc2Nyb2xsIC8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgKiAoY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgfHwgMCkpO1xuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVmcmVzaCkge1xuICAgICAgaWYgKCFzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cbiAgICAgICAgaXNWaWV3cG9ydCB8fCBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cbiAgICAgICAgaWYgKHJlc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBwcmV2UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgIHNjcm9sbDEgPSBzY3JvbGwyID0gbGFzdFNuYXAgPSBzY3JvbGxGdW5jKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWZyZXNoICE9PSBmYWxzZSAmJiBzZWxmLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5nZXRUd2VlbiA9IGZ1bmN0aW9uIChzbmFwKSB7XG4gICAgICByZXR1cm4gc25hcCAmJiB0d2VlblRvID8gdHdlZW5Uby50d2VlbiA6IHNjcnViVHdlZW47XG4gICAgfTtcblxuICAgIHNlbGYuc2V0UG9zaXRpb25zID0gZnVuY3Rpb24gKG5ld1N0YXJ0LCBuZXdFbmQsIGtlZXBDbGFtcCwgcGluT2Zmc2V0KSB7XG4gICAgICAvLyBkb2Vzbid0IHBlcnNpc3QgYWZ0ZXIgcmVmcmVzaCgpISBJbnRlbmRlZCB0byBiZSBhIHdheSB0byBvdmVycmlkZSB2YWx1ZXMgdGhhdCB3ZXJlIHNldCBkdXJpbmcgcmVmcmVzaCgpLCBsaWtlIHlvdSBjb3VsZCBzZXQgaXQgaW4gb25SZWZyZXNoKClcbiAgICAgIGlmIChjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgICAgLy8gY29udmVydCByYXRpb3MgaW50byBzY3JvbGwgcG9zaXRpb25zLiBSZW1lbWJlciwgc3RhcnQvZW5kIHZhbHVlcyBvbiBTY3JvbGxUcmlnZ2VycyB0aGF0IGhhdmUgYSBjb250YWluZXJBbmltYXRpb24gcmVmZXIgdG8gdGhlIHRpbWUgKGluIHNlY29uZHMpLCBOT1Qgc2Nyb2xsIHBvc2l0aW9ucy5cbiAgICAgICAgdmFyIHN0ID0gY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpLFxuICAgICAgICAgICAgX2NoYW5nZSA9IHN0LmVuZCAtIHN0LnN0YXJ0O1xuXG4gICAgICAgIG5ld1N0YXJ0ID0gc3Quc3RhcnQgKyBfY2hhbmdlICogbmV3U3RhcnQgLyBkdXJhdGlvbjtcbiAgICAgICAgbmV3RW5kID0gc3Quc3RhcnQgKyBfY2hhbmdlICogbmV3RW5kIC8gZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmVmcmVzaChmYWxzZSwgZmFsc2UsIHtcbiAgICAgICAgc3RhcnQ6IF9rZWVwQ2xhbXAobmV3U3RhcnQsIGtlZXBDbGFtcCAmJiAhIXNlbGYuX3N0YXJ0Q2xhbXApLFxuICAgICAgICBlbmQ6IF9rZWVwQ2xhbXAobmV3RW5kLCBrZWVwQ2xhbXAgJiYgISFzZWxmLl9lbmRDbGFtcClcbiAgICAgIH0sIHBpbk9mZnNldCk7XG4gICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBzZWxmLmFkanVzdFBpblNwYWNpbmcgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICBpZiAoc3BhY2VyU3RhdGUgJiYgYW1vdW50KSB7XG4gICAgICAgIHZhciBpID0gc3BhY2VyU3RhdGUuaW5kZXhPZihkaXJlY3Rpb24uZCkgKyAxO1xuICAgICAgICBzcGFjZXJTdGF0ZVtpXSA9IHBhcnNlRmxvYXQoc3BhY2VyU3RhdGVbaV0pICsgYW1vdW50ICsgX3B4O1xuICAgICAgICBzcGFjZXJTdGF0ZVsxXSA9IHBhcnNlRmxvYXQoc3BhY2VyU3RhdGVbMV0pICsgYW1vdW50ICsgX3B4O1xuXG4gICAgICAgIF9zZXRTdGF0ZShzcGFjZXJTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYuZGlzYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgYWxsb3dBbmltYXRpb24pIHtcbiAgICAgIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgcmVzZXQgIT09IGZhbHNlICYmIHNlbGYucmV2ZXJ0KHRydWUsIHRydWUpO1xuICAgICAgICBzZWxmLmVuYWJsZWQgPSBzZWxmLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGFsbG93QW5pbWF0aW9uIHx8IHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wYXVzZSgpO1xuICAgICAgICBwcmV2U2Nyb2xsID0gMDtcbiAgICAgICAgcGluQ2FjaGUgJiYgKHBpbkNhY2hlLnVuY2FjaGUgPSAxKTtcbiAgICAgICAgb25SZWZyZXNoSW5pdCAmJiBfcmVtb3ZlTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoSW5pdFwiLCBvblJlZnJlc2hJbml0KTtcblxuICAgICAgICBpZiAoc25hcERlbGF5ZWRDYWxsKSB7XG4gICAgICAgICAgc25hcERlbGF5ZWRDYWxsLnBhdXNlKCk7XG4gICAgICAgICAgdHdlZW5Uby50d2VlbiAmJiB0d2VlblRvLnR3ZWVuLmtpbGwoKSAmJiAodHdlZW5Uby50d2VlbiA9IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZpZXdwb3J0KSB7XG4gICAgICAgICAgdmFyIGkgPSBfdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKF90cmlnZ2Vyc1tpXS5zY3JvbGxlciA9PT0gc2Nyb2xsZXIgJiYgX3RyaWdnZXJzW2ldICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgIHJldHVybjsgLy9kb24ndCByZW1vdmUgdGhlIGxpc3RlbmVycyBpZiB0aGVyZSBhcmUgc3RpbGwgb3RoZXIgdHJpZ2dlcnMgcmVmZXJlbmNpbmcgaXQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHNjcm9sbGVyLCBcInJlc2l6ZVwiLCBfb25SZXNpemUpO1xuXG4gICAgICAgICAgaXNWaWV3cG9ydCB8fCBfcmVtb3ZlTGlzdGVuZXIoc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5raWxsID0gZnVuY3Rpb24gKHJldmVydCwgYWxsb3dBbmltYXRpb24pIHtcbiAgICAgIHNlbGYuZGlzYWJsZShyZXZlcnQsIGFsbG93QW5pbWF0aW9uKTtcbiAgICAgIHNjcnViVHdlZW4gJiYgIWFsbG93QW5pbWF0aW9uICYmIHNjcnViVHdlZW4ua2lsbCgpO1xuICAgICAgaWQgJiYgZGVsZXRlIF9pZHNbaWRdO1xuXG4gICAgICB2YXIgaSA9IF90cmlnZ2Vycy5pbmRleE9mKHNlbGYpO1xuXG4gICAgICBpID49IDAgJiYgX3RyaWdnZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIGkgPT09IF9pICYmIF9kaXJlY3Rpb24gPiAwICYmIF9pLS07IC8vIGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSByZWZyZXNoKCkgb3IgdXBkYXRlKCksIHNwbGljaW5nIHdvdWxkIGNhdXNlIHNraXBzIGluIHRoZSBpbmRleCwgc28gYWRqdXN0Li4uXG4gICAgICAvLyBpZiBubyBvdGhlciBTY3JvbGxUcmlnZ2VyIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBzY3JvbGxlciBhcmUgZm91bmQsIHdpcGUgb3V0IGFueSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb24uIE90aGVyd2lzZSwgaW4gYSBzaW5nbGUgcGFnZSBhcHBsaWNhdGlvbiwgZm9yIGV4YW1wbGUsIGl0IGNvdWxkIG1haW50YWluIHNjcm9sbCBwb3NpdGlvbiB3aGVuIGl0IHJlYWxseSBzaG91bGRuJ3QuXG5cbiAgICAgIGkgPSAwO1xuXG4gICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5zY3JvbGxlciA9PT0gc2VsZi5zY3JvbGxlciAmJiAoaSA9IDEpO1xuICAgICAgfSk7XG5cbiAgICAgIGkgfHwgX3JlZnJlc2hpbmdBbGwgfHwgKHNlbGYuc2Nyb2xsLnJlYyA9IDApO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyID0gbnVsbDtcbiAgICAgICAgcmV2ZXJ0ICYmIGFuaW1hdGlvbi5yZXZlcnQoe1xuICAgICAgICAgIGtpbGw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBhbGxvd0FuaW1hdGlvbiB8fCBhbmltYXRpb24ua2lsbCgpO1xuICAgICAgfVxuXG4gICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnBhcmVudE5vZGUgJiYgbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG0pO1xuICAgICAgfSk7XG4gICAgICBfcHJpbWFyeSA9PT0gc2VsZiAmJiAoX3ByaW1hcnkgPSAwKTtcblxuICAgICAgaWYgKHBpbikge1xuICAgICAgICBwaW5DYWNoZSAmJiAocGluQ2FjaGUudW5jYWNoZSA9IDEpO1xuICAgICAgICBpID0gMDtcblxuICAgICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LnBpbiA9PT0gcGluICYmIGkrKztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaSB8fCAocGluQ2FjaGUuc3BhY2VyID0gMCk7IC8vIGlmIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBTY3JvbGxUcmlnZ2VycyB3aXRoIHRoZSBzYW1lIHBpbiwgcmVtb3ZlIHRoZSBzcGFjZXIsIG90aGVyd2lzZSBpdCBjb3VsZCBiZSBjb250YW1pbmF0ZWQgd2l0aCBvbGQvc3RhbGUgdmFsdWVzIGlmIHRoZSB1c2VyIHJlLWNyZWF0ZXMgYSBTY3JvbGxUcmlnZ2VyIGZvciB0aGUgc2FtZSBlbGVtZW50LlxuICAgICAgfVxuXG4gICAgICB2YXJzLm9uS2lsbCAmJiB2YXJzLm9uS2lsbChzZWxmKTtcbiAgICB9O1xuXG4gICAgX3RyaWdnZXJzLnB1c2goc2VsZik7XG5cbiAgICBzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiBjdXN0b21SZXZlcnRSZXR1cm4oc2VsZik7XG5cbiAgICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5hZGQgJiYgIWNoYW5nZSkge1xuICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBpcyBhIHRpbWVsaW5lLCBpdCBtYXkgbm90IGhhdmUgYmVlbiBwb3B1bGF0ZWQgeWV0LCBzbyBpdCB3b3VsZG4ndCByZW5kZXIgYXQgdGhlIHByb3BlciBwbGFjZSBvbiB0aGUgZmlyc3QgcmVmcmVzaCgpLCB0aHVzIHdlIHNob3VsZCBzY2hlZHVsZSBvbmUgZm9yIHRoZSBuZXh0IHRpY2suIElmIFwiY2hhbmdlXCIgaXMgZGVmaW5lZCwgd2Uga25vdyBpdCBtdXN0IGJlIHJlLWVuYWJsaW5nLCB0aHVzIHdlIGNhbiByZWZyZXNoKCkgcmlnaHQgYXdheS5cbiAgICAgIHZhciB1cGRhdGVGdW5jID0gc2VsZi51cGRhdGU7IC8vIHNvbWUgYnJvd3NlcnMgbWF5IGZpcmUgYSBzY3JvbGwgZXZlbnQgQkVGT1JFIGEgdGljayBlbGFwc2VzIGFuZC9vciB0aGUgRE9NQ29udGVudExvYWRlZCBmaXJlcy4gU28gdGhlcmUncyBhIGNoYW5jZSB1cGRhdGUoKSB3aWxsIGJlIGNhbGxlZCBCRUZPUkUgYSByZWZyZXNoKCkgaGFzIGhhcHBlbmVkIG9uIGEgVGltZWxpbmUtYXR0YWNoZWQgU2Nyb2xsVHJpZ2dlciB3aGljaCBtZWFucyB0aGUgc3RhcnQvZW5kIHdvbid0IGJlIGNhbGN1bGF0ZWQgeWV0LiBXZSBkb24ndCB3YW50IHRvIGFkZCBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgdGhlIHVwZGF0ZSgpIG1ldGhvZCAobGlrZSBjaGVjayB0byBzZWUgaWYgZW5kIGlzIGRlZmluZWQgYW5kIGlmIG5vdCwgZm9yY2UgYSByZWZyZXNoKCkpIGJlY2F1c2UgdGhhdCdzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGhpdCBhIExPVCAocGVyZm9ybWFuY2UpLiBTbyB3ZSBzd2FwIG91dCB0aGUgcmVhbCB1cGRhdGUoKSBtZXRob2QgZm9yIHRoaXMgb25lIHRoYXQnbGwgcmUtYXR0YWNoIGl0IHRoZSBmaXJzdCB0aW1lIGl0IGdldHMgY2FsbGVkIGFuZCBvZiBjb3Vyc2UgZm9yY2VzIGEgcmVmcmVzaCgpLlxuXG4gICAgICBzZWxmLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51cGRhdGUgPSB1cGRhdGVGdW5jO1xuICAgICAgICBfc2Nyb2xsZXJzLmNhY2hlKys7IC8vIG90aGVyd2lzZSBhIGNhY2hlZCBzY3JvbGwgcG9zaXRpb24gbWF5IGdldCB1c2VkIGluIHRoZSByZWZyZXNoKCkgaW4gYSB2ZXJ5IHJhcmUgc2NlbmFyaW8sIGxpa2UgaWYgU2Nyb2xsVHJpZ2dlcnMgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgRE9NQ29udGVudExvYWRlZCBldmVudCBhbmQgdGhlIHF1ZXVlZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSBmaXJlcyBiZWZvcmVoYW5kLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9jb21tdW5pdHkvZm9ydW1zL3RvcGljLzQxMjY3LXNjcm9sbHRyaWdnZXItYnJlYWtzLW9uLXJlZnJlc2gtd2hlbi11c2luZy1kb21jb250ZW50bG9hZGVkL1xuXG4gICAgICAgIHN0YXJ0IHx8IGVuZCB8fCBzZWxmLnJlZnJlc2goKTtcbiAgICAgIH07XG5cbiAgICAgIGdzYXAuZGVsYXllZENhbGwoMC4wMSwgc2VsZi51cGRhdGUpO1xuICAgICAgY2hhbmdlID0gMC4wMTtcbiAgICAgIHN0YXJ0ID0gZW5kID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgcGluICYmIF9xdWV1ZVJlZnJlc2hBbGwoKTsgLy8gcGlubmluZyBjb3VsZCBhZmZlY3QgdGhlIHBvc2l0aW9ucyBvZiBvdGhlciB0aGluZ3MsIHNvIG1ha2Ugc3VyZSB3ZSBxdWV1ZSBhIGZ1bGwgcmVmcmVzaCgpXG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgICAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcbiAgICAgIF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgU2Nyb2xsVHJpZ2dlci5lbmFibGUoKTtcbiAgICAgIF9jb3JlSW5pdHRlZCA9IF9lbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiBfY29yZUluaXR0ZWQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKGNvbmZpZykge1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gY29uZmlnKSB7XG4gICAgICAgIF9kZWZhdWx0c1twXSA9IGNvbmZpZ1twXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2RlZmF1bHRzO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUocmVzZXQsIGtpbGwpIHtcbiAgICBfZW5hYmxlZCA9IDA7XG5cbiAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgcmV0dXJuIHRyaWdnZXJba2lsbCA/IFwia2lsbFwiIDogXCJkaXNhYmxlXCJdKHJlc2V0KTtcbiAgICB9KTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcIndoZWVsXCIsIF9vblNjcm9sbCk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2RvYywgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblxuICAgIGNsZWFySW50ZXJ2YWwoX3N5bmNJbnRlcnZhbCk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfcGFzc1Rocm91Z2gpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9ib2R5LCBcInRvdWNoc3RhcnRcIiwgX3Bhc3NUaHJvdWdoKTtcblxuICAgIF9tdWx0aUxpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVyZG93bix0b3VjaHN0YXJ0LG1vdXNlZG93blwiLCBfcG9pbnRlckRvd25IYW5kbGVyKTtcblxuICAgIF9tdWx0aUxpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBfcG9pbnRlclVwSGFuZGxlcik7XG5cbiAgICBfcmVzaXplRGVsYXkua2lsbCgpO1xuXG4gICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfcmVtb3ZlTGlzdGVuZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfc2Nyb2xsZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBfd2hlZWxMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9zY3JvbGxlcnNbaV0sIF9zY3JvbGxlcnNbaSArIDFdKTtcblxuICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAyXSk7XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuXG4gICAgaWYgKGdzYXApIHtcbiAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcbiAgICAgIF9jb250ZXh0ID0gZ3NhcC5jb3JlLmNvbnRleHQgfHwgX3Bhc3NUaHJvdWdoO1xuICAgICAgX3N1cHByZXNzT3ZlcndyaXRlcyA9IGdzYXAuY29yZS5zdXBwcmVzc092ZXJ3cml0ZXMgfHwgX3Bhc3NUaHJvdWdoO1xuICAgICAgX3Njcm9sbFJlc3RvcmF0aW9uID0gX3dpbi5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uIHx8IFwiYXV0b1wiO1xuICAgICAgX2xhc3RTY3JvbGwgPSBfd2luLnBhZ2VZT2Zmc2V0IHx8IDA7XG4gICAgICBnc2FwLmNvcmUuZ2xvYmFscyhcIlNjcm9sbFRyaWdnZXJcIiwgU2Nyb2xsVHJpZ2dlcik7IC8vIG11c3QgcmVnaXN0ZXIgdGhlIGdsb2JhbCBtYW51YWxseSBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyLCBmdW5jdGlvbnMgKGNsYXNzZXMpIGRvbid0IGhhdmUgYSBcIm5hbWVcIiBwcm9wZXJ0eS5cblxuICAgICAgaWYgKF9ib2R5KSB7XG4gICAgICAgIF9lbmFibGVkID0gMTtcbiAgICAgICAgX2RpdjEwMHZoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTsgLy8gdG8gc29sdmUgbW9iaWxlIGJyb3dzZXIgYWRkcmVzcyBiYXIgc2hvdy9oaWRlIHJlc2l6aW5nLCB3ZSBzaG91bGRuJ3QgcmVseSBvbiB3aW5kb3cuaW5uZXJIZWlnaHQuIEluc3RlYWQsIHVzZSBhIDxkaXY+IHdpdGggaXRzIGhlaWdodCBzZXQgdG8gMTAwdmggYW5kIG1lYXN1cmUgdGhhdCBzaW5jZSB0aGF0J3Mgd2hhdCB0aGUgc2Nyb2xsaW5nIGlzIGJhc2VkIG9uIGFueXdheSBhbmQgaXQncyBub3QgYWZmZWN0ZWQgYnkgYWRkcmVzcyBiYXIgc2hvd2luZy9oaWRpbmcuXG5cbiAgICAgICAgX2RpdjEwMHZoLnN0eWxlLmhlaWdodCA9IFwiMTAwdmhcIjtcbiAgICAgICAgX2RpdjEwMHZoLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgICAgIF9yZWZyZXNoMTAwdmgoKTtcblxuICAgICAgICBfcmFmQnVnRml4KCk7XG5cbiAgICAgICAgT2JzZXJ2ZXIucmVnaXN0ZXIoZ3NhcCk7IC8vIGlzVG91Y2ggaXMgMCBpZiBubyB0b3VjaCwgMSBpZiBPTkxZIHRvdWNoLCBhbmQgMiBpZiBpdCBjYW4gYWNjb21tb2RhdGUgdG91Y2ggYnV0IGFsc28gb3RoZXIgdHlwZXMgbGlrZSBtb3VzZS9wb2ludGVyLlxuXG4gICAgICAgIFNjcm9sbFRyaWdnZXIuaXNUb3VjaCA9IE9ic2VydmVyLmlzVG91Y2g7XG4gICAgICAgIF9maXhJT1NCdWcgPSBPYnNlcnZlci5pc1RvdWNoICYmIC8oaVBhZHxpUGhvbmV8aVBvZHxNYWMpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gc2luY2UgMjAxNywgaU9TIGhhcyBoYWQgYSBidWcgdGhhdCBjYXVzZXMgZXZlbnQuY2xpZW50WC9ZIHRvIGJlIGluYWNjdXJhdGUgd2hlbiBhIHNjcm9sbCBvY2N1cnMsIHRodXMgd2UgbXVzdCBhbHRlcm5hdGUgaWdub3JpbmcgZXZlcnkgb3RoZXIgdG91Y2htb3ZlIGV2ZW50IHRvIHdvcmsgYXJvdW5kIGl0LiBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4MTk1NCBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vRXhiclBOYS8wODdjZWYxOTdkYzM1NDQ1YTA5NTFlODkzNWM0MTUwM1xuXG4gICAgICAgIF9pZ25vcmVNb2JpbGVSZXNpemUgPSBPYnNlcnZlci5pc1RvdWNoID09PSAxO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihfd2luLCBcIndoZWVsXCIsIF9vblNjcm9sbCk7IC8vIG1vc3RseSBmb3IgM3JkIHBhcnR5IHNtb290aCBzY3JvbGxpbmcgbGlicmFyaWVzLlxuXG5cbiAgICAgICAgX3Jvb3QgPSBbX3dpbiwgX2RvYywgX2RvY0VsLCBfYm9keV07XG5cbiAgICAgICAgaWYgKGdzYXAubWF0Y2hNZWRpYSkge1xuICAgICAgICAgIFNjcm9sbFRyaWdnZXIubWF0Y2hNZWRpYSA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gICAgICAgICAgICB2YXIgbW0gPSBnc2FwLm1hdGNoTWVkaWEoKSxcbiAgICAgICAgICAgICAgICBwO1xuXG4gICAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgICBtbS5hZGQocCwgdmFyc1twXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtbTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZ3NhcC5hZGRFdmVudExpc3RlbmVyKFwibWF0Y2hNZWRpYUluaXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZXZlcnRBbGwoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnc2FwLmFkZEV2ZW50TGlzdGVuZXIoXCJtYXRjaE1lZGlhUmV2ZXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmV2ZXJ0UmVjb3JkZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnc2FwLmFkZEV2ZW50TGlzdGVuZXIoXCJtYXRjaE1lZGlhXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9yZWZyZXNoQWxsKDAsIDEpO1xuXG4gICAgICAgICAgICBfZGlzcGF0Y2goXCJtYXRjaE1lZGlhXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdzYXAubWF0Y2hNZWRpYSgpLmFkZChcIihvcmllbnRhdGlvbjogcG9ydHJhaXQpXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gb3JpZW50YXRpb24gY2hhbmdlcywgd2Ugc2hvdWxkIHRha2UgbmV3IGJhc2UgbWVhc3VyZW1lbnRzIGZvciB0aGUgaWdub3JlTW9iaWxlUmVzaXplIGZlYXR1cmUuXG4gICAgICAgICAgICBfc2V0QmFzZURpbWVuc2lvbnMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIF9zZXRCYXNlRGltZW5zaW9ucztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJSZXF1aXJlcyBHU0FQIDMuMTEuMCBvciBsYXRlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRCYXNlRGltZW5zaW9ucygpO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihfZG9jLCBcInNjcm9sbFwiLCBfb25TY3JvbGwpOyAvLyBzb21lIGJyb3dzZXJzIChsaWtlIENocm9tZSksIHRoZSB3aW5kb3cgc3RvcHMgZGlzcGF0Y2hpbmcgc2Nyb2xsIGV2ZW50cyBvbiB0aGUgd2luZG93IGlmIHlvdSBzY3JvbGwgcmVhbGx5IGZhc3QsIGJ1dCBpdCdzIGNvbnNpc3RlbnQgb24gdGhlIGRvY3VtZW50IVxuXG5cbiAgICAgICAgdmFyIGJvZHlIYXNTdHlsZSA9IF9ib2R5Lmhhc0F0dHJpYnV0ZShcInN0eWxlXCIpLFxuICAgICAgICAgICAgYm9keVN0eWxlID0gX2JvZHkuc3R5bGUsXG4gICAgICAgICAgICBib3JkZXIgPSBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUsXG4gICAgICAgICAgICBBbmltYXRpb25Qcm90byA9IGdzYXAuY29yZS5BbmltYXRpb24ucHJvdG90eXBlLFxuICAgICAgICAgICAgYm91bmRzLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBBbmltYXRpb25Qcm90by5yZXZlcnQgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblByb3RvLCBcInJldmVydFwiLCB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZSgtMC4wMSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKEFuaW1hdGlvbi5yZXZlcnQoKSB3YXMgYWRkZWQgYWZ0ZXIgMy4xMC40KVxuXG4gICAgICAgIGJvZHlTdHlsZS5ib3JkZXJUb3BTdHlsZSA9IFwic29saWRcIjsgLy8gd29ya3MgYXJvdW5kIGFuIGlzc3VlIHdoZXJlIGEgbWFyZ2luIG9mIGEgY2hpbGQgZWxlbWVudCBjb3VsZCB0aHJvdyBvZmYgdGhlIGJvdW5kcyBvZiB0aGUgX2JvZHksIG1ha2luZyBpdCBzZWVtIGxpa2UgdGhlcmUncyBhIG1hcmdpbiB3aGVuIHRoZXJlIGFjdHVhbGx5IGlzbid0LiBUaGUgYm9yZGVyIGVuc3VyZXMgdGhhdCB0aGUgYm91bmRzIGFyZSBhY2N1cmF0ZS5cblxuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKF9ib2R5KTtcbiAgICAgICAgX3ZlcnRpY2FsLm0gPSBNYXRoLnJvdW5kKGJvdW5kcy50b3AgKyBfdmVydGljYWwuc2MoKSkgfHwgMDsgLy8gYWNjb21tb2RhdGUgdGhlIG9mZnNldCBvZiB0aGUgPGJvZHk+IGNhdXNlZCBieSBtYXJnaW5zIGFuZC9vciBwYWRkaW5nXG5cbiAgICAgICAgX2hvcml6b250YWwubSA9IE1hdGgucm91bmQoYm91bmRzLmxlZnQgKyBfaG9yaXpvbnRhbC5zYygpKSB8fCAwO1xuICAgICAgICBib3JkZXIgPyBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUgPSBib3JkZXIgOiBib2R5U3R5bGUucmVtb3ZlUHJvcGVydHkoXCJib3JkZXItdG9wLXN0eWxlXCIpO1xuXG4gICAgICAgIGlmICghYm9keUhhc1N0eWxlKSB7XG4gICAgICAgICAgLy8gU1NSIGZyYW1ld29ya3MgbGlrZSBOZXh0LmpzIGNvbXBsYWluIGlmIHRoaXMgYXR0cmlidXRlIGdldHMgYWRkZWQuXG4gICAgICAgICAgX2JvZHkuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIik7IC8vIGl0J3Mgbm90IGVub3VnaCB0byBqdXN0IHJlbW92ZUF0dHJpYnV0ZSgpIC0gd2UgbXVzdCBmaXJzdCBzZXQgaXQgdG8gZW1wdHksIG90aGVyd2lzZSBOZXh0LmpzIGNvbXBsYWlucy5cblxuXG4gICAgICAgICAgX2JvZHkucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICAgIH0gLy8gVE9ETzogKD8pIG1heWJlIG1vdmUgdG8gbGV2ZXJhZ2luZyB0aGUgdmVsb2NpdHkgbWVjaGFuaXNtIGluIE9ic2VydmVyIGFuZCBza2lwIGludGVydmFscy5cblxuXG4gICAgICAgIF9zeW5jSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChfc3luYywgMjUwKTtcbiAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbCgwLjUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3N0YXJ0dXAgPSAwO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfcGFzc1Rocm91Z2gpOyAvLyBzb21lIG9sZGVyIEFuZHJvaWQgZGV2aWNlcyBpbnRlcm1pdHRlbnRseSBzdG9wIGRpc3BhdGNoaW5nIFwidG91Y2htb3ZlXCIgZXZlbnRzIGlmIHdlIGRvbid0IGxpc3RlbiBmb3IgXCJ0b3VjaGNhbmNlbFwiIG9uIHRoZSBkb2N1bWVudC5cblxuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihfYm9keSwgXCJ0b3VjaHN0YXJ0XCIsIF9wYXNzVGhyb3VnaCk7IC8vd29ya3MgYXJvdW5kIFNhZmFyaSBidWc6IGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzIxNDUwLWRyYWdnYWJsZS1pbi1pZnJhbWUtb24tbW9iaWxlLWlzLWJ1Z2d5L1xuXG5cbiAgICAgICAgX211bHRpTGlzdGVuZXIoX2FkZExpc3RlbmVyLCBfZG9jLCBcInBvaW50ZXJkb3duLHRvdWNoc3RhcnQsbW91c2Vkb3duXCIsIF9wb2ludGVyRG93bkhhbmRsZXIpO1xuXG4gICAgICAgIF9tdWx0aUxpc3RlbmVyKF9hZGRMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBfcG9pbnRlclVwSGFuZGxlcik7XG5cbiAgICAgICAgX3RyYW5zZm9ybVByb3AgPSBnc2FwLnV0aWxzLmNoZWNrUHJlZml4KFwidHJhbnNmb3JtXCIpO1xuXG4gICAgICAgIF9zdGF0ZVByb3BzLnB1c2goX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgICAgIF9jb3JlSW5pdHRlZCA9IF9nZXRUaW1lKCk7XG4gICAgICAgIF9yZXNpemVEZWxheSA9IGdzYXAuZGVsYXllZENhbGwoMC4yLCBfcmVmcmVzaEFsbCkucGF1c2UoKTtcbiAgICAgICAgX2F1dG9SZWZyZXNoID0gW19kb2MsIFwidmlzaWJpbGl0eWNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHcgPSBfd2luLmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgIGggPSBfd2luLmlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKF9kb2MuaGlkZGVuKSB7XG4gICAgICAgICAgICBfcHJldldpZHRoID0gdztcbiAgICAgICAgICAgIF9wcmV2SGVpZ2h0ID0gaDtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9wcmV2V2lkdGggIT09IHcgfHwgX3ByZXZIZWlnaHQgIT09IGgpIHtcbiAgICAgICAgICAgIF9vblJlc2l6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2RvYywgXCJET01Db250ZW50TG9hZGVkXCIsIF9yZWZyZXNoQWxsLCBfd2luLCBcImxvYWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwicmVzaXplXCIsIF9vblJlc2l6ZV07XG5cbiAgICAgICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfYWRkTGlzdGVuZXIpO1xuXG4gICAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXIuZW5hYmxlKDAsIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3Njcm9sbGVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMV0pO1xuXG4gICAgICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5jb25maWcgPSBmdW5jdGlvbiBjb25maWcodmFycykge1xuICAgIFwibGltaXRDYWxsYmFja3NcIiBpbiB2YXJzICYmIChfbGltaXRDYWxsYmFja3MgPSAhIXZhcnMubGltaXRDYWxsYmFja3MpO1xuICAgIHZhciBtcyA9IHZhcnMuc3luY0ludGVydmFsO1xuICAgIG1zICYmIGNsZWFySW50ZXJ2YWwoX3N5bmNJbnRlcnZhbCkgfHwgKF9zeW5jSW50ZXJ2YWwgPSBtcykgJiYgc2V0SW50ZXJ2YWwoX3N5bmMsIG1zKTtcbiAgICBcImlnbm9yZU1vYmlsZVJlc2l6ZVwiIGluIHZhcnMgJiYgKF9pZ25vcmVNb2JpbGVSZXNpemUgPSBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggPT09IDEgJiYgdmFycy5pZ25vcmVNb2JpbGVSZXNpemUpO1xuXG4gICAgaWYgKFwiYXV0b1JlZnJlc2hFdmVudHNcIiBpbiB2YXJzKSB7XG4gICAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoKF9yZW1vdmVMaXN0ZW5lcikgfHwgX2l0ZXJhdGVBdXRvUmVmcmVzaChfYWRkTGlzdGVuZXIsIHZhcnMuYXV0b1JlZnJlc2hFdmVudHMgfHwgXCJub25lXCIpO1xuICAgICAgX2lnbm9yZVJlc2l6ZSA9ICh2YXJzLmF1dG9SZWZyZXNoRXZlbnRzICsgXCJcIikuaW5kZXhPZihcInJlc2l6ZVwiKSA9PT0gLTE7XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuc2Nyb2xsZXJQcm94eSA9IGZ1bmN0aW9uIHNjcm9sbGVyUHJveHkodGFyZ2V0LCB2YXJzKSB7XG4gICAgdmFyIHQgPSBfZ2V0VGFyZ2V0KHRhcmdldCksXG4gICAgICAgIGkgPSBfc2Nyb2xsZXJzLmluZGV4T2YodCksXG4gICAgICAgIGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydCh0KTtcblxuICAgIGlmICh+aSkge1xuICAgICAgX3Njcm9sbGVycy5zcGxpY2UoaSwgaXNWaWV3cG9ydCA/IDYgOiAyKTtcbiAgICB9XG5cbiAgICBpZiAodmFycykge1xuICAgICAgaXNWaWV3cG9ydCA/IF9wcm94aWVzLnVuc2hpZnQoX3dpbiwgdmFycywgX2JvZHksIHZhcnMsIF9kb2NFbCwgdmFycykgOiBfcHJveGllcy51bnNoaWZ0KHQsIHZhcnMpO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmNsZWFyTWF0Y2hNZWRpYSA9IGZ1bmN0aW9uIGNsZWFyTWF0Y2hNZWRpYShxdWVyeSkge1xuICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC5fY3R4ICYmIHQuX2N0eC5xdWVyeSA9PT0gcXVlcnkgJiYgdC5fY3R4LmtpbGwodHJ1ZSwgdHJ1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5pc0luVmlld3BvcnQgPSBmdW5jdGlvbiBpc0luVmlld3BvcnQoZWxlbWVudCwgcmF0aW8sIGhvcml6b250YWwpIHtcbiAgICB2YXIgYm91bmRzID0gKF9pc1N0cmluZyhlbGVtZW50KSA/IF9nZXRUYXJnZXQoZWxlbWVudCkgOiBlbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgb2Zmc2V0ID0gYm91bmRzW2hvcml6b250YWwgPyBfd2lkdGggOiBfaGVpZ2h0XSAqIHJhdGlvIHx8IDA7XG4gICAgcmV0dXJuIGhvcml6b250YWwgPyBib3VuZHMucmlnaHQgLSBvZmZzZXQgPiAwICYmIGJvdW5kcy5sZWZ0ICsgb2Zmc2V0IDwgX3dpbi5pbm5lcldpZHRoIDogYm91bmRzLmJvdHRvbSAtIG9mZnNldCA+IDAgJiYgYm91bmRzLnRvcCArIG9mZnNldCA8IF93aW4uaW5uZXJIZWlnaHQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5wb3NpdGlvbkluVmlld3BvcnQgPSBmdW5jdGlvbiBwb3NpdGlvbkluVmlld3BvcnQoZWxlbWVudCwgcmVmZXJlbmNlUG9pbnQsIGhvcml6b250YWwpIHtcbiAgICBfaXNTdHJpbmcoZWxlbWVudCkgJiYgKGVsZW1lbnQgPSBfZ2V0VGFyZ2V0KGVsZW1lbnQpKTtcbiAgICB2YXIgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgc2l6ZSA9IGJvdW5kc1tob3Jpem9udGFsID8gX3dpZHRoIDogX2hlaWdodF0sXG4gICAgICAgIG9mZnNldCA9IHJlZmVyZW5jZVBvaW50ID09IG51bGwgPyBzaXplIC8gMiA6IHJlZmVyZW5jZVBvaW50IGluIF9rZXl3b3JkcyA/IF9rZXl3b3Jkc1tyZWZlcmVuY2VQb2ludF0gKiBzaXplIDogfnJlZmVyZW5jZVBvaW50LmluZGV4T2YoXCIlXCIpID8gcGFyc2VGbG9hdChyZWZlcmVuY2VQb2ludCkgKiBzaXplIC8gMTAwIDogcGFyc2VGbG9hdChyZWZlcmVuY2VQb2ludCkgfHwgMDtcbiAgICByZXR1cm4gaG9yaXpvbnRhbCA/IChib3VuZHMubGVmdCArIG9mZnNldCkgLyBfd2luLmlubmVyV2lkdGggOiAoYm91bmRzLnRvcCArIG9mZnNldCkgLyBfd2luLmlubmVySGVpZ2h0O1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIua2lsbEFsbCA9IGZ1bmN0aW9uIGtpbGxBbGwoYWxsb3dMaXN0ZW5lcnMpIHtcbiAgICBfdHJpZ2dlcnMuc2xpY2UoMCkuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQudmFycy5pZCAhPT0gXCJTY3JvbGxTbW9vdGhlclwiICYmIHQua2lsbCgpO1xuICAgIH0pO1xuXG4gICAgaWYgKGFsbG93TGlzdGVuZXJzICE9PSB0cnVlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gX2xpc3RlbmVycy5raWxsQWxsIHx8IFtdO1xuICAgICAgX2xpc3RlbmVycyA9IHt9O1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2Nyb2xsVHJpZ2dlcjtcbn0oKTtcblNjcm9sbFRyaWdnZXIudmVyc2lvbiA9IFwiMy4xMi43XCI7XG5cblNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcyA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gIHJldHVybiB0YXJnZXRzID8gX3RvQXJyYXkodGFyZ2V0cykuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgLy8gc2F2ZWQgc3R5bGVzIGFyZSByZWNvcmRlZCBpbiBhIGNvbnNlY3V0aXZlIGFsdGVybmF0aW5nIEFycmF5LCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCB0cmFuc2Zvcm0gYXR0cmlidXRlLCBjYWNoZSwgbWF0Y2hNZWRpYSwgLi4uXVxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LnN0eWxlKSB7XG4gICAgICB2YXIgaSA9IF9zYXZlZFN0eWxlcy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgIGkgPj0gMCAmJiBfc2F2ZWRTdHlsZXMuc3BsaWNlKGksIDUpO1xuXG4gICAgICBfc2F2ZWRTdHlsZXMucHVzaCh0YXJnZXQsIHRhcmdldC5zdHlsZS5jc3NUZXh0LCB0YXJnZXQuZ2V0QkJveCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpLCBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KSwgX2NvbnRleHQoKSk7XG4gICAgfVxuICB9KSA6IF9zYXZlZFN0eWxlcztcbn07XG5cblNjcm9sbFRyaWdnZXIucmV2ZXJ0ID0gZnVuY3Rpb24gKHNvZnQsIG1lZGlhKSB7XG4gIHJldHVybiBfcmV2ZXJ0QWxsKCFzb2Z0LCBtZWRpYSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzLCBhbmltYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbik7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2FmZSkge1xuICByZXR1cm4gc2FmZSA/IF9vblJlc2l6ZSh0cnVlKSA6IChfY29yZUluaXR0ZWQgfHwgU2Nyb2xsVHJpZ2dlci5yZWdpc3RlcigpKSAmJiBfcmVmcmVzaEFsbCh0cnVlKTtcbn07XG5cblNjcm9sbFRyaWdnZXIudXBkYXRlID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gIHJldHVybiArK19zY3JvbGxlcnMuY2FjaGUgJiYgX3VwZGF0ZUFsbChmb3JjZSA9PT0gdHJ1ZSA/IDIgOiAwKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuY2xlYXJTY3JvbGxNZW1vcnkgPSBfY2xlYXJTY3JvbGxNZW1vcnk7XG5cblNjcm9sbFRyaWdnZXIubWF4U2Nyb2xsID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhvcml6b250YWwpIHtcbiAgcmV0dXJuIF9tYXhTY3JvbGwoZWxlbWVudCwgaG9yaXpvbnRhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuZ2V0U2Nyb2xsRnVuYyA9IGZ1bmN0aW9uIChlbGVtZW50LCBob3Jpem9udGFsKSB7XG4gIHJldHVybiBfZ2V0U2Nyb2xsRnVuYyhfZ2V0VGFyZ2V0KGVsZW1lbnQpLCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBfaWRzW2lkXTtcbn07XG5cblNjcm9sbFRyaWdnZXIuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX3RyaWdnZXJzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnZhcnMuaWQgIT09IFwiU2Nyb2xsU21vb3RoZXJcIjtcbiAgfSk7XG59OyAvLyBpdCdzIGNvbW1vbiBmb3IgcGVvcGxlIHRvIFNjcm9sbFRyaWdnZXIuZ2V0QWxsKHQgPT4gdC5raWxsKCkpIG9uIHBhZ2Ugcm91dGVzLCBmb3IgZXhhbXBsZSwgYW5kIHdlIGRvbid0IHdhbnQgaXQgdG8gcnVpbiBzbW9vdGggc2Nyb2xsaW5nIGJ5IGtpbGxpbmcgdGhlIG1haW4gU2Nyb2xsU21vb3RoZXIgb25lLlxuXG5cblNjcm9sbFRyaWdnZXIuaXNTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIV9sYXN0U2Nyb2xsVGltZTtcbn07XG5cblNjcm9sbFRyaWdnZXIuc25hcERpcmVjdGlvbmFsID0gX3NuYXBEaXJlY3Rpb25hbDtcblxuU2Nyb2xsVHJpZ2dlci5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSB8fCAoX2xpc3RlbmVyc1t0eXBlXSA9IFtdKTtcbiAgfmEuaW5kZXhPZihjYWxsYmFjaykgfHwgYS5wdXNoKGNhbGxiYWNrKTtcbn07XG5cblNjcm9sbFRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICB2YXIgYSA9IF9saXN0ZW5lcnNbdHlwZV0sXG4gICAgICBpID0gYSAmJiBhLmluZGV4T2YoY2FsbGJhY2spO1xuICBpID49IDAgJiYgYS5zcGxpY2UoaSwgMSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmJhdGNoID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgdmFyc0NvcHkgPSB7fSxcbiAgICAgIGludGVydmFsID0gdmFycy5pbnRlcnZhbCB8fCAwLjAxNixcbiAgICAgIGJhdGNoTWF4ID0gdmFycy5iYXRjaE1heCB8fCAxZTksXG4gICAgICBwcm94eUNhbGxiYWNrID0gZnVuY3Rpb24gcHJveHlDYWxsYmFjayh0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBlbGVtZW50cyA9IFtdLFxuICAgICAgICB0cmlnZ2VycyA9IFtdLFxuICAgICAgICBkZWxheSA9IGdzYXAuZGVsYXllZENhbGwoaW50ZXJ2YWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGVsZW1lbnRzLCB0cmlnZ2Vycyk7XG4gICAgICBlbGVtZW50cyA9IFtdO1xuICAgICAgdHJpZ2dlcnMgPSBbXTtcbiAgICB9KS5wYXVzZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgZWxlbWVudHMubGVuZ3RoIHx8IGRlbGF5LnJlc3RhcnQodHJ1ZSk7XG4gICAgICBlbGVtZW50cy5wdXNoKHNlbGYudHJpZ2dlcik7XG4gICAgICB0cmlnZ2Vycy5wdXNoKHNlbGYpO1xuICAgICAgYmF0Y2hNYXggPD0gZWxlbWVudHMubGVuZ3RoICYmIGRlbGF5LnByb2dyZXNzKDEpO1xuICAgIH07XG4gIH0sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiB2YXJzKSB7XG4gICAgdmFyc0NvcHlbcF0gPSBwLnN1YnN0cigwLCAyKSA9PT0gXCJvblwiICYmIF9pc0Z1bmN0aW9uKHZhcnNbcF0pICYmIHAgIT09IFwib25SZWZyZXNoSW5pdFwiID8gcHJveHlDYWxsYmFjayhwLCB2YXJzW3BdKSA6IHZhcnNbcF07XG4gIH1cblxuICBpZiAoX2lzRnVuY3Rpb24oYmF0Y2hNYXgpKSB7XG4gICAgYmF0Y2hNYXggPSBiYXRjaE1heCgpO1xuXG4gICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmF0Y2hNYXggPSB2YXJzLmJhdGNoTWF4KCk7XG4gICAgfSk7XG4gIH1cblxuICBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB2YXIgY29uZmlnID0ge307XG5cbiAgICBmb3IgKHAgaW4gdmFyc0NvcHkpIHtcbiAgICAgIGNvbmZpZ1twXSA9IHZhcnNDb3B5W3BdO1xuICAgIH1cblxuICAgIGNvbmZpZy50cmlnZ2VyID0gdGFyZ2V0O1xuICAgIHJlc3VsdC5wdXNoKFNjcm9sbFRyaWdnZXIuY3JlYXRlKGNvbmZpZykpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTsgLy8gdG8gcmVkdWNlIGZpbGUgc2l6ZS4gY2xhbXBzIHRoZSBzY3JvbGwgYW5kIGFsc28gcmV0dXJucyBhIGR1cmF0aW9uIG11bHRpcGxpZXIgc28gdGhhdCBpZiB0aGUgc2Nyb2xsIGdldHMgY2hvcHBlZCBzaG9ydGVyLCB0aGUgZHVyYXRpb24gZ2V0cyBjdXJ0YWlsZWQgYXMgd2VsbCAob3RoZXJ3aXNlIGlmIHlvdSdyZSB2ZXJ5IGNsb3NlIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UsIGZvciBleGFtcGxlLCBhbmQgc3dpcGUgdXAgcmVhbGx5IGZhc3QsIGl0J2xsIHN1ZGRlbmx5IHNsb3cgZG93biBhbmQgdGFrZSBhIGxvbmcgdGltZSB0byByZWFjaCB0aGUgdG9wKS5cblxuXG52YXIgX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyID0gZnVuY3Rpb24gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmMsIGN1cnJlbnQsIGVuZCwgbWF4KSB7XG4gIGN1cnJlbnQgPiBtYXggPyBzY3JvbGxGdW5jKG1heCkgOiBjdXJyZW50IDwgMCAmJiBzY3JvbGxGdW5jKDApO1xuICByZXR1cm4gZW5kID4gbWF4ID8gKG1heCAtIGN1cnJlbnQpIC8gKGVuZCAtIGN1cnJlbnQpIDogZW5kIDwgMCA/IGN1cnJlbnQgLyAoY3VycmVudCAtIGVuZCkgOiAxO1xufSxcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nID0gZnVuY3Rpb24gX2FsbG93TmF0aXZlUGFubmluZyh0YXJnZXQsIGRpcmVjdGlvbikge1xuICBpZiAoZGlyZWN0aW9uID09PSB0cnVlKSB7XG4gICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidG91Y2gtYWN0aW9uXCIpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5zdHlsZS50b3VjaEFjdGlvbiA9IGRpcmVjdGlvbiA9PT0gdHJ1ZSA/IFwiYXV0b1wiIDogZGlyZWN0aW9uID8gXCJwYW4tXCIgKyBkaXJlY3Rpb24gKyAoT2JzZXJ2ZXIuaXNUb3VjaCA/IFwiIHBpbmNoLXpvb21cIiA6IFwiXCIpIDogXCJub25lXCI7IC8vIG5vdGU6IEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IGl0IHBpbmNoLXpvb20gcHJvcGVybHksIGF0IGxlYXN0IGluIGFkZGl0aW9uIHRvIGEgcGFuLXggb3IgcGFuLXkuXG4gIH1cblxuICB0YXJnZXQgPT09IF9kb2NFbCAmJiBfYWxsb3dOYXRpdmVQYW5uaW5nKF9ib2R5LCBkaXJlY3Rpb24pO1xufSxcbiAgICBfb3ZlcmZsb3cgPSB7XG4gIGF1dG86IDEsXG4gIHNjcm9sbDogMVxufSxcbiAgICBfbmVzdGVkU2Nyb2xsID0gZnVuY3Rpb24gX25lc3RlZFNjcm9sbChfcmVmNSkge1xuICB2YXIgZXZlbnQgPSBfcmVmNS5ldmVudCxcbiAgICAgIHRhcmdldCA9IF9yZWY1LnRhcmdldCxcbiAgICAgIGF4aXMgPSBfcmVmNS5heGlzO1xuXG4gIHZhciBub2RlID0gKGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudCkudGFyZ2V0LFxuICAgICAgY2FjaGUgPSBub2RlLl9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZShub2RlKSxcbiAgICAgIHRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgY3M7XG5cbiAgaWYgKCFjYWNoZS5faXNTY3JvbGxUIHx8IHRpbWUgLSBjYWNoZS5faXNTY3JvbGxUID4gMjAwMCkge1xuICAgIC8vIGNhY2hlIGZvciAyIHNlY29uZHMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBfYm9keSAmJiAobm9kZS5zY3JvbGxIZWlnaHQgPD0gbm9kZS5jbGllbnRIZWlnaHQgJiYgbm9kZS5zY3JvbGxXaWR0aCA8PSBub2RlLmNsaWVudFdpZHRoIHx8ICEoX292ZXJmbG93WyhjcyA9IF9nZXRDb21wdXRlZFN0eWxlKG5vZGUpKS5vdmVyZmxvd1ldIHx8IF9vdmVyZmxvd1tjcy5vdmVyZmxvd1hdKSkpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgY2FjaGUuX2lzU2Nyb2xsID0gbm9kZSAmJiBub2RlICE9PSB0YXJnZXQgJiYgIV9pc1ZpZXdwb3J0KG5vZGUpICYmIChfb3ZlcmZsb3dbKGNzID0gX2dldENvbXB1dGVkU3R5bGUobm9kZSkpLm92ZXJmbG93WV0gfHwgX292ZXJmbG93W2NzLm92ZXJmbG93WF0pO1xuICAgIGNhY2hlLl9pc1Njcm9sbFQgPSB0aW1lO1xuICB9XG5cbiAgaWYgKGNhY2hlLl9pc1Njcm9sbCB8fCBheGlzID09PSBcInhcIikge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50Ll9nc2FwQWxsb3cgPSB0cnVlO1xuICB9XG59LFxuICAgIC8vIGNhcHR1cmUgZXZlbnRzIG9uIHNjcm9sbGFibGUgZWxlbWVudHMgSU5TSURFIHRoZSA8Ym9keT4gYW5kIGFsbG93IHRob3NlIGJ5IGNhbGxpbmcgc3RvcFByb3BhZ2F0aW9uKCkgd2hlbiB3ZSBmaW5kIGEgc2Nyb2xsYWJsZSBhbmNlc3RvclxuX2lucHV0T2JzZXJ2ZXIgPSBmdW5jdGlvbiBfaW5wdXRPYnNlcnZlcih0YXJnZXQsIHR5cGUsIGlucHV0cywgbmVzdGVkKSB7XG4gIHJldHVybiBPYnNlcnZlci5jcmVhdGUoe1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgZGVib3VuY2U6IGZhbHNlLFxuICAgIGxvY2tBeGlzOiB0cnVlLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgb25XaGVlbDogbmVzdGVkID0gbmVzdGVkICYmIF9uZXN0ZWRTY3JvbGwsXG4gICAgb25QcmVzczogbmVzdGVkLFxuICAgIG9uRHJhZzogbmVzdGVkLFxuICAgIG9uU2Nyb2xsOiBuZXN0ZWQsXG4gICAgb25FbmFibGU6IGZ1bmN0aW9uIG9uRW5hYmxlKCkge1xuICAgICAgcmV0dXJuIGlucHV0cyAmJiBfYWRkTGlzdGVuZXIoX2RvYywgT2JzZXJ2ZXIuZXZlbnRUeXBlc1swXSwgX2NhcHR1cmVJbnB1dHMsIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uRGlzYWJsZTogZnVuY3Rpb24gb25EaXNhYmxlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihfZG9jLCBPYnNlcnZlci5ldmVudFR5cGVzWzBdLCBfY2FwdHVyZUlucHV0cywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn0sXG4gICAgX2lucHV0RXhwID0gLyhpbnB1dHxsYWJlbHxzZWxlY3R8dGV4dGFyZWEpL2ksXG4gICAgX2lucHV0SXNGb2N1c2VkLFxuICAgIF9jYXB0dXJlSW5wdXRzID0gZnVuY3Rpb24gX2NhcHR1cmVJbnB1dHMoZSkge1xuICB2YXIgaXNJbnB1dCA9IF9pbnB1dEV4cC50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpO1xuXG4gIGlmIChpc0lucHV0IHx8IF9pbnB1dElzRm9jdXNlZCkge1xuICAgIGUuX2dzYXBBbGxvdyA9IHRydWU7XG4gICAgX2lucHV0SXNGb2N1c2VkID0gaXNJbnB1dDtcbiAgfVxufSxcbiAgICBfZ2V0U2Nyb2xsTm9ybWFsaXplciA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxOb3JtYWxpemVyKHZhcnMpIHtcbiAgX2lzT2JqZWN0KHZhcnMpIHx8ICh2YXJzID0ge30pO1xuICB2YXJzLnByZXZlbnREZWZhdWx0ID0gdmFycy5pc05vcm1hbGl6ZXIgPSB2YXJzLmFsbG93Q2xpY2tzID0gdHJ1ZTtcbiAgdmFycy50eXBlIHx8ICh2YXJzLnR5cGUgPSBcIndoZWVsLHRvdWNoXCIpO1xuICB2YXJzLmRlYm91bmNlID0gISF2YXJzLmRlYm91bmNlO1xuICB2YXJzLmlkID0gdmFycy5pZCB8fCBcIm5vcm1hbGl6ZXJcIjtcblxuICB2YXIgX3ZhcnMyID0gdmFycyxcbiAgICAgIG5vcm1hbGl6ZVNjcm9sbFggPSBfdmFyczIubm9ybWFsaXplU2Nyb2xsWCxcbiAgICAgIG1vbWVudHVtID0gX3ZhcnMyLm1vbWVudHVtLFxuICAgICAgYWxsb3dOZXN0ZWRTY3JvbGwgPSBfdmFyczIuYWxsb3dOZXN0ZWRTY3JvbGwsXG4gICAgICBvblJlbGVhc2UgPSBfdmFyczIub25SZWxlYXNlLFxuICAgICAgc2VsZixcbiAgICAgIG1heFksXG4gICAgICB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHZhcnMudGFyZ2V0KSB8fCBfZG9jRWwsXG4gICAgICBzbW9vdGhlciA9IGdzYXAuY29yZS5nbG9iYWxzKCkuU2Nyb2xsU21vb3RoZXIsXG4gICAgICBzbW9vdGhlckluc3RhbmNlID0gc21vb3RoZXIgJiYgc21vb3RoZXIuZ2V0KCksXG4gICAgICBjb250ZW50ID0gX2ZpeElPU0J1ZyAmJiAodmFycy5jb250ZW50ICYmIF9nZXRUYXJnZXQodmFycy5jb250ZW50KSB8fCBzbW9vdGhlckluc3RhbmNlICYmIHZhcnMuY29udGVudCAhPT0gZmFsc2UgJiYgIXNtb290aGVySW5zdGFuY2Uuc21vb3RoKCkgJiYgc21vb3RoZXJJbnN0YW5jZS5jb250ZW50KCkpLFxuICAgICAgc2Nyb2xsRnVuY1kgPSBfZ2V0U2Nyb2xsRnVuYyh0YXJnZXQsIF92ZXJ0aWNhbCksXG4gICAgICBzY3JvbGxGdW5jWCA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX2hvcml6b250YWwpLFxuICAgICAgc2NhbGUgPSAxLFxuICAgICAgaW5pdGlhbFNjYWxlID0gKE9ic2VydmVyLmlzVG91Y2ggJiYgX3dpbi52aXN1YWxWaWV3cG9ydCA/IF93aW4udmlzdWFsVmlld3BvcnQuc2NhbGUgKiBfd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogX3dpbi5vdXRlcldpZHRoKSAvIF93aW4uaW5uZXJXaWR0aCxcbiAgICAgIHdoZWVsUmVmcmVzaCA9IDAsXG4gICAgICByZXNvbHZlTW9tZW50dW1EdXJhdGlvbiA9IF9pc0Z1bmN0aW9uKG1vbWVudHVtKSA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9tZW50dW0oc2VsZik7XG4gIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1vbWVudHVtIHx8IDIuODtcbiAgfSxcbiAgICAgIGxhc3RSZWZyZXNoSUQsXG4gICAgICBza2lwVG91Y2hNb3ZlLFxuICAgICAgaW5wdXRPYnNlcnZlciA9IF9pbnB1dE9ic2VydmVyKHRhcmdldCwgdmFycy50eXBlLCB0cnVlLCBhbGxvd05lc3RlZFNjcm9sbCksXG4gICAgICByZXN1bWVUb3VjaE1vdmUgPSBmdW5jdGlvbiByZXN1bWVUb3VjaE1vdmUoKSB7XG4gICAgcmV0dXJuIHNraXBUb3VjaE1vdmUgPSBmYWxzZTtcbiAgfSxcbiAgICAgIHNjcm9sbENsYW1wWCA9IF9wYXNzVGhyb3VnaCxcbiAgICAgIHNjcm9sbENsYW1wWSA9IF9wYXNzVGhyb3VnaCxcbiAgICAgIHVwZGF0ZUNsYW1wcyA9IGZ1bmN0aW9uIHVwZGF0ZUNsYW1wcygpIHtcbiAgICBtYXhZID0gX21heFNjcm9sbCh0YXJnZXQsIF92ZXJ0aWNhbCk7XG4gICAgc2Nyb2xsQ2xhbXBZID0gX2NsYW1wKF9maXhJT1NCdWcgPyAxIDogMCwgbWF4WSk7XG4gICAgbm9ybWFsaXplU2Nyb2xsWCAmJiAoc2Nyb2xsQ2xhbXBYID0gX2NsYW1wKDAsIF9tYXhTY3JvbGwodGFyZ2V0LCBfaG9yaXpvbnRhbCkpKTtcbiAgICBsYXN0UmVmcmVzaElEID0gX3JlZnJlc2hJRDtcbiAgfSxcbiAgICAgIHJlbW92ZUNvbnRlbnRPZmZzZXQgPSBmdW5jdGlvbiByZW1vdmVDb250ZW50T2Zmc2V0KCkge1xuICAgIGNvbnRlbnQuX2dzYXAueSA9IF9yb3VuZChwYXJzZUZsb2F0KGNvbnRlbnQuX2dzYXAueSkgKyBzY3JvbGxGdW5jWS5vZmZzZXQpICsgXCJweFwiO1xuICAgIGNvbnRlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJtYXRyaXgzZCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCBcIiArIHBhcnNlRmxvYXQoY29udGVudC5fZ3NhcC55KSArIFwiLCAwLCAxKVwiO1xuICAgIHNjcm9sbEZ1bmNZLm9mZnNldCA9IHNjcm9sbEZ1bmNZLmNhY2hlSUQgPSAwO1xuICB9LFxuICAgICAgaWdub3JlRHJhZyA9IGZ1bmN0aW9uIGlnbm9yZURyYWcoKSB7XG4gICAgaWYgKHNraXBUb3VjaE1vdmUpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWVUb3VjaE1vdmUpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gX3JvdW5kKHNlbGYuZGVsdGFZIC8gMiksXG4gICAgICAgICAgc2Nyb2xsID0gc2Nyb2xsQ2xhbXBZKHNjcm9sbEZ1bmNZLnYgLSBvZmZzZXQpO1xuXG4gICAgICBpZiAoY29udGVudCAmJiBzY3JvbGwgIT09IHNjcm9sbEZ1bmNZLnYgKyBzY3JvbGxGdW5jWS5vZmZzZXQpIHtcbiAgICAgICAgc2Nyb2xsRnVuY1kub2Zmc2V0ID0gc2Nyb2xsIC0gc2Nyb2xsRnVuY1kudjtcblxuICAgICAgICB2YXIgeSA9IF9yb3VuZCgocGFyc2VGbG9hdChjb250ZW50ICYmIGNvbnRlbnQuX2dzYXAueSkgfHwgMCkgLSBzY3JvbGxGdW5jWS5vZmZzZXQpO1xuXG4gICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJtYXRyaXgzZCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCBcIiArIHkgKyBcIiwgMCwgMSlcIjtcbiAgICAgICAgY29udGVudC5fZ3NhcC55ID0geSArIFwicHhcIjtcbiAgICAgICAgc2Nyb2xsRnVuY1kuY2FjaGVJRCA9IF9zY3JvbGxlcnMuY2FjaGU7XG5cbiAgICAgICAgX3VwZGF0ZUFsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzY3JvbGxGdW5jWS5vZmZzZXQgJiYgcmVtb3ZlQ29udGVudE9mZnNldCgpO1xuICAgIHNraXBUb3VjaE1vdmUgPSB0cnVlO1xuICB9LFxuICAgICAgdHdlZW4sXG4gICAgICBzdGFydFNjcm9sbFgsXG4gICAgICBzdGFydFNjcm9sbFksXG4gICAgICBvblN0b3BEZWxheWVkQ2FsbCxcbiAgICAgIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgLy8gaWYgdGhlIHdpbmRvdyByZXNpemVzLCBsaWtlIG9uIGFuIGlQaG9uZSB3aGljaCBBcHBsZSBGT1JDRVMgdGhlIGFkZHJlc3MgYmFyIHRvIHNob3cvaGlkZSBldmVuIGlmIHdlIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGl0IG1heSBiZSBzY3JvbGxpbmcgdG9vIGZhciBub3cgdGhhdCB0aGUgYWRkcmVzcyBiYXIgaXMgc2hvd2luZywgc28gd2UgbXVzdCBkeW5hbWljYWxseSBhZGp1c3QgdGhlIG1vbWVudHVtIHR3ZWVuLlxuICAgIHVwZGF0ZUNsYW1wcygpO1xuXG4gICAgaWYgKHR3ZWVuLmlzQWN0aXZlKCkgJiYgdHdlZW4udmFycy5zY3JvbGxZID4gbWF4WSkge1xuICAgICAgc2Nyb2xsRnVuY1koKSA+IG1heFkgPyB0d2Vlbi5wcm9ncmVzcygxKSAmJiBzY3JvbGxGdW5jWShtYXhZKSA6IHR3ZWVuLnJlc2V0VG8oXCJzY3JvbGxZXCIsIG1heFkpO1xuICAgIH1cbiAgfTtcblxuICBjb250ZW50ICYmIGdzYXAuc2V0KGNvbnRlbnQsIHtcbiAgICB5OiBcIis9MFwiXG4gIH0pOyAvLyB0byBlbnN1cmUgdGhlcmUncyBhIGNhY2hlIChlbGVtZW50Ll9nc2FwKVxuXG4gIHZhcnMuaWdub3JlQ2hlY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBfZml4SU9TQnVnICYmIGUudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiBpZ25vcmVEcmFnKGUpIHx8IHNjYWxlID4gMS4wNSAmJiBlLnR5cGUgIT09IFwidG91Y2hzdGFydFwiIHx8IHNlbGYuaXNHZXN0dXJpbmcgfHwgZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxO1xuICB9O1xuXG4gIHZhcnMub25QcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBza2lwVG91Y2hNb3ZlID0gZmFsc2U7XG4gICAgdmFyIHByZXZTY2FsZSA9IHNjYWxlO1xuICAgIHNjYWxlID0gX3JvdW5kKChfd2luLnZpc3VhbFZpZXdwb3J0ICYmIF93aW4udmlzdWFsVmlld3BvcnQuc2NhbGUgfHwgMSkgLyBpbml0aWFsU2NhbGUpO1xuICAgIHR3ZWVuLnBhdXNlKCk7XG4gICAgcHJldlNjYWxlICE9PSBzY2FsZSAmJiBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgc2NhbGUgPiAxLjAxID8gdHJ1ZSA6IG5vcm1hbGl6ZVNjcm9sbFggPyBmYWxzZSA6IFwieFwiKTtcbiAgICBzdGFydFNjcm9sbFggPSBzY3JvbGxGdW5jWCgpO1xuICAgIHN0YXJ0U2Nyb2xsWSA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgdXBkYXRlQ2xhbXBzKCk7XG4gICAgbGFzdFJlZnJlc2hJRCA9IF9yZWZyZXNoSUQ7XG4gIH07XG5cbiAgdmFycy5vblJlbGVhc2UgPSB2YXJzLm9uR2VzdHVyZVN0YXJ0ID0gZnVuY3Rpb24gKHNlbGYsIHdhc0RyYWdnaW5nKSB7XG4gICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcblxuICAgIGlmICghd2FzRHJhZ2dpbmcpIHtcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zY3JvbGxlcnMuY2FjaGUrKzsgLy8gbWFrZSBzdXJlIHdlJ3JlIHB1bGxpbmcgdGhlIG5vbi1jYWNoZWQgdmFsdWVcbiAgICAgIC8vIGFsdGVybmF0ZSBhbGdvcml0aG06IGR1clggPSBNYXRoLm1pbig2LCBNYXRoLmFicyhzZWxmLnZlbG9jaXR5WCAvIDgwMCkpLFx0ZHVyID0gTWF0aC5tYXgoZHVyWCwgTWF0aC5taW4oNiwgTWF0aC5hYnMoc2VsZi52ZWxvY2l0eVkgLyA4MDApKSk7IGR1ciA9IGR1ciAqICgwLjQgKyAoMSAtIF9wb3dlcjRJbihkdXIgLyA2KSkgKiAwLjYpKSAqIChtb21lbnR1bVNwZWVkIHx8IDEpXG5cbiAgICAgIHZhciBkdXIgPSByZXNvbHZlTW9tZW50dW1EdXJhdGlvbigpLFxuICAgICAgICAgIGN1cnJlbnRTY3JvbGwsXG4gICAgICAgICAgZW5kU2Nyb2xsO1xuXG4gICAgICBpZiAobm9ybWFsaXplU2Nyb2xsWCkge1xuICAgICAgICBjdXJyZW50U2Nyb2xsID0gc2Nyb2xsRnVuY1goKTtcbiAgICAgICAgZW5kU2Nyb2xsID0gY3VycmVudFNjcm9sbCArIGR1ciAqIDAuMDUgKiAtc2VsZi52ZWxvY2l0eVggLyAwLjIyNzsgLy8gdGhlIGNvbnN0YW50IC4yMjcgaXMgZnJvbSBwb3dlcjQoMC4wNSkuIHZlbG9jaXR5IGlzIGludmVydGVkIGJlY2F1c2Ugc2Nyb2xsaW5nIGdvZXMgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cblxuICAgICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNYLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfaG9yaXpvbnRhbCkpO1xuICAgICAgICB0d2Vlbi52YXJzLnNjcm9sbFggPSBzY3JvbGxDbGFtcFgoZW5kU2Nyb2xsKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFNjcm9sbCA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgICBlbmRTY3JvbGwgPSBjdXJyZW50U2Nyb2xsICsgZHVyICogMC4wNSAqIC1zZWxmLnZlbG9jaXR5WSAvIDAuMjI3OyAvLyB0aGUgY29uc3RhbnQgLjIyNyBpcyBmcm9tIHBvd2VyNCgwLjA1KVxuXG4gICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNZLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfdmVydGljYWwpKTtcbiAgICAgIHR3ZWVuLnZhcnMuc2Nyb2xsWSA9IHNjcm9sbENsYW1wWShlbmRTY3JvbGwpO1xuICAgICAgdHdlZW4uaW52YWxpZGF0ZSgpLmR1cmF0aW9uKGR1cikucGxheSgwLjAxKTtcblxuICAgICAgaWYgKF9maXhJT1NCdWcgJiYgdHdlZW4udmFycy5zY3JvbGxZID49IG1heFkgfHwgY3VycmVudFNjcm9sbCA+PSBtYXhZIC0gMSkge1xuICAgICAgICAvLyBpT1MgYnVnOiBpdCdsbCBzaG93IHRoZSBhZGRyZXNzIGJhciBidXQgTk9UIGZpcmUgdGhlIHdpbmRvdyBcInJlc2l6ZVwiIGV2ZW50IHVudGlsIHRoZSBhbmltYXRpb24gaXMgZG9uZSBidXQgd2UgbXVzdCBwcm90ZWN0IGFnYWluc3Qgb3ZlcnNob290IHNvIHdlIGxldmVyYWdlIGFuIG9uVXBkYXRlIHRvIGRvIHNvLlxuICAgICAgICBnc2FwLnRvKHt9LCB7XG4gICAgICAgICAgb25VcGRhdGU6IG9uUmVzaXplLFxuICAgICAgICAgIGR1cmF0aW9uOiBkdXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb25SZWxlYXNlICYmIG9uUmVsZWFzZShzZWxmKTtcbiAgfTtcblxuICB2YXJzLm9uV2hlZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHdlZW4uX3RzICYmIHR3ZWVuLnBhdXNlKCk7XG5cbiAgICBpZiAoX2dldFRpbWUoKSAtIHdoZWVsUmVmcmVzaCA+IDEwMDApIHtcbiAgICAgIC8vIGFmdGVyIDEgc2Vjb25kLCByZWZyZXNoIHRoZSBjbGFtcHMgb3RoZXJ3aXNlIHRoYXQnbGwgb25seSBoYXBwZW4gd2hlbiBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSBpcyBjYWxsZWQgb3IgZm9yIHRvdWNoLXNjcm9sbGluZy5cbiAgICAgIGxhc3RSZWZyZXNoSUQgPSAwO1xuICAgICAgd2hlZWxSZWZyZXNoID0gX2dldFRpbWUoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFycy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChzZWxmLCBkeCwgZHksIHhBcnJheSwgeUFycmF5KSB7XG4gICAgX3JlZnJlc2hJRCAhPT0gbGFzdFJlZnJlc2hJRCAmJiB1cGRhdGVDbGFtcHMoKTtcbiAgICBkeCAmJiBub3JtYWxpemVTY3JvbGxYICYmIHNjcm9sbEZ1bmNYKHNjcm9sbENsYW1wWCh4QXJyYXlbMl0gPT09IGR4ID8gc3RhcnRTY3JvbGxYICsgKHNlbGYuc3RhcnRYIC0gc2VsZi54KSA6IHNjcm9sbEZ1bmNYKCkgKyBkeCAtIHhBcnJheVsxXSkpOyAvLyBmb3IgbW9yZSBwcmVjaXNpb24sIHdlIHRyYWNrIHBvaW50ZXIvdG91Y2ggbW92ZW1lbnQgZnJvbSB0aGUgc3RhcnQsIG90aGVyd2lzZSBpdCdsbCBkcmlmdC5cblxuICAgIGlmIChkeSkge1xuICAgICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcbiAgICAgIHZhciBpc1RvdWNoID0geUFycmF5WzJdID09PSBkeSxcbiAgICAgICAgICB5ID0gaXNUb3VjaCA/IHN0YXJ0U2Nyb2xsWSArIHNlbGYuc3RhcnRZIC0gc2VsZi55IDogc2Nyb2xsRnVuY1koKSArIGR5IC0geUFycmF5WzFdLFxuICAgICAgICAgIHlDbGFtcGVkID0gc2Nyb2xsQ2xhbXBZKHkpO1xuICAgICAgaXNUb3VjaCAmJiB5ICE9PSB5Q2xhbXBlZCAmJiAoc3RhcnRTY3JvbGxZICs9IHlDbGFtcGVkIC0geSk7XG4gICAgICBzY3JvbGxGdW5jWSh5Q2xhbXBlZCk7XG4gICAgfVxuXG4gICAgKGR5IHx8IGR4KSAmJiBfdXBkYXRlQWxsKCk7XG4gIH07XG5cbiAgdmFycy5vbkVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgbm9ybWFsaXplU2Nyb2xsWCA/IGZhbHNlIDogXCJ4XCIpO1xuXG4gICAgU2Nyb2xsVHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwicmVmcmVzaFwiLCBvblJlc2l6ZSk7XG5cbiAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJyZXNpemVcIiwgb25SZXNpemUpO1xuXG4gICAgaWYgKHNjcm9sbEZ1bmNZLnNtb290aCkge1xuICAgICAgc2Nyb2xsRnVuY1kudGFyZ2V0LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJhdXRvXCI7XG4gICAgICBzY3JvbGxGdW5jWS5zbW9vdGggPSBzY3JvbGxGdW5jWC5zbW9vdGggPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpbnB1dE9ic2VydmVyLmVuYWJsZSgpO1xuICB9O1xuXG4gIHZhcnMub25EaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIF9hbGxvd05hdGl2ZVBhbm5pbmcodGFyZ2V0LCB0cnVlKTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG5cbiAgICBTY3JvbGxUcmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWZyZXNoXCIsIG9uUmVzaXplKTtcbiAgICBpbnB1dE9ic2VydmVyLmtpbGwoKTtcbiAgfTtcblxuICB2YXJzLmxvY2tBeGlzID0gdmFycy5sb2NrQXhpcyAhPT0gZmFsc2U7XG4gIHNlbGYgPSBuZXcgT2JzZXJ2ZXIodmFycyk7XG4gIHNlbGYuaU9TID0gX2ZpeElPU0J1ZzsgLy8gdXNlZCBpbiB0aGUgT2JzZXJ2ZXIgZ2V0Q2FjaGVkU2Nyb2xsKCkgZnVuY3Rpb24gdG8gd29yayBhcm91bmQgYW4gaU9TIGJ1ZyB0aGF0IHdyZWFrcyBoYXZvYyB3aXRoIFRvdWNoRXZlbnQuY2xpZW50WSBpZiB3ZSBhbGxvdyBzY3JvbGwgdG8gZ28gYWxsIHRoZSB3YXkgYmFjayB0byAwLlxuXG4gIF9maXhJT1NCdWcgJiYgIXNjcm9sbEZ1bmNZKCkgJiYgc2Nyb2xsRnVuY1koMSk7IC8vIGlPUyBidWcgY2F1c2VzIGV2ZW50LmNsaWVudFkgdmFsdWVzIHRvIGZyZWFrIG91dCAod2lsZGx5IGluYWNjdXJhdGUpIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgZXhhY3RseSAwLlxuXG4gIF9maXhJT1NCdWcgJiYgZ3NhcC50aWNrZXIuYWRkKF9wYXNzVGhyb3VnaCk7IC8vIHByZXZlbnQgdGhlIHRpY2tlciBmcm9tIHNsZWVwaW5nXG5cbiAgb25TdG9wRGVsYXllZENhbGwgPSBzZWxmLl9kYztcbiAgdHdlZW4gPSBnc2FwLnRvKHNlbGYsIHtcbiAgICBlYXNlOiBcInBvd2VyNFwiLFxuICAgIHBhdXNlZDogdHJ1ZSxcbiAgICBpbmhlcml0OiBmYWxzZSxcbiAgICBzY3JvbGxYOiBub3JtYWxpemVTY3JvbGxYID8gXCIrPTAuMVwiIDogXCIrPTBcIixcbiAgICBzY3JvbGxZOiBcIis9MC4xXCIsXG4gICAgbW9kaWZpZXJzOiB7XG4gICAgICBzY3JvbGxZOiBfaW50ZXJydXB0aW9uVHJhY2tlcihzY3JvbGxGdW5jWSwgc2Nyb2xsRnVuY1koKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHdlZW4ucGF1c2UoKTtcbiAgICAgIH0pXG4gICAgfSxcbiAgICBvblVwZGF0ZTogX3VwZGF0ZUFsbCxcbiAgICBvbkNvbXBsZXRlOiBvblN0b3BEZWxheWVkQ2FsbC52YXJzLm9uQ29tcGxldGVcbiAgfSk7IC8vIHdlIG5lZWQgdGhlIG1vZGlmaWVyIHRvIHNlbnNlIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgYWx0ZXJlZCBvdXRzaWRlIG9mIHRoZSBtb21lbnR1bSB0d2VlbiAobGlrZSB3aXRoIGEgc2Nyb2xsVG8gdHdlZW4pIHNvIHdlIGNhbiBwYXVzZSgpIGl0IHRvIHByZXZlbnQgY29uZmxpY3RzLlxuXG4gIHJldHVybiBzZWxmO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5zb3J0ID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKF9pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuIF90cmlnZ2Vycy5zb3J0KGZ1bmMpO1xuICB9XG5cbiAgdmFyIHNjcm9sbCA9IF93aW4ucGFnZVlPZmZzZXQgfHwgMDtcbiAgU2Nyb2xsVHJpZ2dlci5nZXRBbGwoKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQuX3NvcnRZID0gdC50cmlnZ2VyID8gc2Nyb2xsICsgdC50cmlnZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IHQuc3RhcnQgKyBfd2luLmlubmVySGVpZ2h0O1xuICB9KTtcbiAgcmV0dXJuIF90cmlnZ2Vycy5zb3J0KGZ1bmMgfHwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gKGEudmFycy5yZWZyZXNoUHJpb3JpdHkgfHwgMCkgKiAtMWU2ICsgKGEudmFycy5jb250YWluZXJBbmltYXRpb24gPyAxZTYgOiBhLl9zb3J0WSkgLSAoKGIudmFycy5jb250YWluZXJBbmltYXRpb24gPyAxZTYgOiBiLl9zb3J0WSkgKyAoYi52YXJzLnJlZnJlc2hQcmlvcml0eSB8fCAwKSAqIC0xZTYpO1xuICB9KTsgLy8gYW55dGhpbmcgd2l0aCBhIGNvbnRhaW5lckFuaW1hdGlvbiBzaG91bGQgcmVmcmVzaCBsYXN0LlxufTtcblxuU2Nyb2xsVHJpZ2dlci5vYnNlcnZlID0gZnVuY3Rpb24gKHZhcnMpIHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZlcih2YXJzKTtcbn07XG5cblNjcm9sbFRyaWdnZXIubm9ybWFsaXplU2Nyb2xsID0gZnVuY3Rpb24gKHZhcnMpIHtcbiAgaWYgKHR5cGVvZiB2YXJzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVyO1xuICB9XG5cbiAgaWYgKHZhcnMgPT09IHRydWUgJiYgX25vcm1hbGl6ZXIpIHtcbiAgICByZXR1cm4gX25vcm1hbGl6ZXIuZW5hYmxlKCk7XG4gIH1cblxuICBpZiAodmFycyA9PT0gZmFsc2UpIHtcbiAgICBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5raWxsKCk7XG4gICAgX25vcm1hbGl6ZXIgPSB2YXJzO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBub3JtYWxpemVyID0gdmFycyBpbnN0YW5jZW9mIE9ic2VydmVyID8gdmFycyA6IF9nZXRTY3JvbGxOb3JtYWxpemVyKHZhcnMpO1xuICBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci50YXJnZXQgPT09IG5vcm1hbGl6ZXIudGFyZ2V0ICYmIF9ub3JtYWxpemVyLmtpbGwoKTtcbiAgX2lzVmlld3BvcnQobm9ybWFsaXplci50YXJnZXQpICYmIChfbm9ybWFsaXplciA9IG5vcm1hbGl6ZXIpO1xuICByZXR1cm4gbm9ybWFsaXplcjtcbn07XG5cblNjcm9sbFRyaWdnZXIuY29yZSA9IHtcbiAgLy8gc21hbGxlciBmaWxlIHNpemUgd2F5IHRvIGxldmVyYWdlIGluIFNjcm9sbFNtb290aGVyIGFuZCBPYnNlcnZlclxuICBfZ2V0VmVsb2NpdHlQcm9wOiBfZ2V0VmVsb2NpdHlQcm9wLFxuICBfaW5wdXRPYnNlcnZlcjogX2lucHV0T2JzZXJ2ZXIsXG4gIF9zY3JvbGxlcnM6IF9zY3JvbGxlcnMsXG4gIF9wcm94aWVzOiBfcHJveGllcyxcbiAgYnJpZGdlOiB7XG4gICAgLy8gd2hlbiBub3JtYWxpemVTY3JvbGwgc2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIChzcyA9IHNldFNjcm9sbClcbiAgICBzczogZnVuY3Rpb24gc3MoKSB7XG4gICAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XG4gICAgICBfbGFzdFNjcm9sbFRpbWUgPSBfZ2V0VGltZSgpO1xuICAgIH0sXG4gICAgLy8gYSB3YXkgdG8gZ2V0IHRoZSBfcmVmcmVzaGluZyB2YWx1ZSBpbiBPYnNlcnZlclxuICAgIHJlZjogZnVuY3Rpb24gcmVmKCkge1xuICAgICAgcmV0dXJuIF9yZWZyZXNoaW5nO1xuICAgIH1cbiAgfVxufTtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKTtcbmV4cG9ydCB7IFNjcm9sbFRyaWdnZXIgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6WyJPYnNlcnZlciIsIl9nZXRUYXJnZXQiLCJfdmVydGljYWwiLCJfaG9yaXpvbnRhbCIsIl9zY3JvbGxlcnMiLCJfcHJveGllcyIsIl9nZXRTY3JvbGxGdW5jIiwiX2dldFByb3h5UHJvcCIsIl9nZXRWZWxvY2l0eVByb3AiLCJnc2FwIiwiX2NvcmVJbml0dGVkIiwiX3dpbiIsIl9kb2MiLCJfZG9jRWwiLCJfYm9keSIsIl9yb290IiwiX3Jlc2l6ZURlbGF5IiwiX3RvQXJyYXkiLCJfY2xhbXAiLCJfdGltZTIiLCJfc3luY0ludGVydmFsIiwiX3JlZnJlc2hpbmciLCJfcG9pbnRlcklzRG93biIsIl90cmFuc2Zvcm1Qcm9wIiwiX2kiLCJfcHJldldpZHRoIiwiX3ByZXZIZWlnaHQiLCJfYXV0b1JlZnJlc2giLCJfc29ydCIsIl9zdXBwcmVzc092ZXJ3cml0ZXMiLCJfaWdub3JlUmVzaXplIiwiX25vcm1hbGl6ZXIiLCJfaWdub3JlTW9iaWxlUmVzaXplIiwiX2Jhc2VTY3JlZW5IZWlnaHQiLCJfYmFzZVNjcmVlbldpZHRoIiwiX2ZpeElPU0J1ZyIsIl9jb250ZXh0IiwiX3Njcm9sbFJlc3RvcmF0aW9uIiwiX2RpdjEwMHZoIiwiXzEwMHZoIiwiX2lzUmV2ZXJ0ZWQiLCJfY2xhbXBpbmdNYXgiLCJfbGltaXRDYWxsYmFja3MiLCJfc3RhcnR1cCIsIl9nZXRUaW1lIiwiRGF0ZSIsIm5vdyIsIl90aW1lMSIsIl9sYXN0U2Nyb2xsVGltZSIsIl9lbmFibGVkIiwiX3BhcnNlQ2xhbXAiLCJ2YWx1ZSIsInR5cGUiLCJzZWxmIiwiY2xhbXAiLCJfaXNTdHJpbmciLCJzdWJzdHIiLCJpbmRleE9mIiwibGVuZ3RoIiwiX2tlZXBDbGFtcCIsIl9yYWZCdWdGaXgiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJfcG9pbnRlckRvd25IYW5kbGVyIiwiX3BvaW50ZXJVcEhhbmRsZXIiLCJfcGFzc1Rocm91Z2giLCJ2IiwiX3JvdW5kIiwiTWF0aCIsInJvdW5kIiwiX3dpbmRvd0V4aXN0cyIsIl9nZXRHU0FQIiwid2luZG93IiwicmVnaXN0ZXJQbHVnaW4iLCJfaXNWaWV3cG9ydCIsImUiLCJfZ2V0Vmlld3BvcnREaW1lbnNpb24iLCJkaW1lbnNpb25Qcm9wZXJ0eSIsIl9nZXRCb3VuZHNGdW5jIiwiZWxlbWVudCIsIl93aW5PZmZzZXRzIiwid2lkdGgiLCJpbm5lcldpZHRoIiwiaGVpZ2h0IiwiX2dldEJvdW5kcyIsIl9nZXRTaXplRnVuYyIsInNjcm9sbGVyIiwiaXNWaWV3cG9ydCIsIl9yZWYiLCJkIiwiZDIiLCJhIiwiX2dldE9mZnNldHNGdW5jIiwiX21heFNjcm9sbCIsIl9yZWYyIiwicyIsIm1heCIsIl9pdGVyYXRlQXV0b1JlZnJlc2giLCJmdW5jIiwiZXZlbnRzIiwiaSIsIl9pc0Z1bmN0aW9uIiwiX2lzTnVtYmVyIiwiX2lzT2JqZWN0IiwiX2VuZEFuaW1hdGlvbiIsImFuaW1hdGlvbiIsInJldmVyc2VkIiwicGF1c2UiLCJwcm9ncmVzcyIsIl9jYWxsYmFjayIsImVuYWJsZWQiLCJyZXN1bHQiLCJfY3R4IiwiYWRkIiwidG90YWxUaW1lIiwiY2FsbGJhY2tBbmltYXRpb24iLCJfYWJzIiwiYWJzIiwiX2xlZnQiLCJfdG9wIiwiX3JpZ2h0IiwiX2JvdHRvbSIsIl93aWR0aCIsIl9oZWlnaHQiLCJfUmlnaHQiLCJfTGVmdCIsIl9Ub3AiLCJfQm90dG9tIiwiX3BhZGRpbmciLCJfbWFyZ2luIiwiX1dpZHRoIiwiX0hlaWdodCIsIl9weCIsIl9nZXRDb21wdXRlZFN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIl9tYWtlUG9zaXRpb25hYmxlIiwicG9zaXRpb24iLCJzdHlsZSIsIl9zZXREZWZhdWx0cyIsIm9iaiIsImRlZmF1bHRzIiwicCIsIndpdGhvdXRUcmFuc2Zvcm1zIiwidHdlZW4iLCJ0byIsIngiLCJ5IiwieFBlcmNlbnQiLCJ5UGVyY2VudCIsInJvdGF0aW9uIiwicm90YXRpb25YIiwicm90YXRpb25ZIiwic2NhbGUiLCJza2V3WCIsInNrZXdZIiwiYm91bmRzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwia2lsbCIsIl9nZXRTaXplIiwiX3JlZjMiLCJfZ2V0TGFiZWxSYXRpb0FycmF5IiwidGltZWxpbmUiLCJsYWJlbHMiLCJkdXJhdGlvbiIsInB1c2giLCJfZ2V0Q2xvc2VzdExhYmVsIiwidXRpbHMiLCJzbmFwIiwiX3NuYXBEaXJlY3Rpb25hbCIsInNuYXBJbmNyZW1lbnRPckFycmF5IiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJzb3J0IiwiYiIsImRpcmVjdGlvbiIsInRocmVzaG9sZCIsInNuYXBwZWQiLCJfZ2V0TGFiZWxBdERpcmVjdGlvbiIsInN0IiwiX211bHRpTGlzdGVuZXIiLCJ0eXBlcyIsImNhbGxiYWNrIiwic3BsaXQiLCJmb3JFYWNoIiwiX2FkZExpc3RlbmVyIiwibm9uUGFzc2l2ZSIsImNhcHR1cmUiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsIl9yZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfd2hlZWxMaXN0ZW5lciIsImVsIiwic2Nyb2xsRnVuYyIsIndoZWVsSGFuZGxlciIsIl9tYXJrZXJEZWZhdWx0cyIsInN0YXJ0Q29sb3IiLCJlbmRDb2xvciIsImluZGVudCIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsIl9kZWZhdWx0cyIsInRvZ2dsZUFjdGlvbnMiLCJhbnRpY2lwYXRlUGluIiwiX2tleXdvcmRzIiwidG9wIiwibGVmdCIsImNlbnRlciIsImJvdHRvbSIsInJpZ2h0IiwiX29mZnNldFRvUHgiLCJzaXplIiwiZXFJbmRleCIsInJlbGF0aXZlIiwiY2hhckF0IiwicGFyc2VGbG9hdCIsIl9jcmVhdGVNYXJrZXIiLCJuYW1lIiwiY29udGFpbmVyIiwiX3JlZjQiLCJvZmZzZXQiLCJtYXRjaFdpZHRoRWwiLCJjb250YWluZXJBbmltYXRpb24iLCJjcmVhdGVFbGVtZW50IiwidXNlRml4ZWRQb3NpdGlvbiIsImlzU2Nyb2xsZXIiLCJwYXJlbnQiLCJpc1N0YXJ0IiwiY29sb3IiLCJjc3MiLCJvZmZzZXRXaWR0aCIsIl9pc1N0YXJ0Iiwic2V0QXR0cmlidXRlIiwiY3NzVGV4dCIsImlubmVyVGV4dCIsImNoaWxkcmVuIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJfb2Zmc2V0Iiwib3AiLCJfcG9zaXRpb25NYXJrZXIiLCJtYXJrZXIiLCJzdGFydCIsImZsaXBwZWQiLCJ2YXJzIiwiZGlzcGxheSIsInNpZGUiLCJvcHBvc2l0ZVNpZGUiLCJfaXNGbGlwcGVkIiwic2V0IiwiX3RyaWdnZXJzIiwiX2lkcyIsIl9yYWZJRCIsIl9zeW5jIiwiX3VwZGF0ZUFsbCIsIl9vblNjcm9sbCIsImlzUHJlc3NlZCIsInN0YXJ0WCIsImNsaWVudFdpZHRoIiwiY2FjaGUiLCJfZGlzcGF0Y2giLCJfc2V0QmFzZURpbWVuc2lvbnMiLCJpbm5lckhlaWdodCIsIl9vblJlc2l6ZSIsImZvcmNlIiwiZnVsbHNjcmVlbkVsZW1lbnQiLCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCIsInJlc3RhcnQiLCJfbGlzdGVuZXJzIiwiX2VtcHR5QXJyYXkiLCJfc29mdFJlZnJlc2giLCJTY3JvbGxUcmlnZ2VyIiwiX3JlZnJlc2hBbGwiLCJtYXAiLCJmIiwiX3NhdmVkU3R5bGVzIiwiX3JldmVydFJlY29yZGVkIiwibWVkaWEiLCJxdWVyeSIsImdldEJCb3giLCJ1bmNhY2hlIiwiX3JldmVydEFsbCIsInRyaWdnZXIiLCJyZXZlcnQiLCJfY2xlYXJTY3JvbGxNZW1vcnkiLCJzY3JvbGxSZXN0b3JhdGlvbiIsIl9yZWZyZXNoaW5nQWxsIiwiY2FjaGVJRCIsInJlYyIsImhpc3RvcnkiLCJfcmVmcmVzaElEIiwiX3F1ZXVlUmVmcmVzaElEIiwiX3F1ZXVlUmVmcmVzaEFsbCIsImlkIiwiX3JlZnJlc2gxMDB2aCIsIm9mZnNldEhlaWdodCIsInJlbW92ZUNoaWxkIiwiX2hpZGVBbGxNYXJrZXJzIiwiaGlkZSIsInNraXBSZXZlcnQiLCJkb2N1bWVudEVsZW1lbnQiLCJib2R5IiwiaXNSZWZyZXNoaW5nIiwicmVmcmVzaEluaXRzIiwic21vb3RoIiwidGFyZ2V0Iiwic2Nyb2xsQmVoYXZpb3IiLCJ0IiwicmVmcmVzaCIsIl9zdWJQaW5PZmZzZXQiLCJwaW4iLCJwcm9wIiwiaG9yaXpvbnRhbCIsIm9yaWdpbmFsIiwiYWRqdXN0UGluU3BhY2luZyIsIl9kaXIiLCJlbmRDbGFtcCIsImVuZCIsIl9lbmRDbGFtcCIsInN0YXJ0Q2xhbXAiLCJfc3RhcnRDbGFtcCIsInNldFBvc2l0aW9ucyIsInJlbmRlciIsIm9uUmVmcmVzaCIsIl9sYXN0U2Nyb2xsIiwiX2RpcmVjdGlvbiIsIl9wcmltYXJ5IiwiaXNVcGRhdGluZyIsInVwZGF0ZSIsImwiLCJ0aW1lIiwicmVjb3JkVmVsb2NpdHkiLCJzY3JvbGwiLCJfcHJvcE5hbWVzVG9Db3B5IiwiX3N0YXRlUHJvcHMiLCJjb25jYXQiLCJfc3dhcFBpbk91dCIsInNwYWNlciIsInN0YXRlIiwiX3NldFN0YXRlIiwiX2dzYXAiLCJzcGFjZXJJc05hdGl2ZSIsInNwYWNlclN0YXRlIiwic3dhcHBlZEluIiwicGFyZW50Tm9kZSIsIl9zd2FwUGluSW4iLCJjcyIsInNwYWNlclN0eWxlIiwicGluU3R5bGUiLCJmbGV4QmFzaXMiLCJvdmVyZmxvdyIsImJveFNpemluZyIsIl9jYXBzRXhwIiwiY29yZSIsImdldENhY2hlIiwicmVtb3ZlUHJvcGVydHkiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJfZ2V0U3RhdGUiLCJfY29weVN0YXRlIiwib3ZlcnJpZGUiLCJvbWl0T2Zmc2V0cyIsIl9wYXJzZVBvc2l0aW9uIiwic2Nyb2xsZXJTaXplIiwibWFya2VyU2Nyb2xsZXIiLCJzY3JvbGxlckJvdW5kcyIsImJvcmRlcldpZHRoIiwic2Nyb2xsZXJNYXgiLCJjbGFtcFplcm9Qcm9wIiwicDEiLCJwMiIsInNlZWsiLCJpc05hTiIsIm9mZnNldHMiLCJsb2NhbE9mZnNldCIsImdsb2JhbE9mZnNldCIsIm1hcFJhbmdlIiwic2Nyb2xsVHJpZ2dlciIsIm0iLCJfY2FTY3JvbGxEaXN0IiwiX3ByZWZpeEV4cCIsIl9yZXBhcmVudCIsIl9zdE9yaWciLCJ0ZXN0IiwiX2ludGVycnVwdGlvblRyYWNrZXIiLCJnZXRWYWx1ZUZ1bmMiLCJpbml0aWFsVmFsdWUiLCJvbkludGVycnVwdCIsImxhc3QxIiwibGFzdDIiLCJjdXJyZW50IiwiX3NoaWZ0TWFya2VyIiwiX2dldFR3ZWVuQ3JlYXRvciIsImdldFNjcm9sbCIsImdldFR3ZWVuIiwic2Nyb2xsVG8iLCJjaGFuZ2UxIiwiY2hhbmdlMiIsIm9uQ29tcGxldGUiLCJtb2RpZmllcnMiLCJjaGVja0ZvckludGVycnVwdGlvbiIsImluaGVyaXQiLCJyYXRpbyIsIm9uVXBkYXRlIiwiY2FsbCIsImlzVG91Y2giLCJyZWdpc3RlciIsImNvbnNvbGUiLCJ3YXJuIiwiaW5pdCIsIl9wcm90byIsInByb3RvdHlwZSIsIm5vZGVUeXBlIiwiX3ZhcnMiLCJ0b2dnbGVDbGFzcyIsIm9uVG9nZ2xlIiwic2NydWIiLCJwaW5TcGFjaW5nIiwiaW52YWxpZGF0ZU9uUmVmcmVzaCIsIm9uU2NydWJDb21wbGV0ZSIsIm9uU25hcENvbXBsZXRlIiwib25jZSIsInBpblJlcGFyZW50IiwicGluU3BhY2VyIiwiZmFzdFNjcm9sbEVuZCIsInByZXZlbnRPdmVybGFwcyIsImlzVG9nZ2xlIiwic2Nyb2xsZXJDYWNoZSIsInBpblR5cGUiLCJjYWxsYmFja3MiLCJvbkVudGVyIiwib25MZWF2ZSIsIm9uRW50ZXJCYWNrIiwib25MZWF2ZUJhY2siLCJtYXJrZXJzIiwib25SZWZyZXNoSW5pdCIsImdldFNjcm9sbGVyU2l6ZSIsImdldFNjcm9sbGVyT2Zmc2V0cyIsImxhc3RTbmFwIiwibGFzdFJlZnJlc2giLCJwcmV2UHJvZ3Jlc3MiLCJ0d2VlblRvIiwicGluQ2FjaGUiLCJzbmFwRnVuYyIsInNjcm9sbDEiLCJzY3JvbGwyIiwibWFya2VyU3RhcnQiLCJtYXJrZXJFbmQiLCJtYXJrZXJTdGFydFRyaWdnZXIiLCJtYXJrZXJFbmRUcmlnZ2VyIiwibWFya2VyVmFycyIsImV4ZWN1dGluZ09uUmVmcmVzaCIsImNoYW5nZSIsInBpbk9yaWdpbmFsU3RhdGUiLCJwaW5BY3RpdmVTdGF0ZSIsInBpblN0YXRlIiwicGluR2V0dGVyIiwicGluU2V0dGVyIiwicGluU3RhcnQiLCJwaW5DaGFuZ2UiLCJzcGFjaW5nU3RhcnQiLCJtYXJrZXJTdGFydFNldHRlciIsInBpbk1vdmVzIiwibWFya2VyRW5kU2V0dGVyIiwic25hcDEiLCJzbmFwMiIsInNjcnViVHdlZW4iLCJzY3J1YlNtb290aCIsInNuYXBEdXJDbGFtcCIsInNuYXBEZWxheWVkQ2FsbCIsInByZXZTY3JvbGwiLCJwcmV2QW5pbVByb2dyZXNzIiwiY2FNYXJrZXJTZXR0ZXIiLCJjdXN0b21SZXZlcnRSZXR1cm4iLCJiaW5kIiwicmVmcmVzaFByaW9yaXR5IiwidHdlZW5TY3JvbGwiLCJzY3J1YkR1cmF0aW9uIiwiZWFzZSIsInRvdGFsUHJvZ3Jlc3MiLCJwYXVzZWQiLCJsYXp5IiwiX2luaXR0ZWQiLCJpc1JldmVydGVkIiwiaW1tZWRpYXRlUmVuZGVyIiwic25hcFRvIiwibyIsInNjcm9sbGluZ0VsZW1lbnQiLCJkaXJlY3Rpb25hbCIsIm1pbiIsImRlbGF5ZWRDYWxsIiwiZGVsYXkiLCJyZWZyZXNoZWRSZWNlbnRseSIsImdldFZlbG9jaXR5IiwidmVsb2NpdHkiLCJuYXR1cmFsRW5kIiwiaW5lcnRpYSIsImVuZFZhbHVlIiwiZW5kU2Nyb2xsIiwiX3NuYXAiLCJvblN0YXJ0IiwiX29uSW50ZXJydXB0IiwiX29uQ29tcGxldGUiLCJkYXRhIiwicmVzZXRUbyIsIl90VGltZSIsIl90RHVyIiwiaXNBY3RpdmUiLCJzdFJldmVydCIsInRhcmdldHMiLCJjbGFzc05hbWUiLCJuYXRpdmVFbGVtZW50IiwiY2xhc3NMaXN0IiwiZm9yY2UzRCIsIm9zMiIsImdldFByb3BlcnR5IiwicXVpY2tTZXR0ZXIiLCJjb250ZW50Iiwib2xkT25VcGRhdGUiLCJvbGRQYXJhbXMiLCJvblVwZGF0ZVBhcmFtcyIsImV2ZW50Q2FsbGJhY2siLCJhcHBseSIsInByZXZpb3VzIiwibmV4dCIsInRlbXAiLCJyIiwicHJldlJlZnJlc2hpbmciLCJzb2Z0IiwicGluT2Zmc2V0IiwiaW52YWxpZGF0ZSIsImlzRmlyc3RSZWZyZXNoIiwib3RoZXJQaW5PZmZzZXQiLCJwYXJzZWRFbmQiLCJwYXJzZWRFbmRUcmlnZ2VyIiwiZW5kVHJpZ2dlciIsInBhcnNlZFN0YXJ0IiwicGlubmVkQ29udGFpbmVyIiwidHJpZ2dlckluZGV4IiwiaXNWZXJ0aWNhbCIsImN1clRyaWdnZXIiLCJjdXJQaW4iLCJvcHBvc2l0ZVNjcm9sbCIsImluaXR0ZWQiLCJyZXZlcnRlZFBpbnMiLCJmb3JjZWRPdmVyZmxvdyIsIm1hcmtlclN0YXJ0T2Zmc2V0IiwibWFya2VyRW5kT2Zmc2V0IiwidW5zaGlmdCIsIl9waW5QdXNoIiwibm9ybWFsaXplIiwidG9VcHBlckNhc2UiLCJjZWlsIiwic3BsaWNlIiwiX3Bpbk9mZnNldCIsImVuZEFuaW1hdGlvbiIsImxhYmVsVG9TY3JvbGwiLCJsYWJlbCIsImdldFRyYWlsaW5nIiwicmV2ZXJzZSIsImZpbHRlciIsInJlc2V0IiwiZm9yY2VGYWtlIiwiY2xpcHBlZCIsIndhc0FjdGl2ZSIsInRvZ2dsZVN0YXRlIiwiYWN0aW9uIiwic3RhdGVDaGFuZ2VkIiwidG9nZ2xlZCIsImlzQXRNYXgiLCJpc1Rha2luZ0FjdGlvbiIsIl9kcCIsIl90aW1lIiwiX3N0YXJ0IiwibiIsImVuYWJsZSIsIm5ld1N0YXJ0IiwibmV3RW5kIiwia2VlcENsYW1wIiwiX2NoYW5nZSIsImFtb3VudCIsImRpc2FibGUiLCJhbGxvd0FuaW1hdGlvbiIsIm9uS2lsbCIsInVwZGF0ZUZ1bmMiLCJkb2N1bWVudCIsImNvbmZpZyIsImNsZWFySW50ZXJ2YWwiLCJ0b0FycmF5IiwiY29udGV4dCIsInN1cHByZXNzT3ZlcndyaXRlcyIsInBhZ2VZT2Zmc2V0IiwiZ2xvYmFscyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm1hdGNoTWVkaWEiLCJtbSIsImJvZHlIYXNTdHlsZSIsImhhc0F0dHJpYnV0ZSIsImJvZHlTdHlsZSIsImJvcmRlciIsImJvcmRlclRvcFN0eWxlIiwiQW5pbWF0aW9uUHJvdG8iLCJBbmltYXRpb24iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInNjIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0SW50ZXJ2YWwiLCJjaGVja1ByZWZpeCIsInciLCJoIiwiaGlkZGVuIiwibGltaXRDYWxsYmFja3MiLCJtcyIsInN5bmNJbnRlcnZhbCIsImlnbm9yZU1vYmlsZVJlc2l6ZSIsImF1dG9SZWZyZXNoRXZlbnRzIiwic2Nyb2xsZXJQcm94eSIsImNsZWFyTWF0Y2hNZWRpYSIsImlzSW5WaWV3cG9ydCIsInBvc2l0aW9uSW5WaWV3cG9ydCIsInJlZmVyZW5jZVBvaW50Iiwia2lsbEFsbCIsImFsbG93TGlzdGVuZXJzIiwibGlzdGVuZXJzIiwidmVyc2lvbiIsInNhdmVTdHlsZXMiLCJnZXRBdHRyaWJ1dGUiLCJjcmVhdGUiLCJzYWZlIiwiY2xlYXJTY3JvbGxNZW1vcnkiLCJtYXhTY3JvbGwiLCJnZXRTY3JvbGxGdW5jIiwiZ2V0QnlJZCIsImdldEFsbCIsImlzU2Nyb2xsaW5nIiwic25hcERpcmVjdGlvbmFsIiwiYmF0Y2giLCJ2YXJzQ29weSIsImludGVydmFsIiwiYmF0Y2hNYXgiLCJwcm94eUNhbGxiYWNrIiwiZWxlbWVudHMiLCJ0cmlnZ2VycyIsIl9jbGFtcFNjcm9sbEFuZEdldER1cmF0aW9uTXVsdGlwbGllciIsIl9hbGxvd05hdGl2ZVBhbm5pbmciLCJ0b3VjaEFjdGlvbiIsIl9vdmVyZmxvdyIsImF1dG8iLCJfbmVzdGVkU2Nyb2xsIiwiX3JlZjUiLCJldmVudCIsImF4aXMiLCJub2RlIiwiY2hhbmdlZFRvdWNoZXMiLCJfaXNTY3JvbGxUIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJfaXNTY3JvbGwiLCJzdG9wUHJvcGFnYXRpb24iLCJfZ3NhcEFsbG93IiwiX2lucHV0T2JzZXJ2ZXIiLCJpbnB1dHMiLCJuZXN0ZWQiLCJkZWJvdW5jZSIsImxvY2tBeGlzIiwib25XaGVlbCIsIm9uUHJlc3MiLCJvbkRyYWciLCJvblNjcm9sbCIsIm9uRW5hYmxlIiwiZXZlbnRUeXBlcyIsIl9jYXB0dXJlSW5wdXRzIiwib25EaXNhYmxlIiwiX2lucHV0RXhwIiwiX2lucHV0SXNGb2N1c2VkIiwiaXNJbnB1dCIsInRhZ05hbWUiLCJfZ2V0U2Nyb2xsTm9ybWFsaXplciIsInByZXZlbnREZWZhdWx0IiwiaXNOb3JtYWxpemVyIiwiYWxsb3dDbGlja3MiLCJfdmFyczIiLCJub3JtYWxpemVTY3JvbGxYIiwibW9tZW50dW0iLCJhbGxvd05lc3RlZFNjcm9sbCIsIm9uUmVsZWFzZSIsIm1heFkiLCJzbW9vdGhlciIsIlNjcm9sbFNtb290aGVyIiwic21vb3RoZXJJbnN0YW5jZSIsImdldCIsInNjcm9sbEZ1bmNZIiwic2Nyb2xsRnVuY1giLCJpbml0aWFsU2NhbGUiLCJ2aXN1YWxWaWV3cG9ydCIsIm91dGVyV2lkdGgiLCJ3aGVlbFJlZnJlc2giLCJyZXNvbHZlTW9tZW50dW1EdXJhdGlvbiIsImxhc3RSZWZyZXNoSUQiLCJza2lwVG91Y2hNb3ZlIiwiaW5wdXRPYnNlcnZlciIsInJlc3VtZVRvdWNoTW92ZSIsInNjcm9sbENsYW1wWCIsInNjcm9sbENsYW1wWSIsInVwZGF0ZUNsYW1wcyIsInJlbW92ZUNvbnRlbnRPZmZzZXQiLCJ0cmFuc2Zvcm0iLCJpZ25vcmVEcmFnIiwiZGVsdGFZIiwic3RhcnRTY3JvbGxYIiwic3RhcnRTY3JvbGxZIiwib25TdG9wRGVsYXllZENhbGwiLCJvblJlc2l6ZSIsInNjcm9sbFkiLCJpZ25vcmVDaGVjayIsImlzR2VzdHVyaW5nIiwidG91Y2hlcyIsInByZXZTY2FsZSIsIm9uR2VzdHVyZVN0YXJ0Iiwid2FzRHJhZ2dpbmciLCJkdXIiLCJjdXJyZW50U2Nyb2xsIiwidmVsb2NpdHlYIiwic2Nyb2xsWCIsInZlbG9jaXR5WSIsInBsYXkiLCJfdHMiLCJvbkNoYW5nZSIsImR4IiwiZHkiLCJ4QXJyYXkiLCJ5QXJyYXkiLCJzdGFydFkiLCJ5Q2xhbXBlZCIsImlPUyIsInRpY2tlciIsIl9kYyIsIl9zb3J0WSIsIm9ic2VydmUiLCJub3JtYWxpemVTY3JvbGwiLCJub3JtYWxpemVyIiwiYnJpZGdlIiwic3MiLCJyZWYiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/gsap/ScrollTrigger.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dashboard/content/charitypage/page.tsx":
/*!********************************************************!*\
  !*** ./src/app/dashboard/content/charitypage/page.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CharityContentManagement; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/auth-helpers-nextjs */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js\");\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_ui_LoadingSpinner__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../components/ui/LoadingSpinner */ \"(app-pages-browser)/./src/components/ui/LoadingSpinner.tsx\");\n/* harmony import */ var _components_ui_ErrorMessage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../components/ui/ErrorMessage */ \"(app-pages-browser)/./src/components/ui/ErrorMessage.tsx\");\n/* harmony import */ var _components_preview_CharitySectionPreview__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../components/preview/CharitySectionPreview */ \"(app-pages-browser)/./src/components/preview/CharitySectionPreview.tsx\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction CharityContentManagement() {\n    _s();\n    const [sections, setSections] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [editingSection, setEditingSection] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const supabase = (0,_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_3__.createClientComponentClient)();\n    const { user } = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__.useAuth)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        fetchSections();\n    }, []);\n    async function fetchSections() {\n        setLoading(true);\n        setError(null);\n        try {\n            const { data, error: fetchError } = await supabase.from(\"charity_sections\").select(\"*\").order(\"order_number\");\n            if (fetchError) {\n                const supabaseError = fetchError;\n                throw new Error(\"Database error: \".concat(supabaseError.message).concat(supabaseError.details ? \" - \".concat(supabaseError.details) : \"\"));\n            }\n            if (!data) {\n                throw new Error(\"No data received from charity_sections table\");\n            }\n            setSections(data);\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Failed to fetch charity sections\";\n            setError(errorMessage);\n            console.error(\"Error fetching charity sections:\", err);\n        } finally{\n            setLoading(false);\n        }\n    }\n    async function updateSection(id, newContent) {\n        if (!(user === null || user === void 0 ? void 0 : user.email)) {\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_7__[\"default\"].error(\"You must be logged in to make changes\");\n            return;\n        }\n        try {\n            const currentSection = sections.find((s)=>s.id === id);\n            if (!currentSection) {\n                throw new Error(\"Section not found\");\n            }\n            const updateData = {\n                content: newContent,\n                updated_at: new Date().toISOString()\n            };\n            if (typeof currentSection.version === \"number\") {\n                updateData.version = currentSection.version + 1;\n            }\n            const { error: updateError } = await supabase.from(\"charity_sections\").update(updateData).eq(\"id\", id);\n            if (updateError) {\n                const supabaseError = updateError;\n                throw new Error(\"Database error: \".concat(supabaseError.message).concat(supabaseError.details ? \" - \".concat(supabaseError.details) : \"\"));\n            }\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_7__[\"default\"].success(\"Charity content updated successfully\");\n            await fetchSections();\n            setEditingSection(null);\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Failed to update charity content\";\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_7__[\"default\"].error(errorMessage);\n            console.error(\"Error updating charity section:\", err);\n        }\n    }\n    if (loading) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_LoadingSpinner__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n        size: \"large\",\n        message: \"Loading Charity content...\",\n        centered: true\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n        lineNumber: 108,\n        columnNumber: 23\n    }, this);\n    if (error) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_ErrorMessage__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n        message: error\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n        lineNumber: 109,\n        columnNumber: 21\n    }, this);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"space-y-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center justify-between mb-6\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                    className: \"text-2xl font-bold\",\n                    children: \"Charity Content Management\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                    lineNumber: 114,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                lineNumber: 113,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-8\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-xl font-semibold mb-4\",\n                        children: \"Live Voorbeeld Charity\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                        lineNumber: 118,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"border border-gray-700 rounded-lg p-0 bg-gray-800/50 shadow-inner overflow-hidden\",\n                        children: sections.length > 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_preview_CharitySectionPreview__WEBPACK_IMPORTED_MODULE_6__.CharitySectionPreview, {\n                            sections: sections\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                            lineNumber: 121,\n                            columnNumber: 13\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-4 text-center text-gray-500\",\n                            children: \"Preview not available.\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                            lineNumber: 122,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                        lineNumber: 119,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                lineNumber: 117,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-xl font-semibold mb-4\",\n                        children: \"Bewerk Secties\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                        lineNumber: 128,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid gap-6\",\n                        children: sections.map((section)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"container-card p-6\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex justify-between items-start mb-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                                        className: \"text-lg font-semibold text-gray-200\",\n                                                        children: section.section_key.replace(/_/g, \" \").toUpperCase()\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                        lineNumber: 134,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: [\n                                                            \"Type: \",\n                                                            section.style_type\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                        lineNumber: 137,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                lineNumber: 133,\n                                                columnNumber: 17\n                                            }, this),\n                                            typeof section.version === \"number\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"px-2 py-1 text-xs rounded bg-gray-700 text-gray-300\",\n                                                children: [\n                                                    \"v\",\n                                                    section.version\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                lineNumber: 140,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                        lineNumber: 132,\n                                        columnNumber: 15\n                                    }, this),\n                                    editingSection === section.id ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"space-y-4\",\n                                        children: [\n                                            section.style_type === \"link\" ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"text\",\n                                                className: \"form-input\",\n                                                defaultValue: section.content,\n                                                id: \"edit-\".concat(section.id),\n                                                placeholder: \"Enter URL (e.g., example.com)\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                lineNumber: 149,\n                                                columnNumber: 21\n                                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                                                className: \"form-input h-32\",\n                                                defaultValue: section.content,\n                                                id: \"edit-\".concat(section.id)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                lineNumber: 157,\n                                                columnNumber: 21\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex gap-2\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        className: \"btn-primary\",\n                                                        onClick: ()=>{\n                                                            const element = document.getElementById(\"edit-\".concat(section.id));\n                                                            if (!element) return;\n                                                            const newContent = element.value;\n                                                            updateSection(section.id, newContent);\n                                                        },\n                                                        children: \"Save\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                        lineNumber: 164,\n                                                        columnNumber: 21\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        className: \"btn-secondary\",\n                                                        onClick: ()=>setEditingSection(null),\n                                                        children: \"Cancel\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                        lineNumber: 175,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                lineNumber: 163,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                        lineNumber: 147,\n                                        columnNumber: 17\n                                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"space-y-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-gray-300 whitespace-pre-wrap\",\n                                                children: section.content\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                lineNumber: 185,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"btn-secondary\",\n                                                onClick: ()=>setEditingSection(section.id),\n                                                children: \"Edit\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                                lineNumber: 188,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                        lineNumber: 184,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, section.id, true, {\n                                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                                lineNumber: 131,\n                                columnNumber: 13\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                        lineNumber: 129,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n                lineNumber: 127,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\app\\\\dashboard\\\\content\\\\charitypage\\\\page.tsx\",\n        lineNumber: 112,\n        columnNumber: 5\n    }, this);\n}\n_s(CharityContentManagement, \"ZpT1LcpjXdE26kgcRceGCsExxWg=\", false, function() {\n    return [\n        _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__.useAuth\n    ];\n});\n_c = CharityContentManagement;\nvar _c;\n$RefreshReg$(_c, \"CharityContentManagement\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGFzaGJvYXJkL2NvbnRlbnQvY2hhcml0eXBhZ2UvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUVrRDtBQUNRO0FBQ2lCO0FBQ047QUFDSjtBQUMyQjtBQUN6RDtBQWtCcEIsU0FBU1M7O0lBQ3RCLE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHViwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUM3RCxNQUFNLENBQUNXLFNBQVNDLFdBQVcsR0FBR1osK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDYSxPQUFPQyxTQUFTLEdBQUdkLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNlLGdCQUFnQkMsa0JBQWtCLEdBQUdoQiwrQ0FBUUEsQ0FBZ0I7SUFDcEUsTUFBTWlCLFdBQVdkLDBGQUEyQkE7SUFDNUMsTUFBTSxFQUFFZSxJQUFJLEVBQUUsR0FBR2hCLDhEQUFPQTtJQUV4QkQsZ0RBQVNBLENBQUM7UUFDUmtCO0lBQ0YsR0FBRyxFQUFFO0lBRUwsZUFBZUE7UUFDYlAsV0FBVztRQUNYRSxTQUFTO1FBQ1QsSUFBSTtZQUNGLE1BQU0sRUFBRU0sSUFBSSxFQUFFUCxPQUFPUSxVQUFVLEVBQUUsR0FBRyxNQUFNSixTQUN2Q0ssSUFBSSxDQUFDLG9CQUNMQyxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDO1lBRVQsSUFBSUgsWUFBWTtnQkFDZCxNQUFNSSxnQkFBZ0JKO2dCQUN0QixNQUFNLElBQUlLLE1BQU0sbUJBQTJDRCxPQUF4QkEsY0FBY0UsT0FBTyxFQUE4RCxPQUEzREYsY0FBY0csT0FBTyxHQUFHLE1BQTRCLE9BQXRCSCxjQUFjRyxPQUFPLElBQUs7WUFDckg7WUFFQSxJQUFJLENBQUNSLE1BQU07Z0JBQ1QsTUFBTSxJQUFJTSxNQUFNO1lBQ2xCO1lBRUFoQixZQUFZVTtRQUNkLEVBQUUsT0FBT1MsS0FBSztZQUNaLE1BQU1DLGVBQWVELGVBQWVILFFBQVFHLElBQUlGLE9BQU8sR0FB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dC9jaGFyaXR5cGFnZS9wYWdlLnRzeD8yOWNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnRleHRzL0F1dGhDb250ZXh0J1xyXG5pbXBvcnQgeyBjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqcydcclxuaW1wb3J0IExvYWRpbmdTcGlubmVyIGZyb20gJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvdWkvTG9hZGluZ1NwaW5uZXInXHJcbmltcG9ydCBFcnJvck1lc3NhZ2UgZnJvbSAnLi4vLi4vLi4vLi4vY29tcG9uZW50cy91aS9FcnJvck1lc3NhZ2UnXHJcbmltcG9ydCB7IENoYXJpdHlTZWN0aW9uUHJldmlldyB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvcHJldmlldy9DaGFyaXR5U2VjdGlvblByZXZpZXcnXHJcbmltcG9ydCB0b2FzdCBmcm9tICdyZWFjdC1ob3QtdG9hc3QnXHJcblxyXG5pbnRlcmZhY2UgQ2hhcml0eVNlY3Rpb24ge1xyXG4gIGlkOiBzdHJpbmdcclxuICBzZWN0aW9uX2tleTogc3RyaW5nXHJcbiAgY29udGVudDogc3RyaW5nXHJcbiAgb3JkZXJfbnVtYmVyOiBudW1iZXJcclxuICBzdHlsZV90eXBlOiBzdHJpbmdcclxuICB2ZXJzaW9uPzogbnVtYmVyXHJcbiAgdXBkYXRlZF9hdD86IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU3VwYWJhc2VFcnJvciB7XHJcbiAgbWVzc2FnZTogc3RyaW5nXHJcbiAgZGV0YWlscz86IHN0cmluZ1xyXG4gIGhpbnQ/OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hhcml0eUNvbnRlbnRNYW5hZ2VtZW50KCkge1xyXG4gIGNvbnN0IFtzZWN0aW9ucywgc2V0U2VjdGlvbnNdID0gdXNlU3RhdGU8Q2hhcml0eVNlY3Rpb25bXT4oW10pXHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSlcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgW2VkaXRpbmdTZWN0aW9uLCBzZXRFZGl0aW5nU2VjdGlvbl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50KClcclxuICBjb25zdCB7IHVzZXIgfSA9IHVzZUF1dGgoKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZmV0Y2hTZWN0aW9ucygpXHJcbiAgfSwgW10pXHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoU2VjdGlvbnMoKSB7XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpXHJcbiAgICBzZXRFcnJvcihudWxsKVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY2hhcml0eV9zZWN0aW9ucycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLm9yZGVyKCdvcmRlcl9udW1iZXInKVxyXG5cclxuICAgICAgaWYgKGZldGNoRXJyb3IpIHtcclxuICAgICAgICBjb25zdCBzdXBhYmFzZUVycm9yID0gZmV0Y2hFcnJvciBhcyBTdXBhYmFzZUVycm9yXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBlcnJvcjogJHtzdXBhYmFzZUVycm9yLm1lc3NhZ2V9JHtzdXBhYmFzZUVycm9yLmRldGFpbHMgPyBgIC0gJHtzdXBhYmFzZUVycm9yLmRldGFpbHN9YCA6ICcnfWApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSByZWNlaXZlZCBmcm9tIGNoYXJpdHlfc2VjdGlvbnMgdGFibGUnKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBzZXRTZWN0aW9ucyhkYXRhIGFzIENoYXJpdHlTZWN0aW9uW10pXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gZmV0Y2ggY2hhcml0eSBzZWN0aW9ucydcclxuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKVxyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjaGFyaXR5IHNlY3Rpb25zOicsIGVycilcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uKGlkOiBzdHJpbmcsIG5ld0NvbnRlbnQ6IHN0cmluZykge1xyXG4gICAgaWYgKCF1c2VyPy5lbWFpbCkge1xyXG4gICAgICB0b2FzdC5lcnJvcignWW91IG11c3QgYmUgbG9nZ2VkIGluIHRvIG1ha2UgY2hhbmdlcycpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRTZWN0aW9uID0gc2VjdGlvbnMuZmluZChzID0+IHMuaWQgPT09IGlkKVxyXG4gICAgICBpZiAoIWN1cnJlbnRTZWN0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG5vdCBmb3VuZCcpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGE6IFBhcnRpYWw8Q2hhcml0eVNlY3Rpb24+ID0ge1xyXG4gICAgICAgIGNvbnRlbnQ6IG5ld0NvbnRlbnQsXHJcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRTZWN0aW9uLnZlcnNpb24gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICB1cGRhdGVEYXRhLnZlcnNpb24gPSBjdXJyZW50U2VjdGlvbi52ZXJzaW9uICsgMVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY2hhcml0eV9zZWN0aW9ucycpXHJcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVEYXRhKVxyXG4gICAgICAgIC5lcSgnaWQnLCBpZClcclxuXHJcbiAgICAgIGlmICh1cGRhdGVFcnJvcikge1xyXG4gICAgICAgIGNvbnN0IHN1cGFiYXNlRXJyb3IgPSB1cGRhdGVFcnJvciBhcyBTdXBhYmFzZUVycm9yXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBlcnJvcjogJHtzdXBhYmFzZUVycm9yLm1lc3NhZ2V9JHtzdXBhYmFzZUVycm9yLmRldGFpbHMgPyBgIC0gJHtzdXBhYmFzZUVycm9yLmRldGFpbHN9YCA6ICcnfWApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0NoYXJpdHkgY29udGVudCB1cGRhdGVkIHN1Y2Nlc3NmdWxseScpXHJcbiAgICAgIGF3YWl0IGZldGNoU2VjdGlvbnMoKVxyXG4gICAgICBzZXRFZGl0aW5nU2VjdGlvbihudWxsKVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIHVwZGF0ZSBjaGFyaXR5IGNvbnRlbnQnXHJcbiAgICAgIHRvYXN0LmVycm9yKGVycm9yTWVzc2FnZSlcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgY2hhcml0eSBzZWN0aW9uOicsIGVycilcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChsb2FkaW5nKSByZXR1cm4gPExvYWRpbmdTcGlubmVyIHNpemU9XCJsYXJnZVwiIG1lc3NhZ2U9XCJMb2FkaW5nIENoYXJpdHkgY29udGVudC4uLlwiIGNlbnRlcmVkIC8+XHJcbiAgaWYgKGVycm9yKSByZXR1cm4gPEVycm9yTWVzc2FnZSBtZXNzYWdlPXtlcnJvcn0gLz5cclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS02XCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIG1iLTZcIj5cclxuICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkXCI+Q2hhcml0eSBDb250ZW50IE1hbmFnZW1lbnQ8L2gxPlxyXG4gICAgICA8L2Rpdj5cclxuXHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItOFwiPlxyXG4gICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtc2VtaWJvbGQgbWItNFwiPkxpdmUgVm9vcmJlZWxkIENoYXJpdHk8L2gyPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9yZGVyIGJvcmRlci1ncmF5LTcwMCByb3VuZGVkLWxnIHAtMCBiZy1ncmF5LTgwMC81MCBzaGFkb3ctaW5uZXIgb3ZlcmZsb3ctaGlkZGVuXCI+XHJcbiAgICAgICAgICB7c2VjdGlvbnMubGVuZ3RoID4gMCA/IFxyXG4gICAgICAgICAgICA8Q2hhcml0eVNlY3Rpb25QcmV2aWV3IHNlY3Rpb25zPXtzZWN0aW9uc30gLz4gOiBcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTUwMFwiPlByZXZpZXcgbm90IGF2YWlsYWJsZS48L2Rpdj5cclxuICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcblxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtc2VtaWJvbGQgbWItNFwiPkJld2VyayBTZWN0aWVzPC9oMj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ2FwLTZcIj5cclxuICAgICAgICAgIHtzZWN0aW9ucy5tYXAoKHNlY3Rpb24pID0+IChcclxuICAgICAgICAgICAgPGRpdiBrZXk9e3NlY3Rpb24uaWR9IGNsYXNzTmFtZT1cImNvbnRhaW5lci1jYXJkIHAtNlwiPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtc3RhcnQgbWItNFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZCB0ZXh0LWdyYXktMjAwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAge3NlY3Rpb24uc2VjdGlvbl9rZXkucmVwbGFjZSgvXy9nLCAnICcpLnRvVXBwZXJDYXNlKCl9XHJcbiAgICAgICAgICAgICAgICAgIDwvaDI+XHJcbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTQwMFwiPlR5cGU6IHtzZWN0aW9uLnN0eWxlX3R5cGV9PC9wPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICB7dHlwZW9mIHNlY3Rpb24udmVyc2lvbiA9PT0gJ251bWJlcicgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInB4LTIgcHktMSB0ZXh0LXhzIHJvdW5kZWQgYmctZ3JheS03MDAgdGV4dC1ncmF5LTMwMFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgdntzZWN0aW9uLnZlcnNpb259XHJcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAge2VkaXRpbmdTZWN0aW9uID09PSBzZWN0aW9uLmlkID8gKFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTRcIj5cclxuICAgICAgICAgICAgICAgICAge3NlY3Rpb24uc3R5bGVfdHlwZSA9PT0gJ2xpbmsnID8gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1pbnB1dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9e3NlY3Rpb24uY29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgIGlkPXtgZWRpdC0ke3NlY3Rpb24uaWR9YH1cclxuICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgVVJMIChlLmcuLCBleGFtcGxlLmNvbSlcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWlucHV0IGgtMzJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtzZWN0aW9uLmNvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZD17YGVkaXQtJHtzZWN0aW9uLmlkfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuLXByaW1hcnlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGVkaXQtJHtzZWN0aW9uLmlkfWApIGFzIEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBlbGVtZW50LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNlY3Rpb24oc2VjdGlvbi5pZCwgbmV3Q29udGVudClcclxuICAgICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgU2F2ZVxyXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0bi1zZWNvbmRhcnlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0RWRpdGluZ1NlY3Rpb24obnVsbCl9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgQ2FuY2VsXHJcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS00XCI+XHJcbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS0zMDAgd2hpdGVzcGFjZS1wcmUtd3JhcFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHtzZWN0aW9uLmNvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0bi1zZWNvbmRhcnlcIlxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEVkaXRpbmdTZWN0aW9uKHNlY3Rpb24uaWQpfVxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgRWRpdFxyXG4gICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgKSl9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKVxyXG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQXV0aCIsImNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCIsIkxvYWRpbmdTcGlubmVyIiwiRXJyb3JNZXNzYWdlIiwiQ2hhcml0eVNlY3Rpb25QcmV2aWV3IiwidG9hc3QiLCJDaGFyaXR5Q29udGVudE1hbmFnZW1lbnQiLCJzZWN0aW9ucyIsInNldFNlY3Rpb25zIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiZWRpdGluZ1NlY3Rpb24iLCJzZXRFZGl0aW5nU2VjdGlvbiIsInN1cGFiYXNlIiwidXNlciIsImZldGNoU2VjdGlvbnMiLCJkYXRhIiwiZmV0Y2hFcnJvciIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsInN1cGFiYXNlRXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwiZXJyIiwiZXJyb3JNZXNzYWdlIiwiY29uc29sZSIsInVwZGF0ZVNlY3Rpb24iLCJpZCIsIm5ld0NvbnRlbnQiLCJlbWFpbCIsImN1cnJlbnRTZWN0aW9uIiwiZmluZCIsInMiLCJ1cGRhdGVEYXRhIiwiY29udGVudCIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ2ZXJzaW9uIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJlcSIsInN1Y2Nlc3MiLCJzaXplIiwiY2VudGVyZWQiLCJkaXYiLCJjbGFzc05hbWUiLCJoMSIsImgyIiwibGVuZ3RoIiwibWFwIiwic2VjdGlvbiIsInNlY3Rpb25fa2V5IiwicmVwbGFjZSIsInRvVXBwZXJDYXNlIiwicCIsInN0eWxlX3R5cGUiLCJzcGFuIiwiaW5wdXQiLCJ0eXBlIiwiZGVmYXVsdFZhbHVlIiwicGxhY2Vob2xkZXIiLCJ0ZXh0YXJlYSIsImJ1dHRvbiIsIm9uQ2xpY2siLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dashboard/content/charitypage/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/preview/CharitySectionPreview.tsx":
/*!**********************************************************!*\
  !*** ./src/components/preview/CharitySectionPreview.tsx ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharitySectionPreview: function() { return /* binding */ CharitySectionPreview; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/gsap/index.js\");\n/* harmony import */ var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap/ScrollTrigger */ \"(app-pages-browser)/./node_modules/gsap/ScrollTrigger.js\");\n/* __next_internal_client_entry_do_not_use__ CharitySectionPreview auto */ var _this = undefined;\n\nvar _s = $RefreshSig$();\n\n\n\nconst renderTextPreview = function(content) {\n    let isTitle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, isLink = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    // Split into words\n    return content.split(\" \").map((word, index, array)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"\\n          inline-block\\n          animate-letter-preview\\n          \".concat(isTitle ? \"text-4xl sm:text-5xl md:text-6xl font-bold\" : \"text-lg sm:text-xl\", \"\\n          \").concat(isLink ? \"text-blue-400\" : \"text-white/90\", \" // Style links differently\\n        \"),\n                    children: word\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n                    lineNumber: 24,\n                    columnNumber: 7\n                }, _this),\n                index < array.length - 1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"inline-block w-2 sm:w-2.5\",\n                    children: \"\\xa0\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n                    lineNumber: 36,\n                    columnNumber: 9\n                }, _this)\n            ]\n        }, index, true, {\n            fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n            lineNumber: 23,\n            columnNumber: 5\n        }, _this));\n};\nfunction CharitySectionPreview(param) {\n    let { sections } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [visibleSections, setVisibleSections] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Update visible sections when props change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setVisibleSections(sections);\n    }, [\n        sections\n    ]);\n    // GSAP animaties\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_3__.ScrollTrigger);\n        const container = containerRef.current;\n        if (!container || visibleSections.length === 0) return;\n        // Simple fade-in for preview\n        const animateTextInPreview = (elements)=>{\n            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.fromTo(elements, {\n                opacity: 0,\n                y: 5\n            }, {\n                opacity: 1,\n                y: 0,\n                duration: 0.5,\n                stagger: 0.01,\n                ease: \"power2.out\"\n            });\n        };\n        // Animate letters when sections change\n        const letters = container.querySelectorAll(\".animate-letter-preview\");\n        if (letters.length > 0) {\n            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.killTweensOf(letters) // Kill previous animations first\n            ;\n            animateTextInPreview(letters);\n        }\n        return ()=>{\n            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.killTweensOf(letters);\n        };\n    }, [\n        visibleSections\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"bg-black text-white p-4 rounded-lg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"container mx-auto px-4 sm:px-6 md:px-8\",\n            children: [\n                visibleSections.filter((section)=>section.style_type === \"title\").map((section)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-center mb-12 text-white\",\n                        children: renderTextPreview(section.content, true)\n                    }, section.id, false, {\n                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n                        lineNumber: 92,\n                        columnNumber: 13\n                    }, this)),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"max-w-3xl mx-auto space-y-6\",\n                    children: [\n                        visibleSections.filter((section)=>section.style_type === \"paragraph\").map((section)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"leading-relaxed text-white/90 text-center\",\n                                children: renderTextPreview(section.content)\n                            }, section.id, false, {\n                                fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n                                lineNumber: 105,\n                                columnNumber: 15\n                            }, this)),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"mt-12 text-center\",\n                            children: [\n                                visibleSections.filter((section)=>section.section_key === \"more_info_text\").map((section)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-lg sm:text-xl font-semibold mb-4 text-white\",\n                                        children: renderTextPreview(section.content)\n                                    }, section.id, false, {\n                                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n                                        lineNumber: 118,\n                                        columnNumber: 17\n                                    }, this)),\n                                visibleSections.filter((section)=>section.style_type === \"link\").map((section)=>// Display link content as styled text in preview\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"block\",\n                                        children: renderTextPreview(section.content, false, true)\n                                    }, section.id, false, {\n                                        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n                                        lineNumber: 130,\n                                        columnNumber: 17\n                                    }, this))\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n                            lineNumber: 114,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n                    lineNumber: 101,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n            lineNumber: 87,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\jeffrey\\\\Desktop\\\\MAIN WHISKY\\\\W4CAdminPanel\\\\src\\\\components\\\\preview\\\\CharitySectionPreview.tsx\",\n        lineNumber: 86,\n        columnNumber: 5\n    }, this);\n}\n_s(CharitySectionPreview, \"sTg2XhzFKYMNcpziEqiGdYt2veM=\");\n_c = CharitySectionPreview;\nvar _c;\n$RefreshReg$(_c, \"CharitySectionPreview\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3ByZXZpZXcvQ2hhcml0eVNlY3Rpb25QcmV2aWV3LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFMEQ7QUFDL0I7QUFDdUI7QUFlbEQsTUFBTU0sb0JBQW9CLFNBQUNDO1FBQWlCQywyRUFBbUIsT0FBT0MsMEVBQWtCO0lBQ3RGLG1CQUFtQjtJQUNuQixPQUFPRixRQUFRRyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLENBQUNDLE1BQU1DLE9BQU9DLHNCQUMxQyw4REFBQ2QsdURBQWM7OzhCQUNiLDhEQUFDZ0I7b0JBQ0NDLFdBQVcseUVBSVBSLE9BREFELFVBQVUsK0NBQStDLHNCQUFxQixnQkFDbkMsT0FBM0NDLFNBQVMsa0JBQWtCLGlCQUFnQjs4QkFHOUNHOzs7Ozs7Z0JBR0ZDLFFBQVFDLE1BQU1JLE1BQU0sR0FBRyxtQkFDdEIsOERBQUNGO29CQUFLQyxXQUFVOzhCQUE0Qjs7Ozs7OztXQWIzQko7Ozs7O0FBaUJ6QjtBQUVPLFNBQVNNLHNCQUFzQixLQUF3QztRQUF4QyxFQUFFQyxRQUFRLEVBQThCLEdBQXhDOztJQUNwQyxNQUFNQyxlQUFlbkIsNkNBQU1BLENBQWlCO0lBQzVDLE1BQU0sQ0FBQ29CLGlCQUFpQkMsbUJBQW1CLEdBQUdwQiwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUUzRSw0Q0FBNEM7SUFDNUNGLGdEQUFTQSxDQUFDO1FBQ1JzQixtQkFBbUJIO0lBQ3JCLEdBQUc7UUFBQ0E7S0FBUztJQUViLGlCQUFpQjtJQUNqQm5CLGdEQUFTQSxDQUFDO1FBQ1JHLHNDQUFJQSxDQUFDb0IsY0FBYyxDQUFDbkIsNkRBQWFBO1FBRWpDLE1BQU1vQixZQUFZSixhQUFhSyxPQUFPO1FBQ3RDLElBQUksQ0FBQ0QsYUFBYUgsZ0JBQWdCSixNQUFNLEtBQUssR0FBRztRQUVoRCw2QkFBNkI7UUFDN0IsTUFBTVMsdUJBQXVCLENBQUNDO1lBQzVCeEIsc0NBQUlBLENBQUN5QixNQUFNLENBQUNELFVBQ1Y7Z0JBQUVFLFNBQVM7Z0JBQUdDLEdBQUc7WUFBRSxHQUNuQjtnQkFDRUQsU0FBUztnQkFDVEMsR0FBRztnQkFDSEMsVUFBVTtnQkFDVkMsU0FBUztnQkFDVEMsTUFBTTtZQUNSO1FBRUo7UUFFQSx1Q0FBdUM7UUFDdkMsTUFBTUMsVUFBVVYsVUFBVVcsZ0JBQWdCLENBQUM7UUFDM0MsSUFBSUQsUUFBUWpCLE1BQU0sR0FBRyxHQUFHO1lBQ3RCZCxzQ0FBSUEsQ0FBQ2lDLFlBQVksQ0FBQ0YsU0FBUyxpQ0FBaUM7O1lBQzVEUixxQkFBcUJRO1FBQ3ZCO1FBRUEsT0FBTztZQUNML0Isc0NBQUlBLENBQUNpQyxZQUFZLENBQUNGO1FBQ3BCO0lBRUYsR0FBRztRQUFDYjtLQUFnQjtJQUVwQixxQkFDRSw4REFBQ2dCO1FBQUlDLEtBQUtsQjtRQUFjSixXQUFVO2tCQUNoQyw0RUFBQ3FCO1lBQUlyQixXQUFVOztnQkFFWkssZ0JBQ0VrQixNQUFNLENBQUNDLENBQUFBLFVBQVdBLFFBQVFDLFVBQVUsS0FBSyxTQUN6Qy9CLEdBQUcsQ0FBQzhCLENBQUFBLHdCQUNILDhEQUFDRTt3QkFFQzFCLFdBQVU7a0NBRVRYLGtCQUFrQm1DLFFBQVFsQyxPQUFPLEVBQUU7dUJBSC9Ca0MsUUFBUUcsRUFBRTs7Ozs7OEJBUXJCLDhEQUFDTjtvQkFBSXJCLFdBQVU7O3dCQUNaSyxnQkFDRWtCLE1BQU0sQ0FBQ0MsQ0FBQUEsVUFBV0EsUUFBUUMsVUFBVSxLQUFLLGFBQ3pDL0IsR0FBRyxDQUFDOEIsQ0FBQUEsd0JBQ0gsOERBQUNJO2dDQUVDNUIsV0FBVTswQ0FFVFgsa0JBQWtCbUMsUUFBUWxDLE9BQU87K0JBSDdCa0MsUUFBUUcsRUFBRTs7Ozs7c0NBUXJCLDhEQUFDTjs0QkFBSXJCLFdBQVU7O2dDQUNaSyxnQkFDRWtCLE1BQU0sQ0FBQ0MsQ0FBQUEsVUFBV0EsUUFBUUssV0FBVyxLQUFLLGtCQUMxQ25DLEdBQUcsQ0FBQzhCLENBQUFBLHdCQUNILDhEQUFDSTt3Q0FFQzVCLFdBQVU7a0RBRVRYLGtCQUFrQm1DLFFBQVFsQyxPQUFPO3VDQUg3QmtDLFFBQVFHLEVBQUU7Ozs7O2dDQU9wQnRCLGdCQUNFa0IsTUFBTSxDQUFDQyxDQUFBQSxVQUFXQSxRQUFRQyxVQUFVLEtBQUssUUFDekMvQixHQUFHLENBQUM4QixDQUFBQSxVQUNILGlEQUFpRDtrREFDakQsOERBQUNJO3dDQUFtQjVCLFdBQVU7a0RBQzFCWCxrQkFBa0JtQyxRQUFRbEMsT0FBTyxFQUFFLE9BQU87dUNBRHRDa0MsUUFBUUcsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVNsQztHQWpHZ0J6QjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9wcmV2aWV3L0NoYXJpdHlTZWN0aW9uUHJldmlldy50c3g/ZGQxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgZ3NhcCB9IGZyb20gJ2dzYXAnXHJcbmltcG9ydCB7IFNjcm9sbFRyaWdnZXIgfSBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInXHJcblxyXG4vLyBEZWZpbmUgQ2hhcml0eVNlY3Rpb24gaW50ZXJmYWNlIGJhc2VkIG9uIGZyb250ZW5kIGNvZGVcclxuaW50ZXJmYWNlIENoYXJpdHlTZWN0aW9uIHtcclxuICBpZDogc3RyaW5nXHJcbiAgc2VjdGlvbl9rZXk6IHN0cmluZ1xyXG4gIGNvbnRlbnQ6IHN0cmluZ1xyXG4gIG9yZGVyX251bWJlcjogbnVtYmVyXHJcbiAgc3R5bGVfdHlwZTogc3RyaW5nIC8vICd0aXRsZScsICdwYXJhZ3JhcGgnLCAnbGluaydcclxufVxyXG5cclxuaW50ZXJmYWNlIENoYXJpdHlTZWN0aW9uUHJldmlld1Byb3BzIHtcclxuICBzZWN0aW9uczogQ2hhcml0eVNlY3Rpb25bXVxyXG59XHJcblxyXG5jb25zdCByZW5kZXJUZXh0UHJldmlldyA9IChjb250ZW50OiBzdHJpbmcsIGlzVGl0bGU6IGJvb2xlYW4gPSBmYWxzZSwgaXNMaW5rOiBib29sZWFuID0gZmFsc2UpID0+IHtcclxuICAvLyBTcGxpdCBpbnRvIHdvcmRzXHJcbiAgcmV0dXJuIGNvbnRlbnQuc3BsaXQoJyAnKS5tYXAoKHdvcmQsIGluZGV4LCBhcnJheSkgPT4gKFxyXG4gICAgPFJlYWN0LkZyYWdtZW50IGtleT17aW5kZXh9PlxyXG4gICAgICA8c3BhbiBcclxuICAgICAgICBjbGFzc05hbWU9e2BcclxuICAgICAgICAgIGlubGluZS1ibG9ja1xyXG4gICAgICAgICAgYW5pbWF0ZS1sZXR0ZXItcHJldmlld1xyXG4gICAgICAgICAgJHtpc1RpdGxlID8gJ3RleHQtNHhsIHNtOnRleHQtNXhsIG1kOnRleHQtNnhsIGZvbnQtYm9sZCcgOiAndGV4dC1sZyBzbTp0ZXh0LXhsJ31cclxuICAgICAgICAgICR7aXNMaW5rID8gJ3RleHQtYmx1ZS00MDAnIDogJ3RleHQtd2hpdGUvOTAnfSAvLyBTdHlsZSBsaW5rcyBkaWZmZXJlbnRseVxyXG4gICAgICAgIGB9XHJcbiAgICAgID5cclxuICAgICAgICB7d29yZH1cclxuICAgICAgPC9zcGFuPlxyXG4gICAgICB7LyogQWRkIHNwYWNlIGJldHdlZW4gd29yZHMgKi99XHJcbiAgICAgIHtpbmRleCA8IGFycmF5Lmxlbmd0aCAtIDEgJiYgKFxyXG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImlubGluZS1ibG9jayB3LTIgc206dy0yLjVcIj4mbmJzcDs8L3NwYW4+XHJcbiAgICAgICl9XHJcbiAgICA8L1JlYWN0LkZyYWdtZW50PlxyXG4gICkpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDaGFyaXR5U2VjdGlvblByZXZpZXcoeyBzZWN0aW9ucyB9OiBDaGFyaXR5U2VjdGlvblByZXZpZXdQcm9wcykge1xyXG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbClcclxuICBjb25zdCBbdmlzaWJsZVNlY3Rpb25zLCBzZXRWaXNpYmxlU2VjdGlvbnNdID0gdXNlU3RhdGU8Q2hhcml0eVNlY3Rpb25bXT4oW10pXHJcblxyXG4gIC8vIFVwZGF0ZSB2aXNpYmxlIHNlY3Rpb25zIHdoZW4gcHJvcHMgY2hhbmdlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHNldFZpc2libGVTZWN0aW9ucyhzZWN0aW9ucylcclxuICB9LCBbc2VjdGlvbnNdKVxyXG5cclxuICAvLyBHU0FQIGFuaW1hdGllc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpXHJcbiAgICBcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50XHJcbiAgICBpZiAoIWNvbnRhaW5lciB8fCB2aXNpYmxlU2VjdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm5cclxuXHJcbiAgICAvLyBTaW1wbGUgZmFkZS1pbiBmb3IgcHJldmlld1xyXG4gICAgY29uc3QgYW5pbWF0ZVRleHRJblByZXZpZXcgPSAoZWxlbWVudHM6IE5vZGVMaXN0T2Y8RWxlbWVudD4pID0+IHtcclxuICAgICAgZ3NhcC5mcm9tVG8oZWxlbWVudHMsIFxyXG4gICAgICAgIHsgb3BhY2l0eTogMCwgeTogNSB9LCBcclxuICAgICAgICB7IFxyXG4gICAgICAgICAgb3BhY2l0eTogMSwgXHJcbiAgICAgICAgICB5OiAwLCBcclxuICAgICAgICAgIGR1cmF0aW9uOiAwLjUsIFxyXG4gICAgICAgICAgc3RhZ2dlcjogMC4wMSwgXHJcbiAgICAgICAgICBlYXNlOiBcInBvd2VyMi5vdXRcIixcclxuICAgICAgICB9XHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbmltYXRlIGxldHRlcnMgd2hlbiBzZWN0aW9ucyBjaGFuZ2VcclxuICAgIGNvbnN0IGxldHRlcnMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmFuaW1hdGUtbGV0dGVyLXByZXZpZXcnKVxyXG4gICAgaWYgKGxldHRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZihsZXR0ZXJzKSAvLyBLaWxsIHByZXZpb3VzIGFuaW1hdGlvbnMgZmlyc3RcclxuICAgICAgYW5pbWF0ZVRleHRJblByZXZpZXcobGV0dGVycylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZihsZXR0ZXJzKVxyXG4gICAgfVxyXG5cclxuICB9LCBbdmlzaWJsZVNlY3Rpb25zXSlcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgcmVmPXtjb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cImJnLWJsYWNrIHRleHQtd2hpdGUgcC00IHJvdW5kZWQtbGdcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgbXgtYXV0byBweC00IHNtOnB4LTYgbWQ6cHgtOFwiPlxyXG4gICAgICAgIHsvKiBUaXRsZSAqL31cclxuICAgICAgICB7dmlzaWJsZVNlY3Rpb25zXHJcbiAgICAgICAgICAuZmlsdGVyKHNlY3Rpb24gPT4gc2VjdGlvbi5zdHlsZV90eXBlID09PSAndGl0bGUnKVxyXG4gICAgICAgICAgLm1hcChzZWN0aW9uID0+IChcclxuICAgICAgICAgICAgPGgxIFxyXG4gICAgICAgICAgICAgIGtleT17c2VjdGlvbi5pZH0gXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgbWItMTIgdGV4dC13aGl0ZVwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICB7cmVuZGVyVGV4dFByZXZpZXcoc2VjdGlvbi5jb250ZW50LCB0cnVlKX1cclxuICAgICAgICAgICAgPC9oMT5cclxuICAgICAgICAgICkpfVxyXG5cclxuICAgICAgICB7LyogQ29udGVudCAqL31cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTN4bCBteC1hdXRvIHNwYWNlLXktNlwiPlxyXG4gICAgICAgICAge3Zpc2libGVTZWN0aW9uc1xyXG4gICAgICAgICAgICAuZmlsdGVyKHNlY3Rpb24gPT4gc2VjdGlvbi5zdHlsZV90eXBlID09PSAncGFyYWdyYXBoJylcclxuICAgICAgICAgICAgLm1hcChzZWN0aW9uID0+IChcclxuICAgICAgICAgICAgICA8cCBcclxuICAgICAgICAgICAgICAgIGtleT17c2VjdGlvbi5pZH0gXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsZWFkaW5nLXJlbGF4ZWQgdGV4dC13aGl0ZS85MCB0ZXh0LWNlbnRlclwiXHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge3JlbmRlclRleHRQcmV2aWV3KHNlY3Rpb24uY29udGVudCl9XHJcbiAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICApKX1cclxuXHJcbiAgICAgICAgICB7LyogTW9yZSBJbmZvICYgTGlua3MgU2VjdGlvbiAqL31cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMTIgdGV4dC1jZW50ZXJcIj5cclxuICAgICAgICAgICAge3Zpc2libGVTZWN0aW9uc1xyXG4gICAgICAgICAgICAgIC5maWx0ZXIoc2VjdGlvbiA9PiBzZWN0aW9uLnNlY3Rpb25fa2V5ID09PSAnbW9yZV9pbmZvX3RleHQnKVxyXG4gICAgICAgICAgICAgIC5tYXAoc2VjdGlvbiA9PiAoXHJcbiAgICAgICAgICAgICAgICA8cCBcclxuICAgICAgICAgICAgICAgICAga2V5PXtzZWN0aW9uLmlkfSBcclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1sZyBzbTp0ZXh0LXhsIGZvbnQtc2VtaWJvbGQgbWItNCB0ZXh0LXdoaXRlXCJcclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAge3JlbmRlclRleHRQcmV2aWV3KHNlY3Rpb24uY29udGVudCl9XHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB7dmlzaWJsZVNlY3Rpb25zXHJcbiAgICAgICAgICAgICAgLmZpbHRlcihzZWN0aW9uID0+IHNlY3Rpb24uc3R5bGVfdHlwZSA9PT0gJ2xpbmsnKVxyXG4gICAgICAgICAgICAgIC5tYXAoc2VjdGlvbiA9PiAoXHJcbiAgICAgICAgICAgICAgICAvLyBEaXNwbGF5IGxpbmsgY29udGVudCBhcyBzdHlsZWQgdGV4dCBpbiBwcmV2aWV3XHJcbiAgICAgICAgICAgICAgICA8cCBrZXk9e3NlY3Rpb24uaWR9IGNsYXNzTmFtZT1cImJsb2NrXCI+XHJcbiAgICAgICAgICAgICAgICAgICB7cmVuZGVyVGV4dFByZXZpZXcoc2VjdGlvbi5jb250ZW50LCBmYWxzZSwgdHJ1ZSl9XHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApXHJcbn0gIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJnc2FwIiwiU2Nyb2xsVHJpZ2dlciIsInJlbmRlclRleHRQcmV2aWV3IiwiY29udGVudCIsImlzVGl0bGUiLCJpc0xpbmsiLCJzcGxpdCIsIm1hcCIsIndvcmQiLCJpbmRleCIsImFycmF5IiwiRnJhZ21lbnQiLCJzcGFuIiwiY2xhc3NOYW1lIiwibGVuZ3RoIiwiQ2hhcml0eVNlY3Rpb25QcmV2aWV3Iiwic2VjdGlvbnMiLCJjb250YWluZXJSZWYiLCJ2aXNpYmxlU2VjdGlvbnMiLCJzZXRWaXNpYmxlU2VjdGlvbnMiLCJyZWdpc3RlclBsdWdpbiIsImNvbnRhaW5lciIsImN1cnJlbnQiLCJhbmltYXRlVGV4dEluUHJldmlldyIsImVsZW1lbnRzIiwiZnJvbVRvIiwib3BhY2l0eSIsInkiLCJkdXJhdGlvbiIsInN0YWdnZXIiLCJlYXNlIiwibGV0dGVycyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJraWxsVHdlZW5zT2YiLCJkaXYiLCJyZWYiLCJmaWx0ZXIiLCJzZWN0aW9uIiwic3R5bGVfdHlwZSIsImgxIiwiaWQiLCJwIiwic2VjdGlvbl9rZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/preview/CharitySectionPreview.tsx\n"));

/***/ })

});